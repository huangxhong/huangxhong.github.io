<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 谈 implementation  vs api  maven vs GradleMetadata · dim's blog</title><meta name="description" content="谈 implementation  vs api  maven vs GradleMetadata - Dim"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="stylesheet" href="/css/disqusjs.css"><link rel="search" type="application/opensearchdescription+xml" href="http://dim.red/atom.xml" title="dim's blog"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">博客</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">文章</a></li><li class="nav-list-item"><a href="/about/" target="_self" class="nav-list-link">关于</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">谈 implementation  vs api  maven vs GradleMetadata</h1><div class="post-info">Dec 26, 2019</div><div class="post-content"><h1 id="0x00-环境"><a href="#0x00-环境" class="headerlink" title="0x00  环境"></a>0x00  环境</h1><p>Gradle: 4.10.2<br>Android Gradle Plugin: 3.2.0</p>
<h1 id="0x01-背景"><a href="#0x01-背景" class="headerlink" title="0x01  背景"></a>0x01  背景</h1><p>Android Gradle Plugin 3.0 以后依赖声明使用了 <code>implementation</code> 和 <code>api</code> 来替代原来的 compile 。提供了对依赖进行更细致的控制。<br>这一特性是由 JavaLibraryPlugin 中衍生过来的。 更准确的来说是 JavaBasePlugin 。Android 并不依赖 JavaLibraryPlugin。</p>
<p>好处:</p>
<ol>
<li>隐藏实现细节,  隐藏内部接口。</li>
<li><p>加快编译速度。</p>
<p>相关链接: <a href="https://developer.android.com/studio/build/gradle-plugin-3-0-0-migration?hl=zh-cn#new_configurations" target="_blank" rel="noopener">迁移到 Android Plugin for Gradle 3.0.0 - 使用新依赖项配置</a></p>
<a id="more"></a>
</li>
</ol>
<h1 id="0x02-JavaLibraryPlugin-实现"><a href="#0x02-JavaLibraryPlugin-实现" class="headerlink" title="0x02  JavaLibraryPlugin 实现"></a>0x02  JavaLibraryPlugin 实现</h1><h2 id="2-1-声明方式"><a href="#2-1-声明方式" class="headerlink" title="2.1 声明方式"></a>2.1 声明方式</h2><p>Gradle 是使用 Configuration 表示一组依赖。<br> 如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    compile &apos;com.google.code.gson:gson:2.8.5&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>为名称为 <code>compile</code> 的 <code>Configuration</code> 声明 gson 依赖，版本为 2.8.5。同样的可以为  <code>api</code> ， <code>implementation</code> 或自定义的 <code>Configuration</code> 声明依赖。</p>
<h2 id="2-2-Configuration"><a href="#2-2-Configuration" class="headerlink" title="2.2 Configuration"></a>2.2 Configuration</h2><p>JavaLibraryPlugin 会生成主要的几个 Configuration：<code>api</code>,<code>compile</code>,<code>compileOnly</code>,<code>compileClasspath (JAVA_API)</code>,<code>implementation</code>,<code>runtime</code>,<code>runtimeOnly</code>,<code>runtimeClasspath (JAVA_RUNTIME)</code>,<code>apiElements (JAVA_API)</code>,<code>runtimeElements (JAVA_RUNTIME_JARS)</code>  .</p>
<p>Configuration 存在继承关系：</p>
<ol>
<li>api 继承 compile</li>
<li>implementation 继承 compile , api</li>
<li>compileClasspath 继承  implementation ,  compileOnly</li>
<li>runtime  继承 compile</li>
<li>runtimeClasspath  继承  implementation ,  runtime  , runtimeOnly </li>
<li>apiElements 继承 api</li>
<li>runtimeElements 继承 runtime ,  runtimeOnly , implementation</li>
</ol>
<ul>
<li>继承： 如果 A 继承了 B。 那么存在在 B 上的依赖。也必将存在 A 上。</li>
</ul>
<p>Classpath 类型:<br>compileClasspath runtimeClasspath  总结如下<br><img src="/2019/12/26/implementation_api_maven_gradle_metadata/img1.png" alt="总结1"></p>
<p>Elements 类型:<br>apiElements runtimeElements 总结如下<br><img src="/2019/12/26/implementation_api_maven_gradle_metadata/img2.png" alt="总结2"><br>这里 Configuration  主要分为 3 种：</p>
<ol>
<li>用于声明，不能被解析和获取。如 compile implementation api runtime runtimeOnly 用于声明依赖.</li>
<li>用于本工程获取消费使用。如 compileClasspath ，runtimeClasspath 用于参与工程的编译或运行。</li>
<li>提供给其他工程消费使用。如 apiElements<br>runtimeElements 提供其他工程编译或运行时的所需的 ClassPaths。</li>
</ol>
<p>JavaLibraryPlugin 将生成的 jar  文件注册在 apiElements 和 runtimeElements 上。<br>将 javac 产生的 class 文件注册在 apiElements  上。注册就能被其他工程通过对应的 Configuration 获取到 。</p>
<p>主工程通过 compileClasspath (JAVA_API) 可以获取到子工程的 apiElements(JAVA_API)。 同时能获取到子工程的  class 文件以及 apiElements 上的声明依赖（ 来自 api 和 compile 声明）。</p>
<h5 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h5><p>通过下面例子了解 api 和 implementation 更多的区别：<br><img src="/2019/12/26/implementation_api_maven_gradle_metadata/img3.png" alt="例子">  </p>
<p>描述: app 用 implementation 方式依赖 lib ，lib 使用 api 方式依赖 libsub1 和 implement 方式依赖了libsub2。 </p>
<p>以 app 工程 javac task 为例说明:<br>javac task 的实现类 JavaCompile。 该任务将 java 文件编译成 jvm 能执行的 class 。 在这个过程中有两个主要的输入 source 和 classpath。<br>source 是工程中的 java 文件集合。 classpath 是 javac 编译时需要的 class 路径。这里包括 jdk 和工程的依赖 。 依赖的通过 compileClasspath 获取。</p>
<h6 id="1-隐藏实现细节-隐藏内部接口。"><a href="#1-隐藏实现细节-隐藏内部接口。" class="headerlink" title="1. 隐藏实现细节, 隐藏内部接口。"></a>1. 隐藏实现细节, 隐藏内部接口。</h6><p>compileClasspath 获取链路如下。<br><img src="/2019/12/26/implementation_api_maven_gradle_metadata/img4.png" alt="compileClasspath 获取链路">  </p>
<p>可知。 app 的  compileClasspath 中只有 lib 和 libsub1 ，libsub2 因为使用 implement 而不出现 app 的编译路径中。<br>这样的好处就是对于 lib 来说，它最小化的对外提供了信息， 屏蔽了 libsub2 的存在。</p>
<h6 id="2-编译加速。"><a href="#2-编译加速。" class="headerlink" title="2. 编译加速。"></a>2. 编译加速。</h6><p>加速主要是两点</p>
<p><strong>1. 依托 Gradle 任务的 Task 的 UP-TO-DATE 特性。</strong></p>
<p>一个任务的输入和输出没有变更。该任务不执行。直接使用上次的输出文件为结果。则该任务为 UP-TO-DATE  。<br>javac 的 classpath 被 <code>@Classpath</code>  和 <code>@CompileClasspath</code> 注解表示。<br>通过之前的文章  <a href="https://dim.red/2018/08/24/gradle_task_UP-TO-DATE/">Gradle Task UP-TO-DATE</a> 可知。在这两个注解下 Gradle 会对 classpath 的 class 文件进行重新排序和 ABI 化。 </p>
<p>这样的好处在于</p>
<ol>
<li>对于 implementation 依赖的 libsub2 发生变更。 如果对 ABI 没有变化。 如修改了方法体或修改私有方法或属性等。只有 libsub2 的 javac task 重新编译。lib 和 app 的 javac task 将跳过执行直接使用上次的输出结果。 </li>
<li>对于 implementation 依赖的 libsub2 发生变更。 且 ABI  进行了变化。 那么 lib 的 javac task 将重新编译。 app 的 javac task 是否重新编译，取决于  lib 的 ABI 是否发生变化。</li>
<li>对于 api 依赖的  libsub1 发生变更，如果对 ABI 没有变更。 那么只有libsub1  javac task 重新编译。lib 和 app 的 javac task 使用上次的输出。</li>
<li>对于 api 依赖的  libsub1 发生变更，如果对 ABI 发生变更。 那么无论如何 libsub1，lib ，app  javac task 都将重新编译。</li>
</ol>
<p>通过尽可能的让任务  UP-TO-DATE 减少编译时长。这里所有的优化的都是在增量编译的情况下生效。 </p>
<p>注：<br> ABI 化: 删除了所有私有的方法和字段。 同时删除了所有方法的方法体。具体可查看 AbiExtractingClasspathResourceHasher<br>ABI 变更：修改，新增，删除了 非私有 方法签名。修改或新增了非私有属性 等都将引起 ABI 变更。</p>
<p><strong>2 javac  task classpath 的缩减。</strong><br>由于出现的 编译的 classpath 路径减少 ，让 javac 编译时查找对应类减少几次查找从而加快编译速度。 这一块的加速个人感官上是很轻微的。</p>
<p>总结： implementation 和 api 并不会影响本工程的编译或运行。它只影响本工程对外提供的依赖列表。</p>
<h1 id="0x03-Android-Gradle-Plugin-实现"><a href="#0x03-Android-Gradle-Plugin-实现" class="headerlink" title="0x03  Android Gradle Plugin 实现"></a>0x03  Android Gradle Plugin 实现</h1><h2 id="3-1-android-工程应用"><a href="#3-1-android-工程应用" class="headerlink" title="3.1 android 工程应用"></a>3.1 android 工程应用</h2><p>Android 在原有的纬度加入了 Flavor 和 BuildType 的纬度。 使复杂层度上了一个台阶。变成了 xxCompile xxApi xxRuntime 。 对于 java 项目而言对外提供两种 Configuration：编译期 apiElements 和 运行期 runtimeElements 各一个。Android 因为存在  Flavor 和 BuildType 。 虽然它对外提供的也是两种 Configuration。 但每种 Configuration 又存在多个变种。默认情况下编译期 debugApiElements 和 releaseApiElements。 运行期 debugRuntimeElements 和 releaseRuntimeElements。加入 flavor 以后复杂度又翻了一倍。 </p>
<p>在 AGP  2.x 的时候 主工程 BuildType 不管是 Debug 或 Release 默认都使用 Library 的 Release。 3.0 以后开始对这种情况进行优化。Debug  工程引用 Library 的 Debug。Release 工程使用 Library 的 Release 。<br>实现的原理在于为这些提供 apiElements / runtimeElements 的 Configuration 在原有的属性加入了  BuildType 和 Flavor 属性信息。<br>Configuration 在查找的时候，如果只查到一个，检查双方的属性是否相等或相兼容。 检查成功则选择该 Configuration， 如果查询出现多个的时候， 会根据查找的属性的进行选择，找到一个匹配最全的， 如果没有最全的。 则进行择优匹配。对单个属性值根据规则逐一进行比较，丢弃相对较差的 Configuration。 （ 查找的属性+ 候选的属性）。这样如果选择出最合适的一个则选择该Configuration 。否则查找失败。<br>这里涉及到的兼容和择优的规则参考之前 <a href="https://dim.red/2018/01/25/gradle_transform_%20exploration/">Gradle Transform 初探</a> 的文章 rule 相关信息。</p>
<p>  对于Android  compileClasspath 只参与编译本工程的 java 文件.  最终还需要将 runtimeClasspath 打入 apk 中。<br>Android Configuration 设置详情查看 VariantDependencies<br>Configuration 属性匹配详情查看 ComponentAttributeMatcher</p>
<h2 id="3-2-隐藏存在的问题。"><a href="#3-2-隐藏存在的问题。" class="headerlink" title="3.2 隐藏存在的问题。"></a>3.2 隐藏存在的问题。</h2><p>Android dependency ‘com.android.support:support-support-v4’ has different version for the compile (25.2.0) and runtime (26.0.0-beta2) classpath. You should manually set the same version via DependencyResolution.<br>一个依赖存在  编译期 和运行期。 不可避免会发生同个依赖在两边的依赖版本不一致的问题。这可能导致 API 的不兼容或 ClassNotFound 等问题。 为此 Android 在 prebuild 会对两个 Configuration 的依赖进行版本比较。</p>
<p>详情查看 AppPreBuildTask </p>
<h1 id="0x04-Maven"><a href="#0x04-Maven" class="headerlink" title="0x04 Maven"></a>0x04 Maven</h1><p>Gradle 的依赖分为本地和远程， 本地依赖有本地工程或者本地文件。 远程依赖的有 Maven 和 ivy 依赖。 Gradle 天生支持 Maven 依赖。Gradle 使用 GradlePomModuleDescriptorParser 对 pom 文件进行解析。 pom 文件是 maven 依赖的描述。 主要包括以下几个属性：</p>
<ol>
<li>groupId artifactId version: 表示组件的基本信息。</li>
<li>dependencyManagement: 这个主要是来管理多个 pom 文件的依赖版本问题。dependency 中的依赖没有找到版本或配置。将从这个属性中获取默认的版本和配置。</li>
<li>dependencies: 表示这个组件的依赖项列表。</li>
<li>dependency: 包含在dependencies 里。表示其中的一个依赖<br>由 groupId , artifactId , version , scope , classifier , optional , exclusions 等组成。 一个依赖可以存在多个 classifier 。sources ，javadoc 等等。 对于 android 来说，有 debug 和 release 两个 classifier  。</li>
<li>scope:  表示依赖运作的范围，主要有 compile，runtime，provided，test，  system，import<br>test: 表示仅参与工程测试使用<br>compile: 表示在工程编译中使用。<br>runtime: 表示在仅在工程在运行中使用。<br>provided: 表示仅在工程编译中使用。<br>system: 类似于provided。 不同的是他不需要从远端下载。<br>import: 这里不展开，主要和 dependencyManagement 一起配合使用做版本控制。</li>
</ol>
<p>Gradle 为 Maven 依赖提供 10 种 Configuration 来管理。<code>default</code>，<code>master</code>，<code>compile</code>，<code>provided</code>，<code>runtime</code>，<code>test</code>，<code>system</code>，<code>sources</code>，<code>javadoc</code>，<code>optional</code>。  </p>
<p>详情查看  GradlePomModuleDescriptorBuilder.MAVEN2_CONFIGUR   </p>
<p> Configuration 对应 Maven 的 scope  ，这里会发现 scope 的种类只有5个 (不包含 import)。 但是Configuration 却有10个这么多。 追其原因这是为了兼容  ivy 格式的依赖。 Maven 依赖列表中不一定都是 Maven 依赖。 也可能是 ivy 依赖。ivy 相关可以查看链接 <a href="http://ant.apache.org/ivy/history/latest-milestone/ivyfile/dependency.html" target="_blank" rel="noopener">ivyfile-dependency</a></p>
<p>不同的 Configuration 获取的依赖是不同的。 这里不讨论 ivy 的兼容，根据 Maven 的特性介绍几个重要的 Configuration。 </p>
<ol>
<li>default: 获取  scope 为的 compile 和 runtime 的依赖。 </li>
<li>compile: 获取 scope 为的 compile 的依赖。</li>
<li>runtime: 获取  scope 为的 compile 和 runtime  的依赖</li>
<li>test: 获取 scope 为的  test  的依赖</li>
<li>provided: 获取 scope 为的 provided  的依赖。<br>这里仅仅针对声明的一级依赖。 二级依赖（一级依赖的依赖列表）解析就并非如此。</li>
</ol>
<p>二级依赖解析规则如下。  compile 获取  scope 为的 compile 的依赖。其他均获取  scope 为的 compile 和 runtime  的依赖。  scope 非  compile /runtime  均会被忽略。或许设计便是如此。<br>详情查看 MavenDependencyDescriptor.selectLegacyConfigurations</p>
<p>注意 本小节的 Configuration 不等于的 Gradle 的 Configuration。</p>
<h4 id="Configuration-的使用"><a href="#Configuration-的使用" class="headerlink" title="Configuration 的使用"></a>Configuration 的使用</h4><p>1.默认 Configuration</p>
<p>默认 Configuration 为 default 。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compile &quot;com.dim:lib:1.0&quot;</span><br></pre></td></tr></table></figure></p>
<p>等价<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compile (group: &apos;com.dim&apos;, name: &apos;lib&apos;, version: &apos;1.0&apos;,configuration:&quot;defalut&quot;)</span><br></pre></td></tr></table></figure></p>
<p>2.实现 implementation，api 的效果</p>
<p>Maven 的 scope 存在 rumtime 和 compile 。 应对到 Gradle 的 apiElements 和 runtimeElements 。</p>
<p>java 工程<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">api / implementation project(&quot;:dim&quot;)</span><br></pre></td></tr></table></figure></p>
<p>替换<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">api / implementation (group: &apos;com.dim&apos;, name: &apos;lib&apos;, version: &apos;1.0&apos;,configuration:&quot;compile&quot;)</span><br><span class="line">runtime (group: &apos;com.dim&apos;, name: &apos;lib&apos;, version: &apos;1.0&apos;,configuration:&quot;runtime&quot;)</span><br></pre></td></tr></table></figure></p>
<p>Android 工程<br>因为 Android 存在 debug 和 release ，所以较为复杂，debug / release在 maven 中以 classifier 的形式存在。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">debugApi / debugImplementation (group: &apos;com.dim&apos;, name: &apos;lib&apos;, version: &apos;1.0&apos;,classifier: &apos;debug&apos;, configuration:&quot;compile&quot;)</span><br><span class="line">debugRuntime (group: &apos;com.dim&apos;, name: &apos;lib&apos;, version: &apos;1.0&apos;,classifier: &apos;debug&apos;,configuration:&quot;runtime&quot;)</span><br><span class="line">releaseApi / releaseImplementation (group: &apos;com.dim&apos;, name: &apos;lib&apos;, version: &apos;1.0&apos;,classifier: &apos;release&apos;, configuration:&quot;compile&quot;)</span><br><span class="line">releaseRuntime (group: &apos;com.dim&apos;, name: &apos;lib&apos;, version: &apos;1.0&apos;,classifier: &apos;release&apos;,configuration:&quot;runtime&quot;)</span><br></pre></td></tr></table></figure></p>
<p>android 上的实现略显臃肿，有什么办法解决呢？ Gradle Metadata ？</p>
<h1 id="0x05-Gradle-Metadata"><a href="#0x05-Gradle-Metadata" class="headerlink" title="0x05 Gradle Metadata"></a>0x05 Gradle Metadata</h1><p>为了弥补 Maven 的局限， Gradle 引入 Gradle  Metadata。<br>它在原有的基础上加入  .module 文件来扩展 Maven 的 pom 功能。<br>这里去掉了 Scope 的概念，转为 Variant 。对 pom 依赖进行重新组合。 一组依赖就是一个 Variant 。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;formatVersion&quot;: &quot;0.4&quot;,</span><br><span class="line">  &quot;component&quot;: &#123;</span><br><span class="line">    &quot;group&quot;: &quot;com.dim&quot;,</span><br><span class="line">    &quot;module&quot;: &quot;lib&quot;,</span><br><span class="line">    &quot;version&quot;: &quot;1.0&quot;,</span><br><span class="line">    &quot;attributes&quot;: &#123;</span><br><span class="line">      &quot;org.gradle.status&quot;: &quot;release&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;createdBy&quot;: &#123;</span><br><span class="line">    &quot;gradle&quot;: &#123;</span><br><span class="line">      &quot;version&quot;: &quot;4.10.2&quot;,</span><br><span class="line">      &quot;buildId&quot;: &quot;priv3n7sd5bvbpnahf26lakzju&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;variants&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;name&quot;: &quot;debugApiElements&quot;,</span><br><span class="line">      &quot;attributes&quot;: &#123;</span><br><span class="line">        &quot;com.android.build.api.attributes.BuildTypeAttr&quot;: &quot;debug&quot;,</span><br><span class="line">        &quot;com.android.build.api.attributes.VariantAttr&quot;: &quot;debug&quot;,</span><br><span class="line">        &quot;com.android.build.gradle.internal.dependency.AndroidTypeAttr&quot;: &quot;Aar&quot;,</span><br><span class="line">        &quot;org.gradle.usage&quot;: &quot;java-api&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">        &quot;dependencies&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;group&quot;: &quot;com.google.code.gson&quot;,</span><br><span class="line">          &quot;module&quot;: &quot;gson&quot;,</span><br><span class="line">          &quot;version&quot;: &#123;</span><br><span class="line">            &quot;requires&quot;: &quot;2.8.5&quot;,</span><br><span class="line">            &quot;reject&quot;: &quot;2.7.0&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      &quot;files&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;name&quot;: &quot;lib-debug.aar&quot;,</span><br><span class="line">          &quot;url&quot;: &quot;lib-debug.aar&quot;,</span><br><span class="line">          &quot;size&quot;: 21590,</span><br><span class="line">          &quot;sha1&quot;: &quot;afafefc0dccfcfb0246dc9201868e12e83df04ac&quot;,</span><br><span class="line">          &quot;md5&quot;: &quot;7374a663e6ba72a82ba767f92a2bf810&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">    .</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这是一个 Variant 的描述。<br>.module 文件生成和解析查看<br>ModuleMetadataFileGenerator.generateTo()<br>ModuleMetadataParser.parse()</p>
<p>Variant 几乎是 Gradle Configuration 的翻译。它甚至可以指定版本约束，如拒绝某个依赖版本。Metadata 可以和 Gradle 的 Configuration 系统做完美的结合。 实现了依赖 Project 是什么样子，依赖 Project 生成的 Gradle Metadata 便是什么样子。</p>
<p>Gradle Metadata 只是一个 Gradle 的改进。 对于 Maven 发布的时候，不仅 .module 存在， pom 文件也会被保留。 这样的好处是当 Gradle Metadata  不兼容的情况下使用 pom 文件进行降级。同时不影响其他编译工具对 Maven 的支持。</p>
<h2 id="5-1-使用"><a href="#5-1-使用" class="headerlink" title="5.1 使用"></a>5.1 使用</h2><h3 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">enableFeaturePreview(&quot;GRADLE_METADATA&quot;)</span><br></pre></td></tr></table></figure>
<p>全局启用了 GRADLE_METADATA 特性，该特性会为所有仓库会先检查是否存在 .module。 查询失败降级查询 pom 文件。java 工程原生支持 Gradle Metadata。Gradle 6.0 以下在该特性下 使用 maven-publish 插件发布的时候自动会带上 .module 信息。6.0 默认自动带上.module  文件。</p>
<h3 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h3><p>由于并不不是所有仓库都支持 Gradle Metadata 。所有仓库都先查询一遍 module ，这或许过于浪费。可以为单一的仓库设置。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">repositories &#123;</span><br><span class="line">    maven &#123;</span><br><span class="line">        url = &quot;xxx&quot;</span><br><span class="line">        metadataSources(&#123;</span><br><span class="line">            it.gradleMetadata()</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>有了 Gradle Metadata 加持下。 可以很方便的实现 类似 implementation  和 api 的效果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">api / implementation project(&quot;:dim&quot;)</span><br></pre></td></tr></table></figure></p>
<p>等价<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">api / implementatio &quot;com.dim:lib:1.0&quot;</span><br></pre></td></tr></table></figure></p>
<p>Gradle Metadata  在当前的环境下并非没有缺点</p>
<ol>
<li>当前4.10.2的 Gradle Metadata 以一个 feature 的形式存在。 并不直接提供这些功能，在 6.0 才正式完整支持。</li>
<li>当前版本 .module 文件格式并不稳定，4.10.2 的版本为 0.4 。 6.0 的版本为1.1。 不同版本并不能兼容使用。</li>
<li>内部 API  。如果要自定义这个特性。 需要继承 SoftwareComponentInternal 。 它位于 org.gradle.api.internal.component。 还未正式放出来。 即使是 6.0 也存在这个问题。对于 Android 就更为苛刻。</li>
<li>发布插件。Gradle 默认提供两种发布插件 maven 和 maven-publish 。 这个特性当前只存在 maven-publish。 android 默认情况下只支持 maven 。  </li>
<li>依赖 classifier  丢失。<br>Maven 支持一个依赖存在多个 classifier。 Gradle Metadata 在写入的时候会丢失这部分信息。 这是当前使用唯一遇到的天坑，该错误在8月份被修复，mr <a href="https://github.com/gradle/gradle/issues/10189" target="_blank" rel="noopener">Publish classifier/artifact selection to GMM</a> 在  6.0 RC1 合入。 同时也被带入到 6.0 正式版本中。现阶段提供一个兼容方案。 不直接依赖存在 classifier 的依赖。依赖一个中间依赖。 中间依赖再依赖这个  classifier 的依赖。 中间依赖使用 pom 文件， 不使用 .module。用这种方案来规避 Metadata 序列化的 bug 。</li>
<li>成本提高。<br>对依赖更细致的控制。学习成本变高，对于开发人员素质要求变高。<br>更多 Gradle Metadata 细节查看  <a href="https://blog.gradle.org/gradle-metadata-1.0" target="_blank" rel="noopener">Introducing Gradle Module Metadata</a> 。</li>
</ol>
<p>Gradle 觉得 Metadata 可以帮我们逃离依赖地狱。 或许可以或许通往另外一个地狱。</p>
<p>依赖地狱是指因为依赖大量的组件，过多的组件形成了复杂的依赖关系图。 虽然组件多个版本被引入。 但是最终只能选择一个版本。 这个版本不能兼容所有组件而引发的问题。</p>
<p>Gradle 觉得是信息的不足导致 依赖地狱 的产生。Gradle 在 4.4 的时候支持对依赖版本声明进行更详情的配置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">implementation(&apos;org.slf4j:slf4j-api&apos;) &#123;</span><br><span class="line">     version &#123;</span><br><span class="line">         strictly &apos;[1.0, 2.0[&apos;</span><br><span class="line">         prefer &apos;1.7&apos;</span><br><span class="line">         reject &apos;1.8&apos;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> 支持 org.slf4j:slf4j-api  1.0 到 2.0 不包含1.8 的版本 。 默认情况选择 1.7 。</span><br></pre></td></tr></table></figure>
<p>配置更多查看 <a href="https://docs.gradle.org/6.0/userguide/rich_versions.html" target="_blank" rel="noopener">Declaring Rich Versions</a></p>
<p>但是这一块版本配置或约束在发布成 Maven 的时候就丢失了。Gradle 希望通过 Metadata 保留这块配置。使 Gralde 在依赖版本冲突的时候有更多的信息去选择版本。尽可能避免依赖地狱。</p>
<h1 id="0x06-总结"><a href="#0x06-总结" class="headerlink" title="0x06 总结"></a>0x06 总结</h1><p>国内网络上对于 Gradle Metadata 这块的几乎没有涉及。一个 feature 存在 4.10.2 甚至更早。在 5.3 正式发布了 1.0 版本。但是国内这块的涉及几乎没有，这是非常可惜的。</p>
<p>Gradle 提供的功能或多或少都存在一些 Bug，尽管有这么多个缺陷。但是这个特性确实让人兴奋。 我们只希望 Gradle 6.0 尽快到来。</p>
</div></article></div></main><footer><div class="paginator"><a href="/2019/03/03/scrcpy_usage/" class="next">NEXT</a></div><div id="disqus_thread"></div><script src="/disqus.js"></script><script>var dsqjs = new DisqusJS({
shortname: 'dimredblog', 
identifier: '2019/12/26/implementation_api_maven_gradle_metadata/',
url: 'http://dim.red/2019/12/26/implementation_api_maven_gradle_metadata/', 
api: 'https://disqus.skk.moe/disqus/', 
apikey: 'MvtREFDD6pEIlmM1eqv3vACcJYJSAXfmfgYO4tlVfvgqlPSeE4xhPLQE0YXAbBBe'
});</script><div class="copyright"><p>© 2015 - 2019 <a href="http://dim.red">Dim</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>