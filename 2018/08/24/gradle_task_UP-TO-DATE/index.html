<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Gradle Task  UP-TO-DATE · dim's blog</title><meta name="description" content="Gradle Task  UP-TO-DATE - Dim"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="stylesheet" href="/css/disqusjs.css"><link rel="search" type="application/opensearchdescription+xml" href="http://dim.red/atom.xml" title="dim's blog"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">博客</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">文章</a></li><li class="nav-list-item"><a href="/about/" target="_self" class="nav-list-link">关于</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">Gradle Task  UP-TO-DATE</h1><div class="post-info">Aug 24, 2018</div><div class="post-content"><p><a href="http://dim.red">dim.red</a><br>环境：Gradle 4.4.1</p>
<h2 id="相关"><a href="#相关" class="headerlink" title="相关"></a>相关</h2><p>Task 输入输出注解<br>@Input，@InputFile，@InputFiles，@InputDirectory， @OutputFile，@OutputFiles，@OutputDirectory，@OutputDirectories，@Destroys，@LocalState，@Nested，@Inject，@OptionValues<br>@PathSensitive<br>@Classpath<br>@CompileClasspath<br><a id="more"></a></p>
<h1 id="0x00"><a href="#0x00" class="headerlink" title="0x00"></a>0x00</h1><p>Gradle 为了加快构建速度, 加入了快照缓存的概念。<br>当你的 Task 输出不需要变更。Gradle 会跳转执行过程，同时 Task 在输出打上 UP-TO-DATE 标识。</p>
<h1 id="0x01"><a href="#0x01" class="headerlink" title="0x01"></a>0x01</h1><p>怎样的判断一个 Task 输出不需要变更 ？<br>其中一个条件是比对当前执行状态和上次执行状态的不同。<br>HistoricalTaskExecution： 表示上次执行状态, 是从快照中反序列化出来的。<code>TaskExecutionSnapshotSerializer.read()</code><br>CurrentTaskExecution：表示当前执行状态，是根据当前 Task 的输入输出生成的。 <code>CacheBackedTaskHistoryRepository.createExecution</code>   </p>
<p>比对具体逻辑 <code>TaskUpToDateState</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">this.allTaskChanges = new ErrorHandlingTaskStateChanges(task, new SummaryTaskStateChanges(MAX_OUT_OF_DATE_MESSAGES, </span><br><span class="line">previousSuccessState,</span><br><span class="line">noHistoryState, </span><br><span class="line">taskTypeState, </span><br><span class="line">inputPropertiesState, </span><br><span class="line">outputFileChanges, </span><br><span class="line">inputFileChanges, </span><br><span class="line">discoveredInputFilesChanges</span><br><span class="line">));</span><br></pre></td></tr></table></figure></p>
<p>这里经过 7 个校验，全部验证通过说明这次执行相对上次没有变更，可以直接使用上次执行的输出。</p>
<ul>
<li>previousSuccessState：判断之前执行是否成功。</li>
<li>noHistoryState：判断是否有执行记录。</li>
<li>taskTypeState：比对 Task 和 Action 的实现。具体是比较 ClassLoader 的 Hash 。</li>
<li>inputPropertiesState：比对 InputPropert  变更。</li>
<li>outputFileChanges：比对 OutputFie 变更。</li>
<li>inputFileChanges：比对 InputFie 变更。</li>
<li>discoveredInputFilesChanges：比对 Task 中新增的 Input 变更 。</li>
</ul>
<h1 id="InputPropert"><a href="#InputPropert" class="headerlink" title="InputPropert"></a>InputPropert</h1><p>Map\&lt;String, Object&gt; 类型<br>来自注解 @Input 或API <code>Task.getInput.property</code>  和 <code>Task.getInput.propertys</code> 。</p>
<p>@Input 可以被序列化和反序列化的类型。支持的类型有 基本类型，枚举，Serializable 和 Name 扩展类型。<br><img src="/2018/08/24/gradle_task_UP-TO-DATE/task_01.png" alt="image.png"> </p>
<h1 id="InputFile"><a href="#InputFile" class="headerlink" title="InputFile"></a>InputFile</h1><p>文件类型<br>来自注解  @InputFile @@InputFiles @InputDirectory 或 API<br><code>Task.getInput.file</code>， <code>Task.getInput.files</code>，<code>Task.getInput.dir</code> </p>
<h1 id="OutputFile"><a href="#OutputFile" class="headerlink" title="OutputFile"></a>OutputFile</h1><p>文件类型<br>来自注解 @OutputDirectory @OutputDirectories @OutputFile @OutputFiles 或 API <code>Task.getInput.dir</code>，<code>Task.getInput.dirs</code>，<code>Task.getInput.file</code>，<code>Task.getInput.files</code> </p>
<p>文件的比较主要分为3种， </p>
<ul>
<li>一般的文件：比较文件的的 Hash，Hash 是由文件 Normalized Name 和 文件的内容计算出来的 MD5。</li>
<li>Classpath文件： @Classpath 注释。这种类型在计算 jar 的Hash, 会先对 jar 文件里面的 ZipEntry 进行排序再和 Normalized Name 一起算出 MD5. 这样就不会因ZipEntry 排序导致的 MD5 不同。</li>
<li>CompileClassPath：@CompileClasspath 注释。 在 Classpath 的基础上, 对 Jar 中的 class 进行 ABI 格式化, 即当  jar 提供的接口不变，则 Jar 的 MD5 不变。 这种类型的加入也是使依赖从 compile 升级到  implementation 的关键。</li>
</ul>
<p>Normalized Name 的策略是注解 @PathSensitive 来确定的。 </p>
<ul>
<li>ABSOLUTE：文件的绝对位置。</li>
<li>RELATIVE：文件的相对位置</li>
<li>NAME_ONLY：文件名</li>
<li>NONE：忽略<br>默认值为 ABSOLUTE<br>具体实现查看代码<code>InputPathNormalizationStrategy</code></li>
</ul>
<p>@Nested 是自定义的类型。 是一组或者多组相关输入输出的集合。内部使用上面的注解来定义输入和输出。</p>
<p>注：注解可以声明字段或者 get 方法。但是注解要生效一定要有对应的 get 方法。</p>
<h1 id="0x01-1"><a href="#0x01-1" class="headerlink" title="0x01"></a>0x01</h1><p>Task 通过注解的方式定义输入和输出。<br>Gradle 中定义 Task 。<br><img src="/2018/08/24/gradle_task_UP-TO-DATE/task_02.png" alt="image.png"><br>通过接受一个 Class 类型来声明一个 Task 。<br>Class\<task>  -&gt;  Class\&lt;Task_Decorated&gt;  -&gt; Task_Decorated </task></p>
<p><img src="/2018/08/24/gradle_task_UP-TO-DATE/task_03.png" alt="image.png"><br> Class\<task> 会经过 ClassGenerator , TaskFactory,AnnotationProcessingTaskFactory 生成  Task_Decorated 对象。Task_Decorated 是对 Task 的扩展。</task></p>
<ul>
<li>ClassGenerator：使用 ASM 对原始的类进行分析，生成 Task 的子类 Task_Decorated，并且实现新的接口，增加新的方法和字段。使之具有扩展的能力。</li>
<li>TaskFactory：主要设置 Task_Decorated 合适的实例化方法。(为Task 构造方法注入 Service 对象)</li>
<li>AnnotationProcessingTaskFactory：反射获取 Task 的注解信息，通过一系列的 PropertyAnnotationHandler 处理 Task 类解析出对应 Input 和 Output 。</li>
</ul>
<h1 id="0x02"><a href="#0x02" class="headerlink" title="0x02"></a>0x02</h1><p>Task 的执行由 TaskExecuter 执行的。<br><code>TaskExecutionServices.createTaskExecuter()</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">TaskExecuter createTaskExecuter(TaskArtifactStateRepository repository,</span><br><span class="line">                                    TaskOutputCacheCommandFactory taskOutputCacheCommandFactory,</span><br><span class="line">                                    BuildCacheController buildCacheController,</span><br><span class="line">                                    StartParameter startParameter,</span><br><span class="line">                                    ListenerManager listenerManager,</span><br><span class="line">                                    TaskInputsListener inputsListener,</span><br><span class="line">                                    BuildOperationExecutor buildOperationExecutor,</span><br><span class="line">                                    AsyncWorkTracker asyncWorkTracker,</span><br><span class="line">                                    BuildOutputCleanupRegistry cleanupRegistry,</span><br><span class="line">                                    TaskOutputFilesRepository taskOutputFilesRepository,</span><br><span class="line">                                    BuildScanPluginApplied buildScanPlugin) &#123;</span><br><span class="line"></span><br><span class="line">        boolean taskOutputCacheEnabled = startParameter.isBuildCacheEnabled();</span><br><span class="line">        boolean scanPluginApplied = buildScanPlugin.isBuildScanPluginApplied();</span><br><span class="line">        TaskOutputsGenerationListener taskOutputsGenerationListener = listenerManager.getBroadcaster(TaskOutputsGenerationListener.class);</span><br><span class="line"></span><br><span class="line">        TaskExecuter executer = new ExecuteActionsTaskExecuter(</span><br><span class="line">            taskOutputsGenerationListener,</span><br><span class="line">            listenerManager.getBroadcaster(TaskActionListener.class),</span><br><span class="line">            buildOperationExecutor,</span><br><span class="line">            asyncWorkTracker</span><br><span class="line">        );</span><br><span class="line">        boolean verifyInputsEnabled = Boolean.getBoolean(&quot;org.gradle.tasks.verifyinputs&quot;);</span><br><span class="line">        if (verifyInputsEnabled) &#123;</span><br><span class="line">            executer = new VerifyNoInputChangesTaskExecuter(repository, executer);</span><br><span class="line">        &#125;</span><br><span class="line">        executer = new OutputDirectoryCreatingTaskExecuter(executer);</span><br><span class="line">        if (taskOutputCacheEnabled) &#123;</span><br><span class="line">            executer = new SkipCachedTaskExecuter(</span><br><span class="line">                buildCacheController,</span><br><span class="line">                taskOutputsGenerationListener,</span><br><span class="line">                taskOutputCacheCommandFactory,</span><br><span class="line">                executer</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">        executer = new SkipUpToDateTaskExecuter(executer);</span><br><span class="line">        executer = new ResolveTaskOutputCachingStateExecuter(taskOutputCacheEnabled, executer);</span><br><span class="line">        if (verifyInputsEnabled || taskOutputCacheEnabled || scanPluginApplied) &#123;</span><br><span class="line">            executer = new ResolveBuildCacheKeyExecuter(executer, buildOperationExecutor);</span><br><span class="line">        &#125;</span><br><span class="line">        executer = new ValidatingTaskExecuter(executer);</span><br><span class="line">        executer = new SkipEmptySourceFilesTaskExecuter(inputsListener, cleanupRegistry, taskOutputsGenerationListener, executer);</span><br><span class="line">        executer = new CleanupStaleOutputsExecuter(cleanupRegistry, taskOutputFilesRepository, buildOperationExecutor, executer);</span><br><span class="line">        executer = new ResolveTaskArtifactStateTaskExecuter(repository, executer);</span><br><span class="line">        executer = new SkipTaskWithNoActionsExecuter(executer);</span><br><span class="line">        executer = new SkipOnlyIfTaskExecuter(executer);</span><br><span class="line">        executer = new ExecuteAtMostOnceTaskExecuter(executer);</span><br><span class="line">        executer = new CatchExceptionTaskExecuter(executer);</span><br><span class="line">        return executer;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>这是一个装饰者模式。</p>
<ul>
<li>CatchExceptionTaskExecuter：拦截执行中出现的异常。</li>
<li>ExecuteAtMostOnceTaskExecuter：确保 Task 只执行一次。</li>
<li>SkipOnlyIfTaskExecuter：支持 Task.OnlyIf . Task.onlyIf 为 false 将跳过该任务的执行。 </li>
<li>SkipTaskWithNoActionsExecuter：过滤没有 Action 的 Task。(默认第一个 Action 是 Task 中的被 @TaskAction 的方法)</li>
<li>ResolveTaskArtifactStateTaskExecuter：从快照中反序列化出上次执行的状态(HistoricalTaskExecution)。</li>
<li>CleanupStaleOutputsExecuter：负责清除非 Task 执行中生成的文件</li>
<li>SkipEmptySourceFilesTaskExecuter：判断存在 Output 存在时 Source 文件不为空。Source 文件是输入文件中被 @SkipWhenEmpty 注释的属性。</li>
<li>ValidatingTaskExecuter：验证 input 和 output 。比如 input 的文件要存在等等。 </li>
<li>ResolveBuildCacheKeyExecuter：计算当前执行 Task 的 CacheKey，基于 TaskPath，input , output , Action 等信息， 作为后面从缓存中获取数据的 key。</li>
<li>ResolveTaskOutputCachingStateExecuter: 设置 Task Output 的缓存状态。</li>
<li>SkipUpToDateTaskExecuter：是否能直接跳过执行过程，逻辑主要是有几个， 一，task 的输入输出没有变更， 二 Task 输出 upToDate 为true，三，Gradle 执行命令没有使用 rerun-tasks 参数, 同时执行成功会保存当前 Task 状态(CurrentTaskExecution)的快照, 其中包括 InputPropert ，InputFile，OutputFile。 InputPropert 是将它序列化，而 InputFile，OutputFile 是保存的的文件的 Normalized Name 和 Hash，并不保存文件本身。默认保存在项目中(.gradle/4.4.1/taskHistory/taskHistory.bin)文件下。而这些将成为下一个执行时候从 <code>ResolveTaskArtifactStateTaskExecuter</code> 反序列化出来。</li>
<li>SkipCachedTaskExecuter：缓存有效的时候。尝试从根据 CacheKey 把 OutputFile 文件加载进来， 这里的缓存的来源可以是本地的文件也可是是远程的 Http 服务。同时在 Task 执行完成以后，将Task 输出缓存起来，同样可是缓存在本地或者远程。<br>默认情况本地存储是开启的，位置在全局的 .gradle/caches/build-cache-1/,<br>远程 Http 服务是关闭的。</li>
<li>OutputDirectoryCreatingTaskExecuter：Output 文件不存在自动创建</li>
<li>VerifyNoInputChangesTaskExecuter：验证输入在执行过程中是否有变更。</li>
<li>ExecuteActionsTaskExecuter: 执行被注解 @TaskAction 的方法和添加进来的 Action 。  </li>
</ul>
<p>需要注意的是这里有两种东西，一种是快照由 SkipUpToDateTaskExecuter 存储的是执行的状态，不包括 Output 的实体。另一种缓存是由 SkipCachedTaskExecuter 存储，是 Output 的实体而不是状态。</p>
<h1 id="0x03"><a href="#0x03" class="headerlink" title="0x03"></a>0x03</h1><p>当 Task 满足以下 4 个条件其中一个，则 Gradle 跳转执行过程。</p>
<ol>
<li>当一个 Task 定义了输出，Task 的 Output.upToDate 为 true，Task Source 为空。Gradle 将跳过该任务的执行。 Output 被标识 NO-SOURCE， Output 为空。</li>
<li>当一个 Task 定义了输出，Task 的 Output.upToDate 为 true，Task Source 不为空， Task 的输入和输出没有变更。Output 被标识 UP-TO-DATE，Gradle 将跳过该任务的执行。 使用上次的 Output 。</li>
<li>Task 的 OnlyIf 为 false, Gradle 将跳过该任务的执行。Output 被标识 SKIPPED  Output 为空。</li>
<li>支持缓存。缓存存在且有效，Gradle 将跳过该任务的执行。Output 被标识 FROM-CACHE，使用从缓存解压的 Output 。</li>
</ol>
<h1 id="0x04-尾巴"><a href="#0x04-尾巴" class="headerlink" title="0x04 尾巴"></a>0x04 尾巴</h1><p>Gradle 的代码相对比较松散, 而 Task 这块的代码相对比较集中。通过本章当中的一些关键节点可以很方便的进行学习和深入了解。 </p>
</div></article></div></main><footer><div class="paginator"><a href="/2018/11/03/gradle_configuration_exploration/" class="prev">上一篇</a><a href="/2018/05/13/idea_by_modify/" class="next">下一篇</a></div><div id="disqus_thread"></div><script src="/disqus.js"></script><script>var dsqjs = new DisqusJS({
shortname: 'dimredblog', 
identifier: '2018/08/24/gradle_task_UP-TO-DATE/',
url: 'http://dim.red/2018/08/24/gradle_task_UP-TO-DATE/', 
api: 'https://disqus.skk.moe/disqus/', 
apikey: 'MvtREFDD6pEIlmM1eqv3vACcJYJSAXfmfgYO4tlVfvgqlPSeE4xhPLQE0YXAbBBe'
});</script><div class="copyright"><p>© 2015 - 2019 <a href="http://dim.red">Dim</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>