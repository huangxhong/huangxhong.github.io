<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Gradle Configuration · dim's blog</title><meta name="description" content="Gradle Configuration - Dim"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://dim.red/atom.xml" title="dim's blog"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">博客</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">文章</a></li><li class="nav-list-item"><a href="/about/" target="_self" class="nav-list-link">关于</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">Gradle Configuration</h1><div class="post-info">Nov 3, 2018</div><div class="post-content"><h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><p>Gradle：4.4.1</p>
<h1 id="Configuration-介绍"><a href="#Configuration-介绍" class="headerlink" title="Configuration 介绍"></a>Configuration 介绍</h1><p>通过声明的方式定义了一组依赖。Gradle 通过声明的方式查找对应依赖产物和他们的自身的依赖产物。它代表一组文件。只是这些文件是根据声明信息从本地或远程仓库中获取的。<br> <a id="more"></a></p>
<h1 id="Configuration-状态"><a href="#Configuration-状态" class="headerlink" title="Configuration 状态"></a>Configuration 状态</h1><p>状态分为三个 UNRESOLVED（未解析），RESOLVED（解析成功）/ RESOLVED_WITH_FAILURES（解析失败）<br>从未解析到解析成功或解析失败主要涉及两个过程，一 解析依赖图，二 获取产物。</p>
<h2 id="一-解析依赖图"><a href="#一-解析依赖图" class="headerlink" title="一 解析依赖图"></a>一 解析依赖图</h2><p>主要的功能是使用广度优先算法遍历解析依赖图。同时解决依赖图中相同依赖的版本冲突。</p>
<h3 id="解析冲突策略"><a href="#解析冲突策略" class="headerlink" title="解析冲突策略"></a>解析冲突策略</h3><p>解决版本冲突方式主要使用 3 种策略：</p>
<h4 id="1-版本优先："><a href="#1-版本优先：" class="headerlink" title="1 版本优先："></a>1 版本优先：</h4><p><code>LatestModuleConflictResolver</code><br>一个版本号版本被分为2两部分。<code>数字版本号</code>+<code>限定版本号</code>。<code>数字版本号</code>开始的数字的部分。剩下的为<code>限定版本号</code>在通常版本号分为<br><img src="https://upload-images.jianshu.io/upload_images/166866-82e5000c68d848d2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>eg：1.2.3-bate3，[1,2,3] 为<code>数字版本号</code>，[bate,3] 为 <code>限定版本号</code><br>比较原则</p>
<ol>
<li><code>数字版本号</code>比较大小，逐个比较数字部分，数字大的版本号大<br>eg： 1.2.3 &gt; 1.1.19 ，1.2.3.1 &gt; 1.2.3 </li>
<li><code>限定版本号</code>比较大小，数字 &gt; final &gt; release &gt; rc &gt; (任意非数字字符)  &gt; dev 。任意非数字字符比较方式是逐个比较 Char 的 ASCII码值。</li>
<li><code>数字版本号</code>大的版本号大。</li>
<li><code>数字版本号</code> 相同，没有<code>限定版本号</code> 大于有<code>限定版本号</code>。<br>eg：1.2.3 &gt;1.2.3-beta</li>
<li><code>数字版本号</code> 相同，<code>限定版本号</code>大的版本号大。<br>eg: 1.2.3-final &gt; 1.2.3-release &gt; 1.2.3-rc3 &gt; 1.2.3-rc  &gt; 1.2.3-beta &gt; 1.2.3-dev </li>
<li><code>数字版本号</code>相同，非 SNAPSHOT 大于 SNAPSHOT版本。<br>eg:1.2.3-beta &gt; 1.2.3-SNAPSHOT(注意全部大小)</li>
<li>版本声明顺序不影响版本号的比较。</li>
<li>一个依赖版本被选中，那么它的父节点也要被选中。</li>
</ol>
<p>注：<code>SNAPSHOT</code>类型指的包括版本号使用<code>SNAPSHOT</code>结尾的或者版本号满足<code>SNAPSHOT</code>的规则，版本号会变转换成<code>SNAPSHOT</code>版本<br>即 <code>(.+)-\\d{8}\\.\\d{6}-\\d+·</code><br>版本号-(8位)年月日.(6位)时间-(数字).（eg：0.1.1-20181030.154719-1）</p>
<h5 id="版本比较中的魔幻"><a href="#版本比较中的魔幻" class="headerlink" title="版本比较中的魔幻"></a>版本比较中的魔幻</h5><p>Q：版本 0.1.1-20181030.154719-1 跟 0.1.1-beta 哪个版本比较新？<br>A：0.1.1-beta。 虽然<code>数字版本号</code> 相同，限定版本 [20181030,154719,1] 大于 [beta]，但是 0.1.1-20181030.154719-1 满足正则<code>(.+)-\\d{8}\\.\\d{6}-\\d+·</code>会被解析成 0.1.1-SNAPSHOT 中的 20181030.154719-1版本 , 所以 0.1.1-20181030.154719-1 是个 SNAPSHOT 版本。对应比较原则中的第6原则，非 SNAPSHOT 大于 SNAPSHOT版本。</p>
<p>Q：版本 0.1.1-20181030.154719-1 跟 0.1.1-SNAPSHOT 哪个版本比较新？<br>A： 0.1.1-20181030.154719-1 </p>
<p>Q：1.2.1-SNAPSHOT VS 1.2.0<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">情况A：</span><br><span class="line">&apos;com.dim.red:one:1.2.0&apos;</span><br><span class="line">&apos;com.dim.red:one:1.2.1-SNAPSHOT&apos;</span><br><span class="line">情况B：</span><br><span class="line">&apos;com.dim.red:one:1.2.1-SNAPSHOT&apos;</span><br><span class="line">&apos;com.dim.red:one:1.2.0&apos;</span><br></pre></td></tr></table></figure></p>
<p>1.2.1 跟 1.2.2-SNAPSHOT 哪个版本比较,谁比较新？情况 A 和情况 B 会有不同吗？<br>A: 通过比较原则中 1 和 6 。那么 1.2.2-SNAPSHOT 不管在情况 A 和情况 B 中都应该始终大于 1.2.1 。但是在 Gradle 在 4.4 - 4.6 版本中存在一个BUG。<br>将导致的问题是情况 A 1.2.0 版本大于 1.2.1-SNAPSHOT。 情况 B 1.2.1-SNAPSHOT 大于 1.2.0。具体的原因可以比对版本 4.4.1 和 4.10.2 的实现。<br><a href="https://github.com/gradle/gradle/blob/v4.4.1/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/resolveengine/LatestModuleConflictResolver.java" target="_blank" rel="noopener">LatestModuleConflictResolver.select(details) （4.4.1）</a><br><a href="https://github.com/gradle/gradle/blob/v4.10.2/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/resolveengine/LatestModuleConflictResolver.java" target="_blank" rel="noopener">LatestModuleConflictResolver.select(details)（4.10.2 ） </a></p>
<p>Q：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">情况A</span><br><span class="line">com.dim.red:a:2.0.0</span><br><span class="line">\--- com.dim.red:b:1.2.0</span><br><span class="line">com.dim.red:c:1.0</span><br><span class="line">\--- com.dim.red:a:2.2.0</span><br><span class="line">     \--- com.dim.red:b:1.0.0</span><br><span class="line">情况B</span><br><span class="line">com.dim.red:c:1.0.0</span><br><span class="line">\--- com.dim.red:a:2.2.0</span><br><span class="line">     \--- com.dim.red:b:1.0.0</span><br><span class="line">com.dim.red:a:2.0.0</span><br><span class="line">\--- com.dim.red:b:1.2.0</span><br></pre></td></tr></table></figure></p>
<p>依赖 com.dim.red:b 会选中什么版本？情况 A 和情况 B 会有不同吗？<br>A：通过比较原则中 7 和 8。所以应该是 c:1.0，a:2.2.0，b:1.0.0。<br>但是在 Gradle 的不同版本实现中表现却不一样。在 Gradle 4.9 以下情况 A 会选中版本 c:1.0.0，a:2.2.0，b:1.2.0。而情况 B 选中版本 c:1.0.0，a:2.2.0，b:1.0.0  这里明显是一个BUG。 4.9 修正这个BUG。原因在于 4.9 以下在版本比较中没有过滤掉父节点为空的版本。但是 4.9 的版本中存在一个新的BUG #7050 。该 BUG 在5.0-rc中修复。但是 Gradle 5.0 - rc 的版本还不兼容现有的 Android Gradle Plugin 3.2.1 版本。 </p>
<h4 id="2-严格模式"><a href="#2-严格模式" class="headerlink" title="2 严格模式"></a>2 严格模式</h4><p><code>StrictConflictResolver</code><br> 不允许出现版本冲突。当出现版本冲突的时候，需要手动强制声明锁定版本。 </p>
<h4 id="3-项目优先"><a href="#3-项目优先" class="headerlink" title="3 项目优先"></a>3 项目优先</h4><p><code>ProjectDependencyForcingResolver</code><br>本地项目版本大于远程依赖版本。当没有远程或多个本地项目，使用版本优先算法进行比较。</p>
<h4 id="强制声明锁定版本"><a href="#强制声明锁定版本" class="headerlink" title="强制声明锁定版本"></a>强制声明锁定版本</h4><p>声明以后，在发生版本冲突的时候会直接选择锁定版本。而不需要经过策略。<br>锁定版本方式有两种：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">implementation (&apos;com.google.code.gson:gson:2.8.5&apos;)&#123;</span><br><span class="line">    force = true </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>或<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">configurations.all &#123;</span><br><span class="line">    resolutionStrategy &#123; </span><br><span class="line">        force &apos;com.google.code.gson:gson:2.8.5‘</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="策略设置"><a href="#策略设置" class="headerlink" title="策略设置"></a>策略设置</h3><p>默认策略为版本优先。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">configurations.all &#123;</span><br><span class="line">    resolutionStrategy &#123; </span><br><span class="line">    // 默认为版本优先模式</span><br><span class="line">//       failOnVersionConflict() // 切换策略为严格模式</span><br><span class="line">//       preferProjectModules() // 切换策略为项目优先模式。</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>解析依赖图是一件复杂的事情。Gradle 在上面做的并不好。 或许在 5.0 上会有更稳定，更健壮的表现。所以我们需要特别关心最终打到 APK 的依赖版本。可以使用命令 gradlew :{moduleName}:dependencies  或参考 <a href="https://dim.red/2018/02/05/android_dependency_analyse_code/">输出 Apk 所有的依赖</a> 文章分析 APK 的依赖。</p>
<h2 id="二-获取产物"><a href="#二-获取产物" class="headerlink" title="二 获取产物"></a>二 获取产物</h2><h3 id="缓存策略"><a href="#缓存策略" class="headerlink" title="缓存策略"></a>缓存策略</h3><p>在获取产物过程中，会先从缓存中获取。如果缓存有效。则直接从缓存中获取。缓存无效则请求远程仓库。<br>设置缓存策略：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">configurations.all &#123;</span><br><span class="line">  resolutionStrategy &#123;</span><br><span class="line">    // cache dynamic versions for 10 minutes</span><br><span class="line">    cacheDynamicVersionsFor 10*60, &apos;seconds&apos;</span><br><span class="line">    // don&apos;t cache changing modules at all</span><br><span class="line">    cacheChangingModulesFor 0, &apos;seconds&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里可以配置两种缓存规则，</p>
<ul>
<li><p>第一种是生效在动态版本上，动态版本包括最新版本和区间版本。最新版本是版本号使用<code>latest.</code>开头。 区间版本包括使用 <code>+</code> 和使用开闭区间<code>[()]</code>限制。</p>
</li>
<li><p>第二种是生效在可变版本上。可变版本指的用 <code>-SNAPSHOT</code> 结尾的版本。注意全部为大写</p>
</li>
</ul>
<p>默认缓存时间是一天。<br>所有非动态且非可变版本的依赖的缓存不受缓存策略的影响，默认是一直有效的。</p>
<h3 id="属性匹配"><a href="#属性匹配" class="headerlink" title="属性匹配"></a>属性匹配</h3><p>在获取产物的时候可能会遇到一个异常。</p>
<pre><code>Could not resolve all files for configuration &apos;:app:dim&apos;.
   &gt; Could not resolve project :lib.
     Required by:
         project :app
      &gt; Cannot choose between the following configurations of project :test1:
          - debugApiElements
          - debugRuntimeElements
          - releaseApiElements
          - releaseRuntimeElements
</code></pre><p>这是在Gradle 3.0 以上会出现的问题。 原因在于依赖是可以存在多个变种。在没有属性值匹配的时候会找到多个的产物。Gradle 会抛出异常。因为 Gradle 也不知道应该返回哪一个变种。这个时候需要对 <code>Configuration</code> 加上属性，来筛选出唯一的变种。<br>Gradle 支持属性值的转换。通过定义一些 <code>Transform</code>  提供一些属性转换规则。在属性匹配不上的时候，尝试组合一条最短的 <code>Transform</code> 路径， 进行转换匹配。 筛选出唯一的产物。关于属性匹配和 <code>Transform</code> 相关知识。这里就不展开聊，可以查看相关链接 Gradle Transform 初探 了解更多细节。</p>
<h1 id="相关"><a href="#相关" class="headerlink" title="相关"></a>相关</h1><p><a href="https://docs.oracle.com/middleware/1212/core/MAVEN/maven_version.htm#MAVEN8855" target="_blank" rel="noopener">Understanding Maven Version Numbers</a><br><a href="https://dim.red/2018/01/25/gradle_transform_%20exploration/">Gradle Transform 初探</a></p>
</div></article></div></main><footer><div class="paginator"><a href="/2018/08/24/gradle_task_UP-TO-DATE/" class="next">NEXT</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'dimredblog';
var disqus_identifier = '2018/11/03/gradle_configuration_exploration/';
var disqus_title = 'Gradle Configuration';
var disqus_url = 'http://dim.red/2018/11/03/gradle_configuration_exploration/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//dimredblog.disqus.com/count.js" async></script><div class="copyright"><p>© 2015 - 2018 <a href="http://dim.red">Dim</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>