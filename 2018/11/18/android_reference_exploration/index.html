<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Android 中的引用类型初探 · dim's blog</title><meta name="description" content="Android 中的引用类型初探 - Dim"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://dim.red/atom.xml" title="dim's blog"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">博客</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">文章</a></li><li class="nav-list-item"><a href="/about/" target="_self" class="nav-list-link">关于</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">Android 中的引用类型初探</h1><div class="post-info">Nov 18, 2018</div><div class="post-content"><p><a href="http://dim.red">dim.red</a></p>
<h1 id="引用种类"><a href="#引用种类" class="headerlink" title="引用种类"></a>引用种类</h1><ul>
<li><p>强引用:在 GC 中如果发现一个对象是可达的，那么 GC 在任何情况都不会回收这个对象</p>
</li>
<li><p><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/ref/SoftReference.html" target="_blank" rel="noopener">软引用(SoftReference)</a>：在 GC 中如果发现一个对象是软可达的 。那么 GC 可以根据内存情况清除这些对象。并且保证在抛出 OutOfMemoryError 异常之前。所有的软引用的对象是已经回收过。 </p>
</li>
<li><p><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/ref/WeakReference.html" target="_blank" rel="noopener">弱引用(WeakReference)</a>：在 GC 中如果发现一个对象是软可达的，GC 会回收这些对象。</p>
</li>
<li><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/ref/PhantomReference.html" target="_blank" rel="noopener">虚引用(PhantomReference)</a>：在 GC 中如果发现是一个幽灵引用的时候，GC 会回收这些对象。</li>
</ul>
<p>总结： 强引用在任何情况都不会被回收。软引用在 GC 可以被回收。弱引用和虚引用在 GC 中会尽可能回收。</p>
<h1 id="GC-流程简介"><a href="#GC-流程简介" class="headerlink" title="GC 流程简介"></a>GC 流程简介</h1><p>Android GC 主要分为 标记 和 清除 阶段、 通过定义两个 Bitmap， Live Bitmap 和 Mark Bitmap ， 前者表示上次 GC 存活的对象。后者表示这次 GC 存活的对象。 Mark Bitmap 存在 而 Live Bitmap 不存在的为当前 GC 回收的对象。 GC 结束的时候将  Mark Bitmap  设置为 Live Bitmap。 不管并行还是串行GC， 或者 ART 的 GC 基本流程类似。<br><a id="more"></a></p>
<h2 id="Reference-状态。"><a href="#Reference-状态。" class="headerlink" title="Reference 状态。"></a>Reference 状态。</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Reference&lt;T&gt; &#123;</span><br><span class="line">    ...</span><br><span class="line">    volatile T referent; </span><br><span class="line"></span><br><span class="line">    final ReferenceQueue&lt;? super T&gt; queue; </span><br><span class="line"></span><br><span class="line">    Reference queueNext;</span><br><span class="line"></span><br><span class="line">    Reference&lt;?&gt; pendingNext;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参数介绍：</p>
<ul>
<li>referent：引用对象， referent 回收的时候设置为 null。</li>
<li>queue ：声明的队列。 不为空的时候，在 referent 被回收以后，最终 Reference 会被添加到队列中去。</li>
<li>queueNext ：默认为 null， 在 <code>Enqueued</code> 状态表示同一个 queue 下，下一个 Reference 节点。</li>
<li>pendingNext：默认为 null ，在 <code>Pending</code> 的时候，表示下一个待处理 Reference 节点</li>
</ul>
<h3 id="状态装换"><a href="#状态装换" class="headerlink" title="状态装换"></a>状态装换</h3><p>Reference  有 4 种状态 <code>Active</code>,<code>Pending</code>,<code>Enqueued</code>,<code>Inactive</code>。<br><img src="https://upload-images.jianshu.io/upload_images/166866-1200f9eaa9dae130.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<ul>
<li>queue 不为空：</li>
</ul>
<p>声明的时候默认为  <code>Active</code> 状态（ queueNext  为空 ，pendingNext 为空 ）。在 GC 发现 referent 对象可以被回收，回收 referent ，设置 referent 为 null ， 将 Reference 放在 clear 队列当中。 状态为 <code>Pending</code> 状态（ queueNext  为空 ，pendingNext 不为空 ），GC 会唤醒 ReferenceQueueDaemon 线程处理引用 clear 队列。 ReferenceQueueDaemon 处理  clear 队列。将  Reference 对象放到 queue 队列里面去。 状态为 <code>Enqueued</code> 状态（ queueNext  不为空 ，pendingNext 为 Reference ）。 当 queue  调用 poll() 将 Reference 获取出来。 状态为 <code>Inactive</code>（ queueNext 为 ReferenceQueue.sQueueNextUnenqueued，pendingNext 为 Reference）。</p>
<ul>
<li>queue 为空</li>
</ul>
<p>声明的时候默认为  <code>Active</code> 状态（queueNext  为空 ，pendingNext 为空 ）。在 GC 发现 referent 对象可以被回收，回收 referent ，设置 referent 为 null 。状态为 <code>Inactive</code> （queueNext  为空 ，pendingNext 为空 ）。</p>
<h1 id="Reference-处理流程。"><a href="#Reference-处理流程。" class="headerlink" title="Reference 处理流程。"></a>Reference 处理流程。</h1><h3 id="虚拟机启动"><a href="#虚拟机启动" class="headerlink" title="虚拟机启动"></a>虚拟机启动</h3><p>虚拟机启动的时候会启动守护线程。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public final class Daemons&#123;</span><br><span class="line">   public static void start() &#123;</span><br><span class="line">        ReferenceQueueDaemon.INSTANCE.start(); // 引用队列处理。 </span><br><span class="line">        FinalizerDaemon.INSTANCE.start(); // 处理 finalize 线程</span><br><span class="line">        FinalizerWatchdogDaemon.INSTANCE.start(); // 监听 finalize 方法超时。</span><br><span class="line">        HeapTaskDaemon.INSTANCE.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="加载链接类"><a href="#加载链接类" class="headerlink" title="加载链接类"></a>加载链接类</h3><p>在 虚拟机加载和链接类的时候，会对 Class 进行引用类型判断。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> */</span><br><span class="line">enum ClassFlags &#123;</span><br><span class="line"> ...</span><br><span class="line">    CLASS_ISREFERENCE          = (1&lt;&lt;27), // class is a soft/weak/phantom ref</span><br><span class="line">                                          // only ISREFERENCE is set --&gt; soft</span><br><span class="line">    CLASS_ISWEAKREFERENCE      = (1&lt;&lt;26), // class is a weak reference</span><br><span class="line">    CLASS_ISFINALIZERREFERENCE = (1&lt;&lt;25), // class is a finalizer reference</span><br><span class="line">    CLASS_ISPHANTOMREFERENCE   = (1&lt;&lt;24), // class is a phantom reference</span><br><span class="line"></span><br><span class="line"> ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">static void loadMethodFromDex(ClassObject* clazz, const DexMethod* pDexMethod,</span><br><span class="line">    Method* meth)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    if (dvmCompareNameDescriptorAndMethod(&quot;finalize&quot;, &quot;()V&quot;, meth) == 0) &#123;</span><br><span class="line"></span><br><span class="line">        if (clazz-&gt;classLoader != NULL ||</span><br><span class="line">            strcmp(clazz-&gt;descriptor, &quot;Ljava/lang/Enum;&quot;) != 0)</span><br><span class="line">        &#123;</span><br><span class="line">            SET_CLASS_FLAG(clazz, CLASS_ISFINALIZABLE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>加载类的时候如果发现自定义了 finalize 方法， 那么会在 class 的 <code>accessFlags</code> 对象打上 <code>CLASS_ISFINALIZABLE</code> 标志。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">bool dvmLinkClass(ClassObject* clazz)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line"> </span><br><span class="line">    if (strcmp(clazz-&gt;descriptor, &quot;Ljava/lang/Object;&quot;) == 0) &#123;</span><br><span class="line">        /* Don&apos;t finalize objects whose classes use the</span><br><span class="line">         * default (empty) Object.finalize().</span><br><span class="line">         */</span><br><span class="line">        CLEAR_CLASS_FLAG(clazz, CLASS_ISFINALIZABLE);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">       </span><br><span class="line">        if (IS_CLASS_FLAG_SET(clazz-&gt;super, CLASS_ISFINALIZABLE)) &#123;</span><br><span class="line">            SET_CLASS_FLAG(clazz, CLASS_ISFINALIZABLE);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /* See if this class descends from java.lang.Reference</span><br><span class="line">         * and set the class flags appropriately.</span><br><span class="line">         */</span><br><span class="line">        if (IS_CLASS_FLAG_SET(clazz-&gt;super, CLASS_ISREFERENCE)) &#123;</span><br><span class="line">            u4 superRefFlags;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">            superRefFlags = GET_CLASS_FLAG_GROUP(clazz-&gt;super,</span><br><span class="line">                    CLASS_ISREFERENCE |</span><br><span class="line">                    CLASS_ISWEAKREFERENCE |</span><br><span class="line">                    CLASS_ISFINALIZERREFERENCE |</span><br><span class="line">                    CLASS_ISPHANTOMREFERENCE);</span><br><span class="line">            SET_CLASS_FLAG(clazz, superRefFlags);</span><br><span class="line">        &#125; else if (clazz-&gt;classLoader == NULL &amp;&amp;</span><br><span class="line">                clazz-&gt;super-&gt;classLoader == NULL &amp;&amp;</span><br><span class="line">                strcmp(clazz-&gt;super-&gt;descriptor,</span><br><span class="line">                       &quot;Ljava/lang/ref/Reference;&quot;) == 0)</span><br><span class="line">        &#123;</span><br><span class="line">            u4 refFlags;</span><br><span class="line"></span><br><span class="line">            refFlags = CLASS_ISREFERENCE;</span><br><span class="line">            if (strcmp(clazz-&gt;descriptor,</span><br><span class="line">                       &quot;Ljava/lang/ref/SoftReference;&quot;) == 0)</span><br><span class="line">            &#123;</span><br><span class="line">            &#125; else if (strcmp(clazz-&gt;descriptor,</span><br><span class="line">                       &quot;Ljava/lang/ref/WeakReference;&quot;) == 0)</span><br><span class="line">            &#123;</span><br><span class="line">                refFlags |= CLASS_ISWEAKREFERENCE;</span><br><span class="line">            &#125; else if (strcmp(clazz-&gt;descriptor,</span><br><span class="line">                       &quot;Ljava/lang/ref/FinalizerReference;&quot;) == 0)</span><br><span class="line">            &#123;</span><br><span class="line">                refFlags |= CLASS_ISFINALIZERREFERENCE;</span><br><span class="line">            &#125;  else if (strcmp(clazz-&gt;descriptor,</span><br><span class="line">                       &quot;Ljava/lang/ref/PhantomReference;&quot;) == 0)</span><br><span class="line">            &#123;</span><br><span class="line">                refFlags |= CLASS_ISPHANTOMREFERENCE;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                /* No-one else is allowed to inherit directly</span><br><span class="line">                 * from Reference.</span><br><span class="line">                 */</span><br><span class="line">//xxx is this the right exception?  better than an assertion.</span><br><span class="line">                dvmThrowLinkageError(&quot;illegal inheritance from Reference&quot;);</span><br><span class="line">                goto bail;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            SET_CLASS_FLAG(clazz, refFlags);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   ...</span><br><span class="line">    return okay;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>链接类的时候:<br>当一个 Class 是 <code>SoftReference</code> 或者它的派生类则它的 <code>accessFlags</code> 会被设置为 <code>CLASS_ISREFERENCE</code> 。<br>当一个 Class 是 WeakReference 或者 它的派生类则它的 <code>accessFlags</code> 被设置为<code>CLASS_ISREFERENCE</code> | <code>CLASS_ISPHANTOMREFERENCE</code>。<br>当一个 Class 是 <code>PhantomReference</code> 或者 它的派生类则它的 <code>accessFlags</code> 被设置为 <code>CLASS_ISREFERENCE</code> | <code>CLASS_ISPHANTOMREFERENCE</code>。<br>当一个 Class 是 <code>FinalizerReference</code> 则它的 <code>accessFlags</code> 被设置为 <code>CLASS_ISREFERENCE</code> | <code>CLASS_ISFINALIZERREFERENCE</code>。 它没有派生类， 因为 <code>FinalizerReference</code> 是 Final 。<br>当一个 Class 拥有自定义的 <code>finalize()</code>方法， 或者父类拥有<code>finalize()</code>方法， 那么就会被打上 <code>CLASS_ISFINALIZABLE</code> 标识。 这里有一个是例外 。<code>Object</code>的 <code>finalize()</code>是一个空实现。 它又是所有类的父类。 它会被清除 <code>CLASS_ISFINALIZABLE</code> 标识。因为如果不这样， 所有的类都将被打上 <code>CLASS_ISFINALIZABLE</code>。</p>
<h3 id="对象初始化。"><a href="#对象初始化。" class="headerlink" title="对象初始化。"></a>对象初始化。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/* File: c/OP_INVOKE_OBJECT_INIT_RANGE.cpp */</span><br><span class="line">HANDLE_OPCODE(OP_INVOKE_OBJECT_INIT_RANGE /*&#123;vCCCC..v(CCCC+AA-1)&#125;, meth@BBBB*/)</span><br><span class="line">    &#123;</span><br><span class="line">     ...</span><br><span class="line">         */</span><br><span class="line">        if (IS_CLASS_FLAG_SET(obj-&gt;clazz, CLASS_ISFINALIZABLE)) &#123;</span><br><span class="line">            EXPORT_PC();</span><br><span class="line">            dvmSetFinalizable(obj);</span><br><span class="line">            if (dvmGetException(self))</span><br><span class="line">                GOTO_exceptionThrown();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">     ...</span><br><span class="line">        FINISH(3);</span><br><span class="line">    &#125;</span><br><span class="line">OP_END</span><br></pre></td></tr></table></figure>
<p>在类初始化的时候， 会根据 class 是否有 <code>CLASS_ISFINALIZABLE</code>， 即 拥有 自定义 finalize 方法。 那么会调用 <code>dvmSetFinalizable</code>， <code>dvmSetFinalizable</code> 内部调用了 Java 的 <code>FinalizerReference.add</code> 方法。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public final class FinalizerReference&lt;T&gt; extends Reference&lt;T&gt;&#123;</span><br><span class="line">    // This queue contains those objects eligible for finalization.</span><br><span class="line">    public static final ReferenceQueue&lt;Object&gt; queue = new ReferenceQueue&lt;Object&gt;();</span><br><span class="line"></span><br><span class="line">    public static void add(Object referent) &#123;</span><br><span class="line">        FinalizerReference&lt;?&gt; reference = new FinalizerReference&lt;Object&gt;(referent, queue);</span><br><span class="line">        synchronized (LIST_LOCK) &#123;</span><br><span class="line">            reference.prev = null;</span><br><span class="line">            reference.next = head;</span><br><span class="line">            if (head != null) &#123;</span><br><span class="line">                head.prev = reference;</span><br><span class="line">            &#125;</span><br><span class="line">            head = reference;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里生成了一个新的引用 <code>FinalizerReference</code> 来持有对象，所有的<code>FinalizerReference</code> 设置同一个 <code>queue</code> 。同时将所有的 <code>FinalizerReference</code> 串联起来。</p>
<h1 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h1><p>标记动作就是从 根集 对象开始标记，在标记对象的时候，会根据对象的引用类型，添加到对应的引用队列中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">*</span><br><span class="line"> * Process the &quot;referent&quot; field in a java.lang.ref.Reference.  If the</span><br><span class="line"> * referent has not yet been marked, put it on the appropriate list in</span><br><span class="line"> * the gcHeap for later processing.</span><br><span class="line"> */</span><br><span class="line">static void delayReferenceReferent(Object *obj, GcMarkContext *ctx)</span><br><span class="line">&#123;</span><br><span class="line">   ...</span><br><span class="line">       if (pending == NULL &amp;&amp; referent != NULL &amp;&amp; !isMarked(referent, ctx)) &#123;</span><br><span class="line">        Object **list = NULL;</span><br><span class="line">        if (isSoftReference(obj)) &#123;</span><br><span class="line">            list = &amp;gcHeap-&gt;softReferences;</span><br><span class="line">        &#125; else if (isWeakReference(obj)) &#123;</span><br><span class="line">            list = &amp;gcHeap-&gt;weakReferences;</span><br><span class="line">        &#125; else if (isFinalizerReference(obj)) &#123;</span><br><span class="line">            list = &amp;gcHeap-&gt;finalizerReferences;</span><br><span class="line">        &#125; else if (isPhantomReference(obj)) &#123;</span><br><span class="line">            list = &amp;gcHeap-&gt;phantomReferences;</span><br><span class="line">        &#125;</span><br><span class="line">        assert(list != NULL);</span><br><span class="line">        enqueuePendingReference(obj, list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接下来处理 4 种引用队列。 软引用， 弱引用， 虚引用， finalizer 引用队列<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">void dvmHeapProcessReferences(Object **softReferences, bool clearSoftRefs,</span><br><span class="line">                              Object **weakReferences,</span><br><span class="line">                              Object **finalizerReferences,</span><br><span class="line">                              Object **phantomReferences)</span><br><span class="line">&#123;</span><br><span class="line"> ...</span><br><span class="line">    /*</span><br><span class="line">     * Unless we are in the zygote or required to clear soft</span><br><span class="line">     * references with white references, preserve some white</span><br><span class="line">     * referents.</span><br><span class="line">     */</span><br><span class="line">    if (!gDvm.zygote &amp;&amp; !clearSoftRefs) &#123;</span><br><span class="line">        preserveSomeSoftReferences(softReferences);</span><br><span class="line">    &#125;</span><br><span class="line">    /*</span><br><span class="line">     * Clear all remaining soft and weak references with white</span><br><span class="line">     * referents.</span><br><span class="line">     */</span><br><span class="line">    clearWhiteReferences(softReferences);</span><br><span class="line">    clearWhiteReferences(weakReferences);</span><br><span class="line">    /*</span><br><span class="line">     * Preserve all white objects with finalize methods and schedule</span><br><span class="line">     * them for finalization.</span><br><span class="line">     */</span><br><span class="line">    enqueueFinalizerReferences(finalizerReferences);</span><br><span class="line">    /*</span><br><span class="line">     * Clear all f-reachable soft and weak references with white</span><br><span class="line">     * referents.</span><br><span class="line">     */</span><br><span class="line">    clearWhiteReferences(softReferences);</span><br><span class="line">    clearWhiteReferences(weakReferences);</span><br><span class="line">    /*</span><br><span class="line">     * Clear all phantom references with white referents.</span><br><span class="line">     */</span><br><span class="line">    clearWhiteReferences(phantomReferences);</span><br><span class="line">    /*</span><br><span class="line">     * At this point all reference lists should be empty.</span><br><span class="line">     */</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">static void clearWhiteReferences(Object **list)</span><br><span class="line">&#123;</span><br><span class="line">    GcMarkContext *ctx = &amp;gDvm.gcHeap-&gt;markContext;</span><br><span class="line">    size_t referentOffset = gDvm.offJavaLangRefReference_referent;</span><br><span class="line">    while (*list != NULL) &#123;</span><br><span class="line">        Object *ref = dequeuePendingReference(list);</span><br><span class="line">        Object *referent = dvmGetFieldObject(ref, referentOffset);</span><br><span class="line">        if (referent != NULL &amp;&amp; !isMarked(referent, ctx)) &#123;</span><br><span class="line">            /* Referent is white, clear it. */</span><br><span class="line">            clearReference(ref);</span><br><span class="line">            if (isEnqueuable(ref)) &#123;</span><br><span class="line">                enqueueReference(ref);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">static void enqueueReference(Object *ref)</span><br><span class="line">&#123;</span><br><span class="line">    assert(ref != NULL);</span><br><span class="line">    assert(dvmGetFieldObject(ref, gDvm.offJavaLangRefReference_queue) != NULL);</span><br><span class="line">    assert(dvmGetFieldObject(ref, gDvm.offJavaLangRefReference_queueNext) == NULL);</span><br><span class="line">    enqueuePendingReference(ref, &amp;gDvm.gcHeap-&gt;clearedReferences);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对于弱引用，虚引用， 如果他们没有被标记，那么他们所持有的对象将会回收，referent 设置为 null 。 而他们本身根据 queue 是否为空进入不同状态， 为空将进入<code>Inactive</code> 状态。 不为空 进入<code>Pending</code> 状态。 所有的引用类型会被添加到 Clear 队列中。 此时加入的队列并不是他们自己的 queue 。<br>对软引用来说. 并不会全部回收， 默认情况会回收一半。除非是即将发生 OOM 才会全部回收。这也是软引用和 弱引用，虚引用的主要区别。<br>对于 <code>FinalizerReferences</code> 队列来说的话， 需要调用 <code>enqueueFinalizerReferences</code> 方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">static void enqueueFinalizerReferences(Object **list)</span><br><span class="line">&#123;</span><br><span class="line">    GcMarkContext *ctx = &amp;gDvm.gcHeap-&gt;markContext;</span><br><span class="line">    size_t referentOffset = gDvm.offJavaLangRefReference_referent;</span><br><span class="line">    size_t zombieOffset = gDvm.offJavaLangRefFinalizerReference_zombie;</span><br><span class="line">    bool hasEnqueued = false;</span><br><span class="line">    while (*list != NULL) &#123;</span><br><span class="line">        Object *ref = dequeuePendingReference(list);</span><br><span class="line">        Object *referent = dvmGetFieldObject(ref, referentOffset);</span><br><span class="line">        if (referent != NULL &amp;&amp; !isMarked(referent, ctx)) &#123;</span><br><span class="line">            markObject(referent, ctx);</span><br><span class="line">            dvmSetFieldObject(ref, zombieOffset, referent);</span><br><span class="line">            clearReference(ref);</span><br><span class="line">            enqueueReference(ref);</span><br><span class="line">            hasEnqueued = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (hasEnqueued) &#123;</span><br><span class="line">        processMarkStack(ctx);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于还需要执行 finalizer 方法。 所以需要将还没执行过 finalizer 方法并且未标记的对象标记，防止执行 finalizer 方法前对象被销毁了。然后将 Reference 添加到 Clear 队列。</p>
<p>注: 将 Reference 加入自身的 queue  方法 和  finalizer 方法均不在 GC 过程中调用。因为 GC 时间是宝贵的。 </p>
<p>处理后续  Clear 队列 交给了守护线程 ReferenceQueueDaemon 。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">private static class ReferenceQueueDaemon extends Daemon &#123;</span><br><span class="line">    private static final ReferenceQueueDaemon INSTANCE = new ReferenceQueueDaemon();</span><br><span class="line"></span><br><span class="line">    ReferenceQueueDaemon() &#123;</span><br><span class="line">        super(&quot;ReferenceQueueDaemon&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override public void runInternal() &#123;</span><br><span class="line">        while (isRunning()) &#123;</span><br><span class="line">            Reference&lt;?&gt; list;</span><br><span class="line">            try &#123;</span><br><span class="line">                synchronized (ReferenceQueue.class) &#123;</span><br><span class="line">                    while (ReferenceQueue.unenqueued == null) &#123;</span><br><span class="line">                        ReferenceQueue.class.wait();</span><br><span class="line">                    &#125;</span><br><span class="line">                    list = ReferenceQueue.unenqueued; // </span><br><span class="line">                    ReferenceQueue.unenqueued = null;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125; catch (OutOfMemoryError e) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            // 添加到自己的 queue</span><br><span class="line">            ReferenceQueue.enqueuePending(list);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>ReferenceQueue.unenqueued 就是 Clear 队列。将引用添加到自己的 queue 里面。 状态由 <code>Pending</code> 变更为 <code>Enqueued</code> 。</p>
<p>对于 <code>FinalizerReference</code> 对象的 finalize 方法。 它的处理交给 <code>FinalizerDaemon</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">private static class FinalizerDaemon extends Daemon &#123;</span><br><span class="line"></span><br><span class="line">       private final ReferenceQueue&lt;Object&gt; queue = FinalizerReference.queue;</span><br><span class="line">       @Override public void runInternal() &#123;</span><br><span class="line"></span><br><span class="line">           while (isRunning()) &#123;</span><br><span class="line">               try &#123;</span><br><span class="line">                   ...</span><br><span class="line">                   FinalizerReference&lt;?&gt; finalizingReference = (FinalizerReference&lt;?&gt;)queue.poll();</span><br><span class="line">                   ...</span><br><span class="line">                   doFinalize(finalizingReference);</span><br><span class="line">               &#125; catch (InterruptedException ignored) &#123;</span><br><span class="line">               &#125; catch (OutOfMemoryError ignored) &#123;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       private void doFinalize(FinalizerReference&lt;?&gt; reference) &#123;</span><br><span class="line">           FinalizerReference.remove(reference);</span><br><span class="line">           Object object = reference.get();</span><br><span class="line">           reference.clear();</span><br><span class="line">           try &#123;</span><br><span class="line">               object.finalize();</span><br><span class="line">           &#125; catch (Throwable ex) &#123;    </span><br><span class="line">           &#125; finally &#123;</span><br><span class="line">               finalizingObject = null;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>它是处理是从 <code>FinalizerReference</code> 的 queue 获取 <code>FinalizerReference</code>。 这里 queue 里面存的 <code>FinalizerReference</code> 已经是<code>Enqueued</code> 说明它持有的对象，已经应该需要销毁了。 所有获取的对象然后调用他们的  finalize 方法， 同时拦截所有的异常。并且不做处理。直接结束。 下次的 GC 就可以直接带走这些对象。</p>
</div></article></div></main><footer><div class="paginator"><a href="/2018/11/20/flutter_dy_exploration/" class="prev">上一篇</a><a href="/2018/11/03/gradle_configuration_exploration/" class="next">下一篇</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'dimredblog';
var disqus_identifier = '2018/11/18/android_reference_exploration/';
var disqus_title = 'Android 中的引用类型初探';
var disqus_url = 'http://dim.red/2018/11/18/android_reference_exploration/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//dimredblog.disqus.com/count.js" async></script><div class="copyright"><p>© 2015 - 2019 <a href="http://dim.red">Dim</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>