<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Gradle Transform 初探 · dim's blog</title><meta name="description" content="Gradle Transform 初探 - Dim"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://dim.red/atom.xml" title="dim's blog"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">博客</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">文章</a></li><li class="nav-list-item"><a href="/about/" target="_self" class="nav-list-link">关于</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">Gradle Transform 初探</h1><div class="post-info">Jan 25, 2018</div><div class="post-content"><p><a href="http://dim.red">dim.red</a><br>环境: gradle 4.1 ,  Android Plugin 2.3.0 ,  Android Plugin 3.0.0</p>
<p>#0x00 背景<br>去年的时候写个 <a href="http://dim.red/2017/04/05/android_plugin_transform_%20exploration/">Android Plugin Transform 初探</a> . 现在我们接着之前的脚步来学习 Gradle 下的 Transform . 同时熟悉一下 Android Plugin 在该规则下的应用.<br><a id="more"></a></p>
<p>#0x01 历史<br>Android Plugin 是在1.5.0-beta1 版本加入的.  1.5.0 的 Release 是在2015 年的 11 月.<br>Gradle 的 Transform api 是在 3.5 版本引入的. 3.5.0 的 Release 是在 2017 年的 4 月.<br>相似的命名, 相似的功能,<br>[^_^]: <img src="http://upload-images.jianshu.io/upload_images/166866-fe4983cf873b02d7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Android plugin 1.5.0 "><br><img src="http://upload-images.jianshu.io/upload_images/166866-a3240722fd4ae530.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Gradle 3.5 "></p>
<p>#0x02 使用<br>Gradle 中 Configuration 代表一组依赖关系.而 Transform 是作用在依赖的产物上, 将产物 A 根据一定规则转换成产物 B.<br>依赖的产物默认有一个属性<code>ArtifactAttributes.ARTIFACT_FORMAT</code>, 远程依赖默认为文件的后缀名. 本地依赖的情况比较复杂,具体看应用的插件. </p>
<p>先看一个比较全的应用 </p>
<p>Lib 工程提供 Configuration. 供主工程消费.  </p>
<h2 id="1-Lib-工程"><a href="#1-Lib-工程" class="headerlink" title="1 Lib 工程"></a>1 Lib 工程</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Configuration apLib = project.configurations.create(&quot;apLib&quot;);</span><br><span class="line">        apLib.setDescription(&quot;ap  elements &quot; );</span><br><span class="line">        // 能被其他 project 的消费</span><br><span class="line">        apLib.setCanBeConsumed(true);</span><br><span class="line">        // 设置当前的 Configuration 的属性. 供请求 Configuration 的属性匹配</span><br><span class="line">        apLib.getAttributes().attribute(Attribute.of(&quot;Type&quot;, String.class), &quot;ap&quot;)</span><br><span class="line">        // 声明一个variants apVar , 设置 apVar 属性为 ap, 同时为apVar 设置最终产物 /lib/demo.ap</span><br><span class="line">        apLib.getOutgoing().variants(new Action&lt;NamedDomainObjectContainer&lt;ConfigurationVariant&gt;&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            void execute(NamedDomainObjectContainer&lt;ConfigurationVariant&gt; configurationVariants) &#123;</span><br><span class="line"></span><br><span class="line">                configurationVariants.create(&quot;apVar&quot;, &#123; variant -&gt;</span><br><span class="line">                    variant.artifact(new File(&quot;/lib/demo.ap&quot;), &#123; artifact -&gt;</span><br><span class="line">                        artifact.setType(&quot;ap&quot;);</span><br><span class="line">                    &#125;)</span><br><span class="line">                    variant.getAttributes().attribute(Attribute.of(&quot;artifactType&quot;, String.class), &quot;ap&quot;)</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>
<p>这里声明了一个 apLib 的 Configuration  . 并且为这个apLib 设置了一些属性,这些属性将在后面查找提供作用, 同时为 apLib 设置它的产物 . 也可以为这个 artifact 设置依赖任务 (<code>artifact.builtBy(Task)</code>) , 解析的时候依赖任务是不会被强制执行的。什么时候被执行呢？ Configuration  可以被当一组 Task 被另外一个 Task 依赖 。 TaskA dependOn ConfigurationA. 当 TaskA 被执行之前所有的 ConfigurationA 的 Artifact 设置的依赖Task 会被执行。或者将 ConfigurationA 设置成 TaskA 的 @InputFlies，Gradle 在自动将 TaskA 依赖 ConfigurationA 。  </p>
<h2 id="2-主工程"><a href="#2-主工程" class="headerlink" title="2 主工程"></a>2 主工程</h2><p>定义一个 apC . 获取 apC 依赖上所有 ap 类型的文件.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Configuration apC = project.configurations.create(&quot;apC&quot;);</span><br><span class="line">//主动依赖 Lib 工程</span><br><span class="line">project.getDependencies().add(&quot;apC&quot;, project.project(&apos;:lib&apos;));</span><br><span class="line"></span><br><span class="line">//定义 apC 属性,  主要用来匹配 lib 生成的 apLib 的属性</span><br><span class="line">apC.getAttributes().attribute(Attribute.of(&quot;Type&quot;, String.class), &quot;ap&quot;)</span><br><span class="line">apC.getIncoming().artifactView(&#123;</span><br><span class="line">   config -&gt;</span><br><span class="line">         config.attributes &#123;</span><br><span class="line">            // 定义属性, 用于匹配 apLib apVar 的属性</span><br><span class="line">             container -&gt; container.attribute(Attribute.of(&quot;artifactType&quot;, String.class), &quot;ap&quot;)</span><br><span class="line">         &#125;</span><br><span class="line">&#125;).getArtifacts().getArtifactFiles().getFiles(); //  /lib/demo.ap</span><br></pre></td></tr></table></figure></p>
<p>数据流向:   根据 apC 的属性匹配到 lib 工程的 apLib 的属性. 根据 container 的属性匹配到了 apVar  的属性. 获取到产物.<br>属性的匹配默认是调用两个值的 equals 方法. 当然你可以自己定义一个匹配策略和一个解决匹配冲突的的策略.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AttributeMatchingStrategy attributeMatchingStrategy = project.getDependencies().getAttributesSchema().attribute(Attribute.of(&quot;artifactType&quot;, String.class)); // 获取规则</span><br><span class="line">attributeMatchingStrategy.compatibilityRules.add(TypeCompatibilityRules.class); // 定义新的匹配策</span><br><span class="line">attributeMatchingStrategy.disambiguationRules.add(TypeDisambiguationRules.class); // 定义解决冲突的策</span><br></pre></td></tr></table></figure></p>
<p>到这里. 我们还没有讲到 Transform 的应用. 属性匹配是 Transform 的基础. 当匹配不成功的时候, 会根据 Transform 定义的 <code>From</code> 和 <code>To</code> 尝试组成转化规则. 下面是一个简单的转换<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">DependencyHandler dependencies = project.getDependencies();</span><br><span class="line">        dependencies.registerTransform(&#123;</span><br><span class="line">            it.getFrom().attribute(ArtifactAttributes.ARTIFACT_FORMAT, &quot;ap&quot;);</span><br><span class="line">            it.getTo().attribute(Attribute.of(&quot;artifactType&quot;, String.class), &quot;ap-info&quot;);</span><br><span class="line">            it.artifactTransform(ApInfoTransform.class);</span><br><span class="line">        &#125;);</span><br><span class="line"> apC.getIncoming().artifactView(&#123;</span><br><span class="line">            config -&gt;</span><br><span class="line">                config.attributes &#123;</span><br><span class="line">                    container -&gt; container.attribute(Attribute.of(&quot;artifactType&quot;, String.class), &quot;ap-info&quot;)</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;).getArtifacts().getArtifactFiles().getFiles();</span><br></pre></td></tr></table></figure></p>
<p>定义了一个转换规则: 由 ap 转化成 ap-info .具体转换在 ApInfoTransform</p>
<p>数据的流向是: 根据 apC 的属性匹配到 lib 工程的 apLib 的属性.  container 的属性没有找到能够匹配的属性. 但是匹配到了 ApInfoTransform 的<code>To</code>, ApInfoTransform 的 From 匹配到了 apVar  的属性. 至此组成了一个转化规则, 由 apVar 获取到的产物,需经过 ApInfoTransform 转化后返回. </p>
<p>#0x03 Android Plugin 的应用</p>
<p>Android Plugin 正式使用 Gradle Transform 是在 3.0 上.  </p>
<h3 id="1-Android-Plugin-2-3-0-实现"><a href="#1-Android-Plugin-2-3-0-实现" class="headerlink" title="1. Android Plugin 2.3.0 实现"></a>1. Android Plugin 2.3.0 实现</h3><p><img src="http://upload-images.jianshu.io/upload_images/166866-d59cec6322fd8bbb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="2.3.0"></p>
<p>处理的是 AAR  </p>
<ol>
<li>AAR 的来源有两个: 一种是 AAR 依赖 通过网络下载或本地获取, 一种是 Android Library Module 通过 bundleXX 任务打包出来的 AAR.</li>
<li>Application Plugin 通过依赖关系收集所有的AAR, 再通过 PrepareLibraryTask 将所有 AAR 文件的解压, 用 AndroidDependency 来管理这些 AAR . 通过自己管理这些目录. 组织出不同的资源目录, 如 jar ,Jni,Aidl,Proguard …<h3 id="2-Android-Plugin-3-0-0-实现"><a href="#2-Android-Plugin-3-0-0-实现" class="headerlink" title="2. Android Plugin 3.0.0 实现"></a>2. Android Plugin 3.0.0 实现</h3><img src="http://upload-images.jianshu.io/upload_images/166866-ddf9f2221fb04c59.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3.0"><br>处理的是 attribute 产物<br>这里的 attribute 产物来源主要是两种,<br>一种是 AAR 依赖, 通过网络下载AAR, 通过 ExtractAarTransform 将  ARTIFACT_FORMAT 为 aar 转化成 android-exploded-aar 的产物. 再通过不不同的 AarTransform 将 ARTIFACT_FORMAT 为 android-exploded-aar 转化成不同的属性的产物.<br>一种是通过使用 Android Library Module . 通过往 Configuration 输出不同属性的产物.  </li>
</ol>
<h3 id="3-对比"><a href="#3-对比" class="headerlink" title="3. 对比:"></a>3. 对比:</h3><p>对比 2.3.0 来说 通过将 Transform 的功能将 AAR 文件的处理的时机和缓存全部移交给了 Gradle,<br>好处  </p>
<ol>
<li>Transform 的处理是只有一次, 可以节省多余重复的解压. </li>
<li>缓存是全局的. 所有的工程都能复用同一个缓存.  </li>
</ol>
<p>同时由于 Gradle 并没有对 AAR 依赖做特别的适配, 导致在2.3.0 上处理依赖的时候,需要对依赖进行二次管理,   Android Plugin 3.0.0 不需要这些额外的处理,只需要通过定义不同的 Transform 获取到对应的产物就好了. </p>
<h1 id="0x03-Android-Plugin-Transform-和-Gradle-Transform"><a href="#0x03-Android-Plugin-Transform-和-Gradle-Transform" class="headerlink" title="0x03 Android Plugin Transform 和 Gradle Transform"></a>0x03 Android Plugin Transform 和 Gradle Transform</h1><ul>
<li>维度不同<br>Android Plugin Transform 有两个维度一个是 ContentType ,一个是 Scope,  一个产物只有一个ContentType 和 Scope , Gradle 维度是 Attribute ,一个产物有多个 Attribute. </li>
<li>扩展能力不同<br>Android Plugin Transform 不支持自定义 ContentType , Gradle 支持自定义 Attribute . </li>
<li>缓存不同<br>Android Plugin Transform 将结果记录是在一个大的文件目录下, 通过不同的文件名称来表示不同 Scope 下的 ContentType.<br>Gradle Transform 是将 Transform 输出的结果记录在 Gradle 的文件缓存中,<br>由于记录的方式不同, 导致的结果是 Android plugin Transform 的一个输入对应一个输出,即使你并不对输入做任何操作, 也需要将输入的文件 copy 到输出的文件夹下.才能被下一个 Transform 正确识别. 而 Gradle Transform 不同, 记录是结果, 你完全可以不对输出目录做任何的事情, 直接将原有的输出地址返回回去. </li>
<li>缓存范围不同<br>Android Plugin Transform 缓存是 Application 级别的. 在 build/intermediates/transforms/目录下以transforms名称命名的.<br>Gradle Transform 是全局的, 在.gradle/caches/transforms-1/files-1.1/下, 文件名称是由所有关键信息进行 hash 算出来的. </li>
<li>应用不同<br>Gradle Transform 应用的是依赖的产物。 将产物A 转化成 产物B, 不支持同属性的转化.<br>Android  Plugin Transform 应用的是打包过程中的产物如 so, classs, res,dex。 这些信息大部分是由依赖产物加工而来的。支持相同ContentType 的转化. </li>
</ul>
<h1 id="0x04-总结"><a href="#0x04-总结" class="headerlink" title="0x04 总结"></a>0x04 总结</h1><p>通过上述的对比, 我们可以知道 两个 Transform 应用在不同场景, Gradle Transform  是对依赖进行处理. 这种处理是全局性的.而 Android  Plugin Transform 是对打包过程中中间产物的再处理, 是针对 Application 的. </p>
<h2 id="0x05-尾巴"><a href="#0x05-尾巴" class="headerlink" title="0x05 尾巴"></a>0x05 尾巴</h2><p>这一块的代码看蛮久的, 因为涉及的代码比较多, 面比较广, 需要有一个比较好的耐心和比较久的时间. 通过这一块的梳理, 对 Android plugin 3.0 和 Gradle 4.1 的依赖的管理有更好的理解.  </p>
</div></article></div></main><footer><div class="paginator"><a href="/2018/02/05/android_dependency_analyse_code/" class="prev">PREV</a><a href="/2017/12/24/sasuke_sdk_view_hierarchy/" class="next">NEXT</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'dimredblog';
var disqus_identifier = '2018/01/25/gradle_transform_ exploration/';
var disqus_title = 'Gradle Transform 初探';
var disqus_url = 'http://dim.red/2018/01/25/gradle_transform_ exploration/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//dimredblog.disqus.com/count.js" async></script><div class="copyright"><p>© 2015 - 2018 <a href="http://dim.red">Dim</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>