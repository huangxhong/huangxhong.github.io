<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Android Plugin Transform 初探 · dim's blog</title><meta name="description" content="Android Plugin Transform 初探 - Dim"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://dim.red/atom.xml" title="dim's blog"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">博客</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">文章</a></li><li class="nav-list-item"><a href="/about/" target="_self" class="nav-list-link">关于</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">Android Plugin Transform 初探</h1><div class="post-info">Apr 5, 2017</div><div class="post-content"><h1 id="开头"><a href="#开头" class="headerlink" title="开头"></a>开头</h1><p>java上的AOP 框架比较出名的是AspectJ，比较可惜的是这个框架是在gradle上需要一些变换才能使用。<br><a id="more"></a><br>在使用这个框架之前,我们来看AspectJ 命令的几个比较重要的参数：<br>-classpath：class和source 的位置<br>-aspectpath： 定义了切面规则的class<br>-d：指定输出的目录<br>-outjar：指定输出的jar上<br>-inpath：需要处理的.class<br>classpath 的作用是在当解析一个类的时候，当这个类是不在inpath 中，会从classpath 中寻找。<br>在使用AspectJ的时候, 我们用以下几个方面来优化我们的速度。</p>
<h2 id="一-多线程"><a href="#一-多线程" class="headerlink" title="一 多线程:"></a>一 多线程:</h2><p>首先我们通过android plugin的Transform api ，收集所有的class文件。<br>然后用AspectJ处理所有的class.输出到对应的目录下。<br>这里我们为了保证transform灵活性，我们不将所有的class 合并成一个jar，而是每个输入对应一个输出。同时使用多线程来为这个过程加速。<br>在后续的使用我们发现单纯的直接用多线程来处理这个问题，会引发一个异常，异常如下：<br><img src="http://upload-images.jianshu.io/upload_images/166866-df7277b830e682a9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="异常.png"><br>通过分析可以发现问题是出现在CompilerAdapter 类下，具体是因为CompilerAdapter 会被注入到相关类中。而注入的是同一个实例，在多线程下操作中，一并发就会导致一些bug， 我们重新编写CompilerAdapter 类。在对应的field上用ThreadLocal 包裹，使在参数实例在多线程下隔离，这样就简单的解决问题。</p>
<p>这里有个比较有意思的点是：AspectJ AOP 框架对自身的代码进行了AOP编程。</p>
<h2 id="二-指定精确的aspectpath"><a href="#二-指定精确的aspectpath" class="headerlink" title="二 指定精确的aspectpath"></a>二 指定精确的aspectpath</h2><p>为了加速aspectJ的处理过程， 我们会将aspectpath对应的class 找出来，然后在AspectJ处理的时候将参数指向给aspectpath。 我们通过用ASM 框架解析类，查找所有被Lorg/aspectj/lang/annotation/Aspect 注释的类，收集到一个单独的文件夹中。这样可以为AspectJ处理提升速度。<br>同时为了加快查找aspectpath 的文件。<br>我们支持了对Android library 和Java Library 的aspectpath 文件进行标注。在主项目中查找aspectpath 文件的时候，可以根据这个标注更快的收集.</p>
<ul>
<li>Android Library 我们定义2个Transform ，一个针对Class，收集和分析class，一个针对资源，将上个Transform收集的结果写入Java Resource 中的NOTICE文件。</li>
<li>Java Library 则是在jar task 后面分析生成的jar文件.同样把结果写入Java Resource 的 NOTICE文件。</li>
</ul>
<p>这里之所以使用NOTICE ，而不使用别的，一是为了兼容Android Plugin 版本的变迁。二是因为 Android Plugin 的Java Resource 的合并是会忽略掉几个特定的文件，而NOTICE就在这几个特定文件中。<br>2.0 Android Plugin 忽略的文件：<br><img src="http://upload-images.jianshu.io/upload_images/166866-dd51e8f4a4147a6c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Android Plugin 2.0 "></p>
<p>2.3 Android Plugin 忽略的文件：<br><img src="http://upload-images.jianshu.io/upload_images/166866-c3dfb3269a1bc81d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Android Plugin 2.3.png"></p>
<p>使用NOTICE 好处就是，你用插件处理的jar 包或者aar 在应用到不相干的项目中，在生成的APK不会多余令人困户的配置文件存在。</p>
<h2 id="三-支持增量："><a href="#三-支持增量：" class="headerlink" title="三 支持增量："></a>三 支持增量：</h2><p>我们几乎所有的Transform 都支持了增量编译，意思是AspectJ 并不会每次都处理所有的class， 他只会处理有变更的class 文件。 除非是你的aspectpath文件出现了变更，即AOP规则变更了, 之前的处理结果已经不可靠了，就会触发一次全量的处理。<br>为了支持这个特性，我们必须手动的为AspectJ 新增一个参数  <code>-infiles</code>。为了这个特性我们必须去修改aspectJ 的源码。修改以下3个类 <code>org.aspectj.ajdt.internal.core.builder.AjBuildManager</code>和<code>org.aspectj.ajdt.internal.core.builder.AjBuildConfig</code> 和<code>org.aspectj.ajdt.ajc.BuildArgParser</code>， 这个特性在持续开发中对于节省时间特别有效。</p>
<p>因为在一些需求我们需要修改AspectJ的代码，因为AspectJ 的源码编译比较麻烦。我们这里使用修改后的java编译出的class 文件，然后直接覆盖AspectJ jar包中对应的文件上。</p>
<h1 id="结尾"><a href="#结尾" class="headerlink" title="结尾:"></a>结尾:</h1><p>我们将所有的代码放置在github 上 <a href="https://github.com/zzz40500/AspectJAOP" target="_blank" rel="noopener">AspectJAOP</a>。</p>
</div></article></div></main><footer><div class="paginator"><a href="/2017/04/23/aspectj_aop/" class="prev">上一篇</a><a href="/2016/05/27/gson-skill/" class="next">下一篇</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'dimredblog';
var disqus_identifier = '2017/04/05/android_plugin_transform_ exploration/';
var disqus_title = 'Android Plugin Transform 初探';
var disqus_url = 'http://dim.red/2017/04/05/android_plugin_transform_ exploration/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//dimredblog.disqus.com/count.js" async></script><div class="copyright"><p>© 2015 - 2018 <a href="http://dim.red">Dim</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>