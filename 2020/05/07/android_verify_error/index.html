<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> java.lang.VerifyError:一技组合拳 · dim's blog</title><meta name="description" content="java.lang.VerifyError:一技组合拳 - Dim"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="stylesheet" href="/css/disqusjs.css"><link rel="search" type="application/opensearchdescription+xml" href="http://dim.red/atom.xml" title="dim's blog"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">博客</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">文章</a></li><li class="nav-list-item"><a href="/about/" target="_self" class="nav-list-link">关于</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">java.lang.VerifyError:一技组合拳</h1><div class="post-info">May 7, 2020</div><div class="post-content"><h1 id="0x00-背景"><a href="#0x00-背景" class="headerlink" title="0x00 背景"></a>0x00 背景</h1><p>最近整体升级了项目的工具链。 使用了 D8 作为项目的主力。<br>在 Release 包在 5.1 上出现了 java.lang.VerifyError 异常。</p>
<h1 id="0x01-问题定位"><a href="#0x01-问题定位" class="headerlink" title="0x01 问题定位"></a>0x01 问题定位</h1><p>VerifyError 错误一般出现的 5.0 以下。通常由分包导致的。但是这次发生的机子是 5.1 。<br><a id="more"></a><br>我们将问题代码进行简化如下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class A &#123;</span><br><span class="line"></span><br><span class="line">    // 方法调用入口</span><br><span class="line">    public int method1(Activity activity) &#123;</span><br><span class="line">        if (Build.VERSION.SDK_INT &gt;= 24 &amp;&amp; activity.isInMultiWindowMode()) &#123;</span><br><span class="line">            // 节点1 </span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 节点2 </span><br><span class="line">            Point screenSize = method2((Runnable) activity);</span><br><span class="line">            method3(activity, screenSize);</span><br><span class="line">            return 1;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            // 节点3 </span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Point method2(Runnable activity) &#123;</span><br><span class="line">        return new Point();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void method3(Activity activity, Point screenSize) &#123;</span><br><span class="line">        //忽略</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行奔溃如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.VerifyError: Verifier rejected class com.dim.A due to bad method int com.dim.A.method1(android.app.Activity) (declaration of &apos;com.dim.A&apos; appears in /data/app/com.dim-2/base.apk)</span><br></pre></td></tr></table></figure></p>
<p>往往单纯的奔溃信息是不足以发现问题的。查找上下文日志获取更多信息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">I/art: Verification error in int com.dim.A.method1(android.app.Activity)</span><br><span class="line">I/art: int com.dim.A.method1(android.app.Activity): [0x7] couldn&apos;t find method android.app.Activity.isInMultiWindowMode ()Z</span><br><span class="line">I/art: int com.dim.A.method1(android.app.Activity) failed to verify: int com.dim.A.method1(android.app.Activity): [0x1A] register v1 has type Undefined but expected Integer return-1nr on invalid register v1 </span><br><span class="line">E/art: Verification failed on class com.dim.A in /data/app/com.dim-2/base.apk because: Verifier rejected class com.dim.A due to bad method int com.dim.A.method1(android.app.Activity)</span><br></pre></td></tr></table></figure></p>
<p>发现两个异常信息:</p>
<ol>
<li>isInMultiWindowMode 方法未找到 :<br>找不到 isInMultiWindowMode 方法。 这个方法是在 api 24 上加入的, 确实在 android 5.1 ( api 22) 上不存在。 但就这？</li>
<li>寄存器类型匹配失败:<br>java 虚拟机检验类合法性的时候会匹配栈帧。 对应 android 虚拟机校验寄存器注册表。</li>
</ol>
<p>根源问题在寄存器类型匹配失败。 导致校验方法失败从而校验类失败。 </p>
<p>比较吊诡的是这个问题只出现在 android 5.1 上。 并且只在 Release 包上出现。 据其原因我们使用 dexduup 工具 查看该方法在 Debug 和 Release 包生成的 Dex 字节码的异同。</p>
<p><img src="/2020/05/07/android_verify_error/01.png" alt="Dex字节码异同"><br>可以看出方法使用的寄存器 5 个。一个 catch 异常处理。参数2个。 Debug 包仅仅比 Release 包在异常处理处多个一个 move-exception 指令。 </p>
<p>字节码的异同是因为项目中使用 D8 。D8 生成 Dex 的时候会做一些优化。如字符串优化,  new-array 指令优化，分支指令优化等。 其中包含一些无效指令的删除。 比如一个异常被 catch。 但并没有对异常进行操作。在 Release 模式下那么 D8 认为 move-exception 指令是一个无意义的操作，该指令将会被移除。 </p>
<p>至此我们已经知道了出现问题的大概。<br>因为 D8 对 Dex 优化。生成特定的指令排列导致在部分虚拟机校验失败。</p>
<h1 id="0x02-问题回朔"><a href="#0x02-问题回朔" class="headerlink" title="0x02 问题回朔"></a>0x02 问题回朔</h1><p>查看 art 相关代码<br>art 方法校验入口在 <a href="https://android.googlesource.com/platform/art/+/refs/tags/android-cts-5.1_r9/runtime/verifier/method_verifier.cc#450" target="_blank" rel="noopener">MethodVerifier::Verify()</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">insn_flags_.reset(new InstructionFlags[code_item_-&gt;insns_size_in_code_units_]());</span><br><span class="line">// Run through the instructions and see if the width checks out.</span><br><span class="line">bool result = ComputeWidthsAndCountOps();</span><br><span class="line">// Flag instructions guarded by a &quot;try&quot; block and check exception handlers.</span><br><span class="line">result = result &amp;&amp; ScanTryCatchBlocks();</span><br><span class="line">// Perform static instruction verification.</span><br><span class="line">result = result &amp;&amp; VerifyInstructions();</span><br><span class="line">// Perform code-flow analysis and return.</span><br><span class="line">result = result &amp;&amp; VerifyCodeFlow();</span><br><span class="line">// Compute information for compiler.</span><br><span class="line">if (result &amp;&amp; Runtime::Current()-&gt;IsCompiler()) &#123;</span><br><span class="line">  result = Runtime::Current()-&gt;GetCompilerCallbacks()-&gt;MethodVerified(this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>校验方法主要以下几个方面</p>
<ol>
<li>校验指令大小是否超过声明大小。</li>
<li>校验方法指令使用的寄存器是否越界。</li>
<li>校验跳转指令是否越界或错误</li>
<li>校验指令引用的元素在 Dex 位置是否正确</li>
<li>校验寄存器注册表否正确。即从寄存器读取的类型是否匹配声明的类型。</li>
<li>锁 是否被正确释放。</li>
</ol>
<p>这次这个错误是在校验寄存器注册表出现的。</p>
<p>寄存注册表校验流程如下：</p>
<p>为每个指令设置一个 insn_flags 标记。当对应的 insn_flags 设置为 Changed。 那么该指令需要被校验。art 会从第一个指令开始校验 。 校验指令的同时会设置其他的指令设置 Changed。如<code>操作指令</code>会设置下一个指令为 Changed。<code>分支指令</code>因为存在多个分支的指令。 会对多个分支的第一个指令设置 Changed。<code>回值指令</code> 则不会为任何指令设置。 通过检查是否还存在 Changed 标记位来检查是否完成校验工作。<br>关于指令的类型定义都  <a href="https://android.googlesource.com/platform/art/+/refs/tags/android-cts-5.1_r9/runtime/dex_instruction_list.h" target="_blank" rel="noopener">dex_instruction_list.h</a> </p>
<p><code>kContinue</code> 为<code>操作指令</code><br><code>kBranch</code> 为<code>分支指令</code><br><code>kReturn</code> 为<code>回值指令</code></p>
<p>指令在运行的时候还存在一个寄存器注册表。寄存器注册表很大一部分体现了当前运行的环境。 当遇到分支指令的时候， 由于存在分支跳转。还需要把寄存器注册表状态转移到所有的分支上。 一个指令多次被执行的时候。就会存在多张寄存器注册表，需要合并这些表。当合并不兼容的时候， 需要重新校验该分支的代码。</p>
<p>从字节码流程中观察寄存器注册表的变化。来定位问题<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">|0000: sget v0, Landroid/os/Build$VERSION;.SDK_INT:I // field@0000</span><br><span class="line">|0002: const/4 v1, #int 0 // #0</span><br><span class="line">|0003: const/16 v2, #int 24 // #18</span><br><span class="line">|0005: if-lt v0, v2, 000e // +0009</span><br><span class="line">|0007: invoke-virtual &#123;v4&#125;, Landroid/app/Activity;.isInMultiWindowMode:()Z // method@0001</span><br><span class="line">|000a: move-result v0</span><br><span class="line">|000b: if-eqz v0, 000e // +0003</span><br><span class="line">|000d: return v1</span><br><span class="line">|000e: move-object v0, v4</span><br><span class="line">|000f: check-cast v0, Ljava/lang/Runnable; // type@001c</span><br><span class="line">|0011: invoke-virtual &#123;v3, v0&#125;, Lcom/dim/A;.method2:(Ljava/lang/Runnable;)Landroid/graphics/Point; // method@0008</span><br><span class="line">|0014: move-result-object v0</span><br><span class="line">|0015: invoke-direct &#123;v3, v4, v0&#125;, Lcom/dim/A;.method3:(Landroid/app/Activity;Landroid/graphics/Point;)V // </span><br><span class="line">|0018: const/4 v1, #int 1 // #1</span><br><span class="line">|0019: return v1</span><br><span class="line">|001a: return v1</span><br><span class="line">catches       : 1</span><br><span class="line">    0x000e - 0x0018</span><br><span class="line">    Ljava/lang/Exception; -&gt; 0x001a</span><br></pre></td></tr></table></figure></p>
<ol>
<li>第一步<br>该方法声明寄存器5个，初始化寄存器注册表 V0～V4: xxxL1L2<br>x: 未定义<br>L1 ：this 对象类型<br>L2 ：第一个入参</li>
<li>第二步<br>校验第一个指令 0000  sget V0<br>设置指令 0002 的 insn_flags  为 Changed<br>寄存器注册表 IxxL1L2</li>
<li>第三步<br>校验指令 0002  const/4 v1, #int 0<br>设置下一个指令 0003 的 insn_flags  为 Changed<br>寄存器注册表 IIxL1L2</li>
<li>第四步<br>校验指令 0003  const/16 v2, #int 24<br>设置下一个指令 0005 的 insn_flags  为 Changed<br>寄存器注册表 IIIL1L2</li>
<li><p>第五步<br>校验分支指令 0005: if-lt v0, v2, 000e<br>设置下一个指令 0007 的 insn_flags  为 Changed<br>设置下个分支第一个指令 000e 的 insn_flags  为 Changed<br>寄存器注册表 IIIL1L2<br>复制寄存注册表到 000e 上</p>
</li>
<li><p>第六步<br>校验指令 0007: invoke-virtual {v4}, Landroid/app/Activity;.isInMultiWindowMode:()Z<br>检验发现 isInMultiWindowMode 方法不存在。该异常会导致出现运行期异常。 该条链路以下的指令不再校验。 不再为任何指令设置 Changed 。<br>当前寄存器注册表 IIIL1L2</p>
</li>
<li><p>第七步<br>由于 000e 的 insn_flags 还是 Changed。还需要校验指令 000e 指令<br>校验指令 000e: move-object v0, v4<br>0x00e - 0x0018 是位于 try catch 里面的指令。 try catch 里所有可能发生异常的指令。都会走到 catch 的处理逻辑中。 所以需要把进入该指令前的寄存器注册表状态转移到 0x001a 中。进入前的寄存器注册表保存在 saved_line_ 变量上。理论上 move-object 指令是不会发生异常的。 但是 api 22 存在的一个 bug 。 由于第六步的异常导致所有的指令都强制设置为会发生异常。  导致 art 错误的把一个未赋值的 saved_line_  寄存器注册表赋值给 0x001a ，同时设置 0x001a  的 insn_flags 设置为 Changed   。<br>执行指令是否会发生异常查看 <a href="https://android.googlesource.com/platform/art/+/refs/tags/android-cts-5.1_r9/runtime/dex_instruction_list.h" target="_blank" rel="noopener">dex_instruction_list.h</a>  kThrow </p>
</li>
<li><p>第八步<br>检验 001a: return v1。 检验寄存器1是否匹配<br>由于当前寄存器注册表未赋值为 xxxxx<br>校验失败。结束校验。抛出异常</p>
</li>
</ol>
<p>异常现场复现。</p>
<h1 id="0x03-总结"><a href="#0x03-总结" class="headerlink" title="0x03 总结"></a>0x03 总结</h1><h4 id="Bug-如何出现-？"><a href="#Bug-如何出现-？" class="headerlink" title="Bug 如何出现 ？"></a>Bug 如何出现 ？</h4><p>这个 Bug 是一套组合。 </p>
<ol>
<li>一个运行期异常。</li>
<li>紧跟一个 try catch 代码块</li>
<li>try catch 第一个指令运行不会发生异常</li>
<li>catch异常处理第一个指令是一个从寄存器读的操作。</li>
</ol>
<h4 id="如何解决这个-Bug-？"><a href="#如何解决这个-Bug-？" class="headerlink" title="如何解决这个 Bug ？"></a>如何解决这个 Bug ？</h4><ol>
<li>弃用 D8 使用 dx 来转化 Dex （历史的倒退）</li>
<li>弃用  release 模式的  D8 来生成 Dex（优化力度变小）</li>
<li><p>规避特定的排序。 （看天吃饭）<br>节点1  去除 isInMultiWindowMode 方法调用。<br>节点2  关闭强转。<br>节点3  处理异常。<br>节点3  return 非 0 。 </p>
</li>
<li><p>对 D8 进行干预。 关闭  move-exception 指令的优化<br><a href="https://r8.googlesource.com/r8/+/refs/heads/2.1.7/src/main/java/com/android/tools/r8/ir/code/MoveException.java" target="_blank" rel="noopener">MoveException.java</a></p>
</li>
</ol>
<p><img src="/2020/05/07/android_verify_error/02.png" alt="image.png"></p>
<h4 id="Bug-影响范围-？"><a href="#Bug-影响范围-？" class="headerlink" title="Bug 影响范围 ？"></a>Bug 影响范围 ？</h4><p>问题存在在 api  21-22 在 api 23 被修复。<br>修复的 commit 如下：</p>
<ol>
<li><p>saved_line_ 正确被赋值<br><a href="https://android.googlesource.com/platform/art/+/d7f8d05987e08723de008ba6dbbf66acb7db0f24%5E%21/#F0" target="_blank" rel="noopener">d7f8d059 diff</a></p>
</li>
<li><p>have_pending_runtime_throw_failure_ 状态及时重置。<br><a href="https://android.googlesource.com/platform/art/+/3ae8da0a803370be9dd410226438f636af553e22%5E%21/#F0" target="_blank" rel="noopener">3ae8da0 diff</a></p>
</li>
</ol>
</div></article></div></main><footer><div class="paginator"><a href="/2020/03/31/android_r8/" class="next">NEXT</a></div><div id="disqus_thread"></div><script src="/disqus.js"></script><script>var dsqjs = new DisqusJS({
shortname: 'dimredblog', 
identifier: '2020/05/07/android_verify_error/',
url: 'http://dim.red/2020/05/07/android_verify_error/', 
api: 'https://disqus.skk.moe/disqus/', 
apikey: 'MvtREFDD6pEIlmM1eqv3vACcJYJSAXfmfgYO4tlVfvgqlPSeE4xhPLQE0YXAbBBe'
});</script><div class="copyright"><p>© 2015 - 2020 <a href="http://dim.red">Dim</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>