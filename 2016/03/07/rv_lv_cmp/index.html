<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> lv 和 rv 的缓存比较(初稿) · dim's blog</title><meta name="description" content="lv 和 rv 的缓存比较(初稿) - Dim"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="stylesheet" href="/css/disqusjs.css"><link rel="search" type="application/opensearchdescription+xml" href="http://dim.red/atom.xml" title="dim's blog"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">博客</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">文章</a></li><li class="nav-list-item"><a href="/about/" target="_self" class="nav-list-link">关于</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">lv 和 rv 的缓存比较(初稿)</h1><div class="post-info">Mar 7, 2016</div><div class="post-content"><p><a href="http://dim.red">dim.red</a></p>
<h2 id="lv的缓存"><a href="#lv的缓存" class="headerlink" title="lv的缓存"></a>lv的缓存</h2><a id="more"></a>
<h3 id="存储-View-结构"><a href="#存储-View-结构" class="headerlink" title="存储 View 结构"></a>存储 View 结构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public void setViewTypeCount(int viewTypeCount) &#123;</span><br><span class="line">    if (viewTypeCount &lt; 1) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;Can&apos;t have a viewTypeCount &lt; 1&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    //noinspection unchecked</span><br><span class="line">    ArrayList&lt;View&gt;[] scrapViews = new ArrayList[viewTypeCount];</span><br><span class="line">    for (int i = 0; i &lt; viewTypeCount; i++) &#123;</span><br><span class="line">        scrapViews[i] = new ArrayList&lt;View&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    mViewTypeCount = viewTypeCount;</span><br><span class="line">    mCurrentScrap = scrapViews[0];</span><br><span class="line">    mScrapViews = scrapViews;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>存储View 的是ArrayList<view>[],并且数组大小为viewTypeCount , 这也是为什么我们在多 type 的时候需要指定type的个数了.</view></p>
<h3 id="屏幕外的缓存"><a href="#屏幕外的缓存" class="headerlink" title="屏幕外的缓存"></a>屏幕外的缓存</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Put a view into the ScrapViews list. These views are unordered.</span><br><span class="line"> *</span><br><span class="line"> * @param scrap The view to add</span><br><span class="line"> */</span><br><span class="line">void addScrapView(View scrap, int position) &#123;</span><br><span class="line">    AbsListView.LayoutParams lp = (AbsListView.LayoutParams) scrap.getLayoutParams();</span><br><span class="line">    if (lp == null) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    lp.scrappedFromPosition = position;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    if (mViewTypeCount == 1) &#123;</span><br><span class="line">        mCurrentScrap.add(scrap);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        mScrapViews[viewType].add(scrap);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @return A view from the ScrapViews collection. These are unordered.</span><br><span class="line"> */</span><br><span class="line">View getScrapView(int position) &#123;</span><br><span class="line">    if (mViewTypeCount == 1) &#123;</span><br><span class="line">        return retrieveFromScrap(mCurrentScrap, position);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        int whichScrap = mAdapter.getItemViewType(position);</span><br><span class="line">        if (whichScrap &gt;= 0 &amp;&amp; whichScrap &lt; mScrapViews.length) &#123;</span><br><span class="line">            return retrieveFromScrap(mScrapViews[whichScrap], position);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static View retrieveFromScrap(ArrayList&lt;View&gt; scrapViews, int position) &#123;</span><br><span class="line">    int size = scrapViews.size();</span><br><span class="line">    if (size &gt; 0) &#123;</span><br><span class="line">        // See if we still have a view for this position.</span><br><span class="line">        for (int i=0; i&lt;size; i++) &#123;</span><br><span class="line">            View view = scrapViews.get(i);</span><br><span class="line">            if (((AbsListView.LayoutParams)view.getLayoutParams())</span><br><span class="line">                    .scrappedFromPosition == position) &#123;</span><br><span class="line">                scrapViews.remove(i);</span><br><span class="line">                return view;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return scrapViews.remove(size - 1);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意:"></a>注意:</h4><p>代码为api 21的,各个系统版本不同可能代码有所不同,但是核心的思想是一样的.</p>
<h2 id="rv的缓存"><a href="#rv的缓存" class="headerlink" title="rv的缓存"></a>rv的缓存</h2><h3 id="根据-Position-获取-View-视图"><a href="#根据-Position-获取-View-视图" class="headerlink" title="根据 Position 获取 View 视图"></a>根据 Position 获取 View 视图</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">View getViewForPosition(int position, boolean dryRun) &#123;</span><br><span class="line">     ...</span><br><span class="line">    // 0) If there is a changed scrap, try to find from there</span><br><span class="line">    if (mState.isPreLayout()) &#123;</span><br><span class="line">        holder = getChangedScrapViewForPosition(position);</span><br><span class="line">        fromScrap = holder != null;</span><br><span class="line">    &#125;</span><br><span class="line">    // 1) Find from scrap by position</span><br><span class="line">    if (holder == null) &#123;</span><br><span class="line">        holder = getScrapViewForPosition(position, INVALID_TYPE, dryRun);</span><br><span class="line">       ...</span><br><span class="line">    &#125;</span><br><span class="line">    if (holder == null) &#123;</span><br><span class="line">       ...</span><br><span class="line">        // 2) Find from scrap via stable ids, if exists</span><br><span class="line">        if (mAdapter.hasStableIds()) &#123;</span><br><span class="line">            holder = getScrapViewForId(mAdapter.getItemId(offsetPosition), type, dryRun);</span><br><span class="line">            if (holder != null) &#123;</span><br><span class="line">                // update position</span><br><span class="line">                holder.mPosition = offsetPosition;</span><br><span class="line">                fromScrap = true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (holder == null &amp;&amp; mViewCacheExtension != null) &#123;</span><br><span class="line">            // We are NOT sending the offsetPosition because LayoutManager does not</span><br><span class="line">            // know it.</span><br><span class="line">            final View view = mViewCacheExtension</span><br><span class="line">                    .getViewForPositionAndType(this, position, type);</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        if (holder == null) &#123; // fallback to recycler</span><br><span class="line">            // try recycler.</span><br><span class="line">            // Head to the shared pool.</span><br><span class="line">            if (DEBUG) &#123;</span><br><span class="line">                Log.d(TAG, &quot;getViewForPosition(&quot; + position + &quot;) fetching from shared &quot;</span><br><span class="line">                        + &quot;pool&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            holder = getRecycledViewPool().getRecycledView(type);</span><br><span class="line">            if (holder != null) &#123;</span><br><span class="line">                holder.resetInternal();</span><br><span class="line">                if (FORCE_INVALIDATE_DISPLAY_LIST) &#123;</span><br><span class="line">                    invalidateDisplayListInt(holder);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (holder == null) &#123;</span><br><span class="line">            holder = mAdapter.createViewHolder(RecyclerView.this, type);</span><br><span class="line">            if (DEBUG) &#123;</span><br><span class="line">                Log.d(TAG, &quot;getViewForPosition created new ViewHolder&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    boolean bound = false;</span><br><span class="line">    if (mState.isPreLayout() &amp;&amp; holder.isBound()) &#123;</span><br><span class="line">        // do not update unless we absolutely have to.</span><br><span class="line">        holder.mPreLayoutPosition = position;</span><br><span class="line">    &#125; else if (!holder.isBound() || holder.needsUpdate() || holder.isInvalid()) &#123;</span><br><span class="line">        if (DEBUG &amp;&amp; holder.isRemoved()) &#123;</span><br><span class="line">            throw new IllegalStateException(&quot;Removed holder should be bound and it should&quot;</span><br><span class="line">                    + &quot; come here only in pre-layout. Holder: &quot; + holder);</span><br><span class="line">        &#125;</span><br><span class="line">        final int offsetPosition = mAdapterHelper.findPositionOffset(position);</span><br><span class="line">        holder.mOwnerRecyclerView = RecyclerView.this;</span><br><span class="line">        mAdapter.bindViewHolder(holder, offsetPosition);</span><br><span class="line">        attachAccessibilityDelegate(holder.itemView);</span><br><span class="line">        bound = true;</span><br><span class="line">        if (mState.isPreLayout()) &#123;</span><br><span class="line">            holder.mPreLayoutPosition = position;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    final ViewGroup.LayoutParams lp = holder.itemView.getLayoutParams();</span><br><span class="line">    final LayoutParams rvLayoutParams;</span><br><span class="line">    if (lp == null) &#123;</span><br><span class="line">        rvLayoutParams = (LayoutParams) generateDefaultLayoutParams();</span><br><span class="line">        holder.itemView.setLayoutParams(rvLayoutParams);</span><br><span class="line">    &#125; else if (!checkLayoutParams(lp)) &#123;</span><br><span class="line">        rvLayoutParams = (LayoutParams) generateLayoutParams(lp);</span><br><span class="line">        holder.itemView.setLayoutParams(rvLayoutParams);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        rvLayoutParams = (LayoutParams) lp;</span><br><span class="line">    &#125;</span><br><span class="line">    rvLayoutParams.mViewHolder = holder;</span><br><span class="line">    rvLayoutParams.mPendingInvalidate = fromScrap &amp;&amp; bound;</span><br><span class="line">    return holder.itemView;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里可以看出<br>holder 分别从以下几个地方被赋值: </p>
<ol>
<li>当mState.isPreLayout() 为 true 有也就是动画的时候.<br>getChangedScrapViewForPosition<br>从mChangedScrap 中获取到配置position ,position 配置不到的话,当mAdapter.hasStableIds() 为 true 的话,匹配getItemId 的值.值得注意当我们的 LayoutManger 支持动画的时候,他的onLayoutChildren 会被调用两个,一次为Pre-Layout,一种是 Real-Layout, 而mChangedScrap中的 View 在只会在Pre-Layout.返回的目的是为了 LayoutManager 在Pre-Layout中不会空白了一块.可以正确布局.</li>
</ol>
<ul>
<li>getScrapViewForPosition() 从mAttachedScrap 中匹配position , 配置不到的话从mCachedViews 去匹配 position 值,</li>
<li>当mAdapter.hasStableIds() 为 true 的时候.<br>getScrapViewForId 从mAttachedScrap 中匹配getItemId 以及 ViewType 值,匹配不到的话,尝试从mCachedViews 匹配getItemId 和ViewType.</li>
<li>当 mViewCacheExtension 不为空的时候 getViewForPositionAndType()从开发者设置ViewCacheExtension  中获取到 View</li>
<li>getRecycledViewPool().getRecycledView(type)<br>从RecycledViewPool 获取到View</li>
<li>mAdapter.createViewHolder(RecyclerView.this, type); 创建一个 View .</li>
</ul>
<p>我们从上面的是地方可以看出我们的缓存 View 存储在两种类型:<br>Scrap 和recycle:</p>
<p>Scrap<br>mChangedScrap,mAttachedScrap,mCachedViews.<br>recycle<br>RecycledViewPool.<br>Scrap 之所以比recycle轻量. 因为recycle 一定会有bindViewHolder 的动作.而Scrap 不一定会有.</p>
<h4 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h4><p>mAdapter.hasStableIds()  表示数据集合中的每一项是否可以代表有惟一的标识符,这个都作用跟Adapter.hasStableIds一致的效果,具体作用在notifyDataSetChanged 体现. eg:你有适配器hasStableIds为 false, 你的列表中删除了第2项,那你使用notifyDataSetChanged 那么你的第2项的展示的数据是第三项的,但是你的 View 还是之前的第2的View.而你hasStableIds 为 true, 并且为他们每个项有一个唯一的 id, 那你删除了第2项,使用notifyDataSetChanged 那么你的第2项的展示的数据是第三项的,你的 View 就是之前第三项.因为 View 跟数据匹配上了.</p>
<h3 id="屏幕内缓存"><a href="#屏幕内缓存" class="headerlink" title="屏幕内缓存"></a>屏幕内缓存</h3><p>RequestLayout 和NotifyXXX 下的回收.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">void scrapView(View view) &#123;</span><br><span class="line">    final ViewHolder holder = getChildViewHolderInt(view);</span><br><span class="line">    if (holder.hasAnyOfTheFlags(ViewHolder.FLAG_REMOVED | ViewHolder.FLAG_INVALID)</span><br><span class="line">            || !holder.isUpdated() || canReuseUpdatedViewHolder(holder)) &#123;</span><br><span class="line">       ...</span><br><span class="line">        holder.setScrapContainer(this, false);</span><br><span class="line">        mAttachedScrap.add(holder);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if (mChangedScrap == null) &#123;</span><br><span class="line">            mChangedScrap = new ArrayList&lt;ViewHolder&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        holder.setScrapContainer(this, true);</span><br><span class="line">        mChangedScrap.add(holder);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>mChangedScrap: 收集的是界面上被打上UpdateOp.UPDATE的 item,rv 通过notifyItemChanged对 position 所在的ViewHolder 打上flag的.</p>
<p>mAttachedScrap: 界面上所有非mChangedScrap 的 View</p>
<h3 id="屏幕外的缓存-1"><a href="#屏幕外的缓存-1" class="headerlink" title="屏幕外的缓存."></a>屏幕外的缓存.</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">private static final int DEFAULT_CACHE_SIZE = 2;</span><br><span class="line">private int mViewCacheMax = DEFAULT_CACHE_SIZE;</span><br><span class="line">/**</span><br><span class="line"> * internal implementation checks if view is scrapped or attached and throws an exception</span><br><span class="line"> * if so.</span><br><span class="line"> * Public version un-scraps before calling recycle.</span><br><span class="line"> */</span><br><span class="line">void recycleViewHolderInternal(ViewHolder holder) &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    if (forceRecycle || holder.isRecyclable()) &#123;</span><br><span class="line">        if (!holder.hasAnyOfTheFlags(ViewHolder.FLAG_INVALID | ViewHolder.FLAG_REMOVED</span><br><span class="line">                | ViewHolder.FLAG_UPDATE)) &#123;</span><br><span class="line">            // Retire oldest cached view</span><br><span class="line">            final int cachedViewSize = mCachedViews.size();</span><br><span class="line">            if (cachedViewSize == mViewCacheMax &amp;&amp; cachedViewSize &gt; 0) &#123;</span><br><span class="line">                recycleCachedViewAt(0);</span><br><span class="line">            &#125;</span><br><span class="line">            if (cachedViewSize &lt; mViewCacheMax) &#123;</span><br><span class="line">                mCachedViews.add(holder);</span><br><span class="line">                cached = true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (!cached) &#123;</span><br><span class="line">            addViewHolderToRecycledViewPool(holder);</span><br><span class="line">            recycled = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    …</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void recycleCachedViewAt(int cachedViewIndex) &#123;</span><br><span class="line">   </span><br><span class="line">    ViewHolder viewHolder = mCachedViews.get(cachedViewIndex);</span><br><span class="line">    </span><br><span class="line">    addViewHolderToRecycledViewPool(viewHolder);</span><br><span class="line">    mCachedViews.remove(cachedViewIndex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void addViewHolderToRecycledViewPool(ViewHolder holder) &#123;</span><br><span class="line">    ViewCompat.setAccessibilityDelegate(holder.itemView, null);</span><br><span class="line">    dispatchViewRecycled(holder);</span><br><span class="line">    holder.mOwnerRecyclerView = null;</span><br><span class="line">    getRecycledViewPool().putRecycledView(holder);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们可以看出 view 的回收是要经过mCachedViews 然后才是RecycledViewPool<br>并且这里的判断条件也是挺有意思:<br>如果mCachedViews 到达 最大值,讲 mCachedViews 第一个压入RecycledViewPool中,然后要回收的 View也压到RecycledViewPool中去.如果不没有到达最大值才压入 mCachedViews 中去.从代码中我们可以看出最大值为2,你也可是使用setViewCacheSize方法设置最大值.</p>
<p>RecycledViewPool 是最后一级回收了.我们看一下这个RecycledViewPool 的实现.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public static class RecycledViewPool &#123;</span><br><span class="line">    private SparseArray&lt;ArrayList&lt;ViewHolder&gt;&gt; mScrap =</span><br><span class="line">            new SparseArray&lt;ArrayList&lt;ViewHolder&gt;&gt;();</span><br><span class="line">    private SparseIntArray mMaxScrap = new SparseIntArray();</span><br><span class="line">    private int mAttachCount = 0;</span><br><span class="line"></span><br><span class="line">    private static final int DEFAULT_MAX_SCRAP = 5;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">public void putRecycledView(ViewHolder scrap) &#123;</span><br><span class="line">    final int viewType = scrap.getItemViewType();</span><br><span class="line">    final ArrayList scrapHeap = getScrapHeapForType(viewType);</span><br><span class="line">    if (mMaxScrap.get(viewType) &lt;= scrapHeap.size()) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if (DEBUG &amp;&amp; scrapHeap.contains(scrap)) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;this scrap item already exists&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    scrap.resetInternal();</span><br><span class="line">    scrapHeap.add(scrap);</span><br><span class="line">&#125;</span><br><span class="line">…</span><br><span class="line"></span><br><span class="line">private ArrayList&lt;ViewHolder&gt; getScrapHeapForType(int viewType) &#123;</span><br><span class="line">    ArrayList&lt;ViewHolder&gt; scrap = mScrap.get(viewType);</span><br><span class="line">    if (scrap == null) &#123;</span><br><span class="line">        scrap = new ArrayList&lt;&gt;();</span><br><span class="line">        mScrap.put(viewType, scrap);</span><br><span class="line">        if (mMaxScrap.indexOfKey(viewType) &lt; 0) &#123;</span><br><span class="line">            mMaxScrap.put(viewType, DEFAULT_MAX_SCRAP);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return scrap;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们可以看出这里使用了SparseArray&lt;ArrayList<viewholder>&gt;来存储 View,由于SparseArray 可以动态增加,所以我们并不需要手动写明 viewTypeCount. 同时我们也可以看到每种类型缓存最大值为5 ,大于5以后 的 view 会被丢弃.</viewholder></p>
<p>##对比:</p>
<ol>
<li>lv为一 View 为单位. rv 以 ViewHolder 为单位. 设计上 rv 更先进.</li>
</ol>
<ul>
<li>lv对多 type 的缓存机制不太好, 只要被生成 View 都会被缓存起来.<br>eg:当出现大量 type 1 出现以后,在出现大量的 type2, 此时内存中就还有存在大量的 type1和大量的 type2. 而我们现在只有 type2,多余的 type1 一直占有内存不释放..而rv 的滑动时候的缓存是RecycledViewPool +mCachedViews , mCachedViews只有2个,而RecycledViewPool相同 type 最多存储5个.也就像上面的场景, rv 就不会有大量的 type1和 type2 的出现.</li>
<li>rv 的缓存定制能力更强.你可以自定义一个RecycledViewPool 进去,也能设置mCachedViews 的容量.</li>
</ul>
<p>##rv 使用的坑:</p>
<ol>
<li>当你的 多type的是个,相同 type 出现在屏幕的数量差值大于5 的时候,并且经常出现的这种情况.比如说你的 type1 这时候在屏幕中是有13个,然后变成3,然后再变成13,这中情况交替出现的时候,会出现频繁的 View 的创建.因为你在13 切换到3 的时候,剩下的10要被缓存起来,但是RecycledViewPool只能缓存5个,mCachedViews最多帮助缓存2个,剩下的 View 就被释放了.当再次切换到13的情况下,就只能创建 View 了,我们可以通过setMaxRecycledViews对RecycledViewPool 缓存最大值的修改.</li>
</ol>
<ul>
<li>出于动画的考量.当你的 数据的改变而你调用notifyItemChanged 的时候.因为此时的 View 被 mChangedScrap 储存.而且mChangedScrap只会在 pre-Layout 中返回,导致你在 real-layout 中得到 View 是一个新的 View, 所以notifyItemChanged 往往导致了一些 View 的创建和界面的图片的闪烁.</li>
</ul>
</div></article></div></main><footer><div class="paginator"><a href="/2016/05/27/gson-skill/" class="prev">PREV</a><a href="/2016/01/22/automatic_trace/" class="next">NEXT</a></div><div id="disqus_thread"></div><script src="/disqus.js"></script><script>var dsqjs = new DisqusJS({
shortname: 'dimredblog', 
identifier: '2016/03/07/rv_lv_cmp/',
url: 'http://dim.red/2016/03/07/rv_lv_cmp/', 
api: 'https://disqus.skk.moe/disqus/', 
apikey: 'MvtREFDD6pEIlmM1eqv3vACcJYJSAXfmfgYO4tlVfvgqlPSeE4xhPLQE0YXAbBBe'
});</script><div class="copyright"><p>© 2015 - 2020 <a href="http://dim.red">Dim</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>