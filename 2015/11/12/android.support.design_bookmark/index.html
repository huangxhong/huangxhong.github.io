<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> android.support.design 学习笔记 · dim's blog</title><meta name="description" content="android.support.design 学习笔记 - Dim"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="stylesheet" href="/css/disqusjs.css"><link rel="search" type="application/opensearchdescription+xml" href="http://dim.red/atom.xml" title="dim's blog"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">博客</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">文章</a></li><li class="nav-list-item"><a href="/about/" target="_self" class="nav-list-link">关于</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">android.support.design 学习笔记</h1><div class="post-info">Nov 12, 2015</div><div class="post-content"><p>在appcompat 22 的时候,google带来了Support Design,成为实现MD的利器,最近因为要开始使用这个库,稍微过了下库的内容.<br><a id="more"></a></p>
<p>这次主要通过讲解当前界面是怎么实现的.来学习这个库.<br>布局</p>
<p><img src="/2015/11/12/android.support.design_bookmark/android.support.design_01.png" alt="布局"></p>
<p>看看这个界面的实现,我们主要通过3个方面来了解,</p>
<ol>
<li>子控件的宽高的测量   </li>
</ol>
<ul>
<li>子控件的位置摆放</li>
<li>子控件的事件传递</li>
</ul>
<h2 id="1-测量"><a href="#1-测量" class="headerlink" title="1 测量:"></a>1 测量:</h2><p>因为它们的根控件是CoordinatorLayout .所以我们重点是放在<br>CoordinatorLayout 的onMeasure方法里面:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 省略N多代码</span><br><span class="line">     */</span><br><span class="line">        final Behavior b = lp.getBehavior();</span><br><span class="line">        if (b == null || !b.onMeasureChild(this, child, childWidthMeasureSpec, keylineWidthUsed,</span><br><span class="line">                childHeightMeasureSpec, 0)) &#123;</span><br><span class="line">            onMeasureChild(child, childWidthMeasureSpec, keylineWidthUsed,</span><br><span class="line">                    childHeightMeasureSpec, 0);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 省略N多代码</span><br><span class="line">     */</span><br><span class="line">         </span><br><span class="line">    setMeasuredDimension(width, height);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>子控件的测量交给他们的Behavior,Behavior 不处理,交给CoordinatorLayout处理  ,Behavior 可以在attr中指定. 可以看出ViewPager的Behavior 是AppBarLayout$ScrollingViewBehavior<br>,我们进入ScrollingViewBehavior 中的onMeasureChild方法中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public boolean onMeasureChild(CoordinatorLayout parent, View child,</span><br><span class="line">        int parentWidthMeasureSpec, int widthUsed, int parentHeightMeasureSpec,</span><br><span class="line">        int heightUsed) &#123;</span><br><span class="line">    final int childLpHeight = child.getLayoutParams().height;</span><br><span class="line">    if (childLpHeight == ViewGroup.LayoutParams.MATCH_PARENT</span><br><span class="line">            || childLpHeight == ViewGroup.LayoutParams.WRAP_CONTENT) &#123;</span><br><span class="line">     /**</span><br><span class="line">     * 省略N多代码</span><br><span class="line">     */</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    if (availableHeight == 0) &#123;</span><br><span class="line">       // If the measure spec doesn&apos;t specify a size, use the         current height</span><br><span class="line">         availableHeight = parent.getHeight();</span><br><span class="line">     &#125;</span><br><span class="line">     final int height = availableHeight - header.getMeasuredHeight()</span><br><span class="line">                    + getScrollRange(header);</span><br><span class="line">      final int heightMeasureSpec = View.MeasureSpec.makeMeasureSpec(height,</span><br><span class="line">                    childLpHeight == ViewGroup.LayoutParams.MATCH_PARENT</span><br><span class="line">                            ? View.MeasureSpec.EXACTLY</span><br><span class="line">                            : View.MeasureSpec.AT_MOST);</span><br><span class="line"></span><br><span class="line">            // Now measure the scrolling menu with the correct height</span><br><span class="line">      parent.onMeasureChild(child, parentWidthMeasureSpec,</span><br><span class="line">                    widthUsed, heightMeasureSpec, heightUsed);</span><br><span class="line"></span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看出来当你的ViewPager的高度不设置固定的值得话,他的高度会被ScrollingViewBehavior重新赋值,高度为CoordinatorLayout的高度减去AppBarLayout的可滑动范围.(既getTotalScrollRange())</p>
<p>可以看出:当前的ViewPager 的高度比我们当前屏幕上看的要高一点.</p>
<p>AppBarLayout 里面有3个范围比较有意思.<br><code>getTotalScrollRange()</code>:表示总共可以滑动的范围<br>它是计算所有layout_scrollFlags标有scroll 的View 的高度减去所有同时标有scroll 和 exitUntilCollapsed 的 View 的最小高度.</p>
<p><code>getDownNestedPreScrollRange()</code>:表示当向下滑动可以滑动的范围.<br>它计算了所有layout_scrollFlags同时标记scroll 和 enterAlways 同时不标记 enterAlwaysCollapsed的View 的高度 加上既标记了scroll 和 enterAlways又标记了enterAlwaysCollapsed 的最小高度.<br>产生的效果是:在下滑的过程中AppBarLayout残留在屏幕上的最小高度为 AppBarLayout本身的高度减去getDownNestedPreScrollRange()的高度.</p>
<p><code>getUpNestedPreScrollRange()</code>:表示当向上滑动可以滑动的范围.<br>这里返回的是getTotalScrollRange().<br>产生的效果是:在上滑的过程中AppBarLayout残留在屏幕上的最小高度为 AppBarLayout本身的高度减去getUpNestedPreScrollRange()的高.</p>
<p>而这三种范围构成了 AppBarLayout 在 RecyclerView 滑动事件的滑动效果.</p>
<h5 id="主意点"><a href="#主意点" class="headerlink" title="主意点:"></a>主意点:</h5><ol>
<li>exitUntilCollapsed只有和scroll一起组合才会有效果;</li>
</ol>
<ul>
<li>enterAlwaysCollapsed 要和scroll 和enterAlways一起使用才有效果.</li>
<li>官方说要把带有scroll flag的view放在前面，这样收回的view才能让正常退出，而固定的view继续留在顶部。<br>那是因为AppBarLayout 是一个 LinearLayout 布局.最后留在屏幕上的东西是 AppBarLayout 的底部,所以需要把要固定的 View 放在最后.</li>
<li>这里所有的 View 都是 AppBarLayout 的一级 View.二级不太考虑当中,</li>
</ul>
<p>下面放出几个例子来加深大家对layout_scrollFlags和3中范围的理解.<br>第一中 正常情况(scroll):<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;android.support.design.widget.AppBarLayout</span><br><span class="line">    android:id=&quot;@+id/appbar&quot;</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">    android:theme=&quot;@style/ThemeOverlay.AppCompat.Dark.ActionBar&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;android.support.v7.widget.Toolbar</span><br><span class="line">        android:id=&quot;@+id/toolbar&quot;</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;100dp&quot;</span><br><span class="line">        android:background=&quot;#f00&quot;</span><br><span class="line">        app:popupTheme=&quot;@style/ThemeOverlay.AppCompat.Light&quot;</span><br><span class="line">        app:layout_scrollFlags=&quot;scroll&quot; /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;android.support.design.widget.TabLayout</span><br><span class="line">        android:id=&quot;@+id/tabs&quot;</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;wrap_content&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;/android.support.design.widget.AppBarLayout&gt;</span><br></pre></td></tr></table></figure></p>
<p><img src="/2015/11/12/android.support.design_bookmark/android.support.design_02.gif" alt="demo_0.gif"></p>
<p>第2种(minHeight +scroll +exitUntilCollapsed)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;android.support.design.widget.AppBarLayout</span><br><span class="line">    android:id=&quot;@+id/appbar&quot;</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">    android:theme=&quot;@style/ThemeOverlay.AppCompat.Dark.ActionBar&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;android.support.v7.widget.Toolbar</span><br><span class="line">        android:id=&quot;@+id/toolbar&quot;</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;100dp&quot;</span><br><span class="line">        android:background=&quot;#f00&quot;</span><br><span class="line">        app:popupTheme=&quot;@style/ThemeOverlay.AppCompat.Light&quot;</span><br><span class="line">        android:minHeight=&quot;20dp&quot;</span><br><span class="line">        app:layout_scrollFlags=&quot;scroll|exitUntilCollapsed&quot; /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;android.support.design.widget.TabLayout</span><br><span class="line">        android:id=&quot;@+id/tabs&quot;</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;wrap_content&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;/android.support.design.widget.AppBarLayout&gt;</span><br></pre></td></tr></table></figure></p>
<p><img src="/2015/11/12/android.support.design_bookmark/android.support.design_03.gif" alt="demo_1.gif"></p>
<p>第3种(minHeight +scroll +enterAlways+enterAlwaysCollapsed)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;android.support.design.widget.AppBarLayout</span><br><span class="line">    android:id=&quot;@+id/appbar&quot;</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">    android:theme=&quot;@style/ThemeOverlay.AppCompat.Dark.ActionBar&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;android.support.v7.widget.Toolbar</span><br><span class="line">        android:id=&quot;@+id/toolbar&quot;</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;100dp&quot;</span><br><span class="line">        android:background=&quot;#f00&quot;</span><br><span class="line">        app:popupTheme=&quot;@style/ThemeOverlay.AppCompat.Light&quot;</span><br><span class="line">        android:minHeight=&quot;20dp&quot;</span><br><span class="line">        app:layout_scrollFlags=&quot;scroll|enterAlways|enterAlwaysCollapsed&quot; /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;android.support.design.widget.TabLayout</span><br><span class="line">        android:id=&quot;@+id/tabs&quot;</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;wrap_content&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;/android.support.design.widget.AppBarLayout&gt;</span><br></pre></td></tr></table></figure></p>
<p><img src="/2015/11/12/android.support.design_bookmark/android.support.design_04.gif" alt="demo_2.gif"></p>
<h2 id="2-位置摆放"><a href="#2-位置摆放" class="headerlink" title="2 位置摆放"></a>2 位置摆放</h2><p>同样进入CoordinatorLayout 的onLayout方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@Override</span><br><span class="line">protected void onLayout(boolean changed, int l, int t, int r, int b) &#123;</span><br><span class="line">    final int layoutDirection = ViewCompat.getLayoutDirection(this);</span><br><span class="line">    final int childCount = mDependencySortedChildren.size();</span><br><span class="line">    for (int i = 0; i &lt; childCount; i++) &#123;</span><br><span class="line">        final View child = mDependencySortedChildren.get(i);</span><br><span class="line">        final LayoutParams lp = (LayoutParams) child.getLayoutParams();</span><br><span class="line">        final Behavior behavior = lp.getBehavior();</span><br><span class="line"></span><br><span class="line">        if (behavior == null || !behavior.onLayoutChild(this, child, layoutDirection)) &#123;</span><br><span class="line">            onLayoutChild(child, layoutDirection);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>同样可以看到它也是先让Behavior处理.不处理才是CoordinatorLayout自身去处理.<br>同样我们为了查看ViewPager 的摆放,我们进入ScrollingViewBehavior 中的onLayoutChild方法中.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public boolean onLayoutChild(CoordinatorLayout parent, View child, int layoutDirection) &#123;</span><br><span class="line">    // First lay out the child as normal</span><br><span class="line">    super.onLayoutChild(parent, child, layoutDirection);</span><br><span class="line"></span><br><span class="line">    // Now offset us correctly to be in the correct position. This is important for things</span><br><span class="line">    // like activity transitions which rely on accurate positioning after the first layout.</span><br><span class="line">    final List&lt;View&gt; dependencies = parent.getDependencies(child);</span><br><span class="line">    for (int i = 0, z = dependencies.size(); i &lt; z; i++) &#123;</span><br><span class="line">        if (updateOffset(parent, child, dependencies.get(i))) &#123;</span><br><span class="line">            // If we updated the offset, break out of the loop now</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>先调用的父类的onLayoutChild 的方法.然后根据dependencies (其实就是AppBarLayout)的getTopBottomOffsetForScrollingSibling(),其实就是把ViewPager放在AppBarLayout的下方.</p>
<h2 id="3-事件传递"><a href="#3-事件传递" class="headerlink" title="3 事件传递"></a>3 事件传递</h2><h3 id="Touch事件的话"><a href="#Touch事件的话" class="headerlink" title="Touch事件的话"></a>Touch事件的话</h3><p>CoordinatorLayout是会在onInterceptTouchEvent 对所有的携带Behavior的第一级View 发送通知.如果被哪一个Behavior的onInterceptTouchEvent 的拦截,所以的后续的 Touch动作都分发给这个Behavior.</p>
<p><img src="/2015/11/12/android.support.design_bookmark/android.support.design_05.png" alt="7BE0A9A6-CA47-4FD4-9CFF-6BE1790B86B6.png"></p>
<h6 id="注意点"><a href="#注意点" class="headerlink" title="注意点:"></a>注意点:</h6><p>能接受到事件只有第一级的并且携带Behavior的控件.<br>同时这个事件是通知给所有的携带Behavior的控件,也就是说当你的点击事件不在这个 View 的上方,只要这个View 有携带 Behavior 都会收到通知,就是说不管你是点击屏幕上的1还是2,AppBarLayout 都会收到onInterceptTouchEvent事件,所以在复写 Behavior 的onInterceptTouchEvent 要特别注意到这个情况.</p>
<p>比如说界面一开始往上滑动. 这个时候点击事件是被AppBarLayout的Behavior 拦截的. AppBarLayout的Behavior事件会设置AppBarLayout的setTopAndBottomOffset ,使AppBarLayout产生了往上偏移,所以你可以看到AppBarLayout 往上偏移,那么ViewPager 为啥也向上偏移.因为ViewPager的ScrollingViewBehavior 中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public boolean layoutDependsOn(CoordinatorLayout parent, View child, View dependency) &#123;</span><br><span class="line">    // We depend on any AppBarLayouts</span><br><span class="line">    return dependency instanceof AppBarLayout;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对AppBarLayout 进行关联,当AppBarLayout 有变化的时候会通知给<br>ScrollingViewBehavior 的onDependentViewChanged 方法中.<br>通过在这个方法中进行对ViewPager的位置也进行偏移.使他们一起往上偏移.所以看起来想两个一起往上偏移,这个也是酷酷的.</p>
<h3 id="Scroll-事件"><a href="#Scroll-事件" class="headerlink" title="Scroll 事件"></a>Scroll 事件</h3><p>当Touch 事件在ViewPager中. 因为ViewPager中的使用的RecyclerView控件,而RecyclerView 是使用Nest来和其他控件一起处理Scroll事件.RecyclerView 的Nest的事件会一层一层的上传Scroll 事件,被最近的NestedScrollingParent 接受,这里是CoordinatorLayout ,CoordinatorLayout是一个协调者的角色,他将Nest的事件分发给子控件的View的Behavior处理.<br>在这里都会被AppBarLayout的Behavior接受.它会根据getTotalScrollRange,getDownNestedPreScrollRange,getUpNestedPreScrollRange来进行想对应的偏移. 效果在上面已经讲了.</p>
<h4 id="关于Nest-来处理-Scroll-事件"><a href="#关于Nest-来处理-Scroll-事件" class="headerlink" title="关于Nest 来处理 Scroll 事件:"></a>关于Nest 来处理 Scroll 事件:</h4><p>当 NestedScrollingChild(下面用Child代替) 要开始滑动的时候会发送 onStartNestedScroll 请求给最近的NestedScrollingParent(下面用Parent代替). 当onStartNestedScroll 返回 true 表示同意一起处理 Scroll 事件的时候时候Child会发送onNestedScrollAccepted 通知 让Parent去做一些准备动作,当Child 要开始滑动的时候,会先发送onNestedPreScroll 请求给Parent ,告诉它我现在要滑动多少米了,你觉得行不行,这时候Parent 根据实际情况告诉Child 现在只允许你滑动多少.然后 Child 根据 onNestedPreScroll 中传递回来的信息对滑动距离做相对应的调整.在滑动的过程中 Child 会发送onNestedScroll通知告知Parent 当前 Child 的滑动情况. 当要进行滑行的时候,会先发送onNestedFling 请求给Parent,告诉它 我现在要滑行了,你说行不行, 这时候Parent会根据情况告诉 Child 你是否可以滑行. Child 通过onNestedFling 返回的 Boolean 值来觉得是否进行滑行.如果要滑行的话,会在滑行的时候发送onNestedFling 通知告知 Parent 滑行情况.当滑动事件结束就会发送onStopNestedScroll 通知 Parent 去做相关操作.</p>
<h5 id="注意点-1"><a href="#注意点-1" class="headerlink" title="注意点:"></a>注意点:</h5><ol>
<li>Parent 告知 Child 现在允许你滑动多少是通过<br>onNestedPreScroll中的数组int[] consumed ,consumed[0]表示 Parent 在 X 轴消耗的量, 所以 Child 滑动距离是请求X轴的滑动距离上面减少consumed[0],consumed[1]表示 Y轴上面的消耗.<br>因为consumed是数组,所以Child可以完成可以拿到数据,而不需要onNestedPreScroll 的返回值.</li>
</ol>
<ul>
<li>重点注意讲解中的请求和通知.</li>
</ul>
<h2 id="尾巴"><a href="#尾巴" class="headerlink" title="尾巴"></a>尾巴</h2><p>详情界面我也大概看了一遍..机制差不多,其实就是多了CollapsingToolbarLayout这个的好玩的控件.所以这个学习笔记不一定有2.</p>
</div></article></div></main><footer><div class="paginator"><a href="/2016/01/22/automatic_trace/" class="prev">上一篇</a><a href="/2015/01/10/gsonformat/" class="next">下一篇</a></div><div id="disqus_thread"></div><script src="/disqus.js"></script><script>var dsqjs = new DisqusJS({
shortname: 'dimredblog', 
identifier: '2015/11/12/android.support.design_bookmark/',
url: 'http://dim.red/2015/11/12/android.support.design_bookmark/', 
api: 'https://disqus.skk.moe/disqus/', 
apikey: 'MvtREFDD6pEIlmM1eqv3vACcJYJSAXfmfgYO4tlVfvgqlPSeE4xhPLQE0YXAbBBe'
});</script><div class="copyright"><p>© 2015 - 2019 <a href="http://dim.red">Dim</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>