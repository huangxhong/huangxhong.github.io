<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>dim&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://dim.red/"/>
  <updated>2018-11-20T13:02:40.204Z</updated>
  <id>http://dim.red/</id>
  
  <author>
    <name>Dim</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Flutter 模块动态化初探</title>
    <link href="http://dim.red/2018/11/20/flutter_dy_exploration/"/>
    <id>http://dim.red/2018/11/20/flutter_dy_exploration/</id>
    <published>2018-11-19T16:00:00.000Z</published>
    <updated>2018-11-20T13:02:40.204Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://dim.red">dim.red</a></p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><a href="https://flutter.io/" target="_blank" rel="noopener">Flutter</a> : Flutter allows you to build beautiful native apps on iOS and Android from a single codebase.  具有跨平台, 高性能的优势.<br><a id="more"></a></p><h1 id="Flutter-产物"><a href="#Flutter-产物" class="headerlink" title="Flutter 产物"></a>Flutter 产物</h1><p><img src="https://upload-images.jianshu.io/upload_images/166866-ec16bd55f1c1a303.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=" Flutter 产物"></p><p>产物流向:</p><p><img src="https://upload-images.jianshu.io/upload_images/166866-5749c05ad706c7d4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="产物流向"><br>通过分析我们可以发现<br>不变的产物有 flutter.jar ,libfluter.so,icudtl.dat, vm_snapshot_data , vm_snapshot_instr, 不跟业务代码相关, 只跟 flutter engine 的版本有关. </p><p>变化的产物: flutter_assets , isolate_snapshot_data , isolate_snapshot_instr 主要是业务的代码和资源.<br>LICENSE 没用, 可以删除.<br>总结:<br>我们通过将不变的产物集成到APK 中.将变化组成一个资源包,通过配置下发下来.</p><h1 id="动态化改造"><a href="#动态化改造" class="headerlink" title="动态化改造"></a>动态化改造</h1><h2 id="Flutter-SDK-改造"><a href="#Flutter-SDK-改造" class="headerlink" title="Flutter SDK 改造"></a>Flutter SDK 改造</h2><p>修改 <code>Flutter.createView()</code> 方法.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">@NonNull</span><br><span class="line">  public static FlutterView createView(@NonNull final Context activity, @NonNull final Lifecycle lifecycle,</span><br><span class="line">                                       final String initialRoute, String bundlePath) &#123;</span><br><span class="line">      Context context = activity;</span><br><span class="line">      if (!TextUtils.isEmpty(bundlePath)) &#123;</span><br><span class="line">          final AssetManager bundleAsset = AssetManagerUtils.newAssetManager(bundlePath); //  Flutter  组件资源包位置</span><br><span class="line">          context = new ContextWrapper(activity) &#123;</span><br><span class="line">              @Override</span><br><span class="line">              public Resources getResources() &#123;</span><br><span class="line">                  return new Resources(bundleAsset,</span><br><span class="line">                          super.getResources().getDisplayMetrics(), super.getResources().getConfiguration()) &#123;</span><br><span class="line">                  &#125;;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      FlutterMain.startInitialization(context); // 使用自定义的 context </span><br><span class="line">      FlutterMain.ensureInitializationComplete(activity.getApplicationContext(), null);</span><br><span class="line">      final FlutterNativeView nativeView = new FlutterNativeView(context);// 使用自定义的 context </span><br><span class="line">    ...</span><br><span class="line">      return flutterView;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>这里:  通过反射 AssetManger . 同时将 bundlePath 添加进去.<br>bundlePath 的作用:</p><ul><li>用于查找 flutter_assets,  bundleAsset  会在 <code>FlutterNativeView.nativeRunBundleAndSnapshotFromLibrary()</code>传递给 Flutter 用于查找 flutter_assets  资源.</li><li>用于 copy isolate_snapshot_data , isolate_snapshot_instr 资源.</li></ul><p>Copy 资源是由 ResourceExtractor 完成的.<br>我们需要修改 ResourceExtractor.ExtractTask<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">private void extractResources() &#123;</span><br><span class="line">         final File dataDir = new File(PathUtils.getDataDirectory(mContext));</span><br><span class="line">         final AssetManager bundleManger = mContext.getResources().getAssets();</span><br><span class="line">         //获取 Apk 自身的 AssetsManger</span><br><span class="line">         final AssetManager shareManager = mContext.getApplicationContext().getResources().getAssets();</span><br><span class="line">         final String fluterBundleVersion = getFluterBundleVersion(bundleManger);</span><br><span class="line">         if (fluterBundleVersion != null) &#123;</span><br><span class="line">             Log.i(TAG, &quot;delete cache fluterBundleVersion &quot; + fluterBundleVersion);</span><br><span class="line">             deleteFiles();</span><br><span class="line">         &#125;</span><br><span class="line">         AssetManager manager;</span><br><span class="line">         byte[] buffer = null;</span><br><span class="line">         for (String asset : mResources) &#123;</span><br><span class="line">             try &#123;</span><br><span class="line">                 final File output = new File(dataDir, asset);</span><br><span class="line"></span><br><span class="line">                 if (output.exists()) &#123;</span><br><span class="line">                     continue;</span><br><span class="line">                 &#125;</span><br><span class="line">                 if (output.getParentFile() != null) &#123;</span><br><span class="line">                     output.getParentFile().mkdirs();</span><br><span class="line">                 &#125;</span><br><span class="line"></span><br><span class="line">                 manager = bundleManger;</span><br><span class="line">                 if (asset.startsWith(&quot;flutter_shared&quot;)</span><br><span class="line">                         || asset.equals(&quot;vm_snapshot_data&quot;)</span><br><span class="line">                         || asset.equals(&quot;vm_snapshot_instr&quot;)) &#123;</span><br><span class="line">                     manager = shareManager;</span><br><span class="line">                 &#125;</span><br><span class="line">                 ...</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125; catch (FileNotFoundException fnfe) &#123;</span><br><span class="line"></span><br><span class="line">                 continue;</span><br><span class="line">             &#125; catch (IOException ioe) &#123;</span><br><span class="line">                 Log.w(TAG, &quot;Exception unpacking resources: &quot; + ioe.getMessage());</span><br><span class="line">                 deleteFiles();</span><br><span class="line">                 return;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         if (fluterBundleVersion != null) &#123;</span><br><span class="line">             try &#123;</span><br><span class="line">                 new File(dataDir, fluterBundleVersion).createNewFile();</span><br><span class="line">             &#125; catch (IOException e) &#123;</span><br><span class="line">                 Log.w(TAG, &quot;Failed to write resource timestamp&quot;);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     private String getFluterBundleVersion(AssetManager bundleAssets) &#123;</span><br><span class="line">         final File dataDir = new File(PathUtils.getDataDirectory(mContext));</span><br><span class="line">         String expectedTimestamp = null;</span><br><span class="line">         try &#123;</span><br><span class="line">             InputStream in = bundleAssets.open(&quot;flutter_bundle_version&quot;);</span><br><span class="line">             expectedTimestamp = VERSION_PREFIX + IoUtils.toString(in);</span><br><span class="line">         &#125; catch (IOException e) &#123;</span><br><span class="line">             e.printStackTrace();</span><br><span class="line">         &#125;</span><br><span class="line">         if (expectedTimestamp == null) &#123;</span><br><span class="line">             return null;</span><br><span class="line">         &#125;</span><br><span class="line">         final String[] existingTimestamps = getVersionStamps(dataDir);</span><br><span class="line"></span><br><span class="line">         if (existingTimestamps == null) &#123;</span><br><span class="line">             return null;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         if (existingTimestamps.length != 1</span><br><span class="line">                 || !expectedTimestamp.equals(existingTimestamps[0])) &#123;</span><br><span class="line">             return expectedTimestamp;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         return null;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure></p><p>主要的修改:</p><ul><li>共享的资源由 APK 的 AssetsManger 中获取. 其他由 bundleManger 中获取 </li><li>修改 ResourceExtractor 更新资源逻辑, 由本来的 res_timestamp- {versionCode} -{packageInfo.lastUpdateTime} 不同就更新改为 flutter_bundle_version 不同就更新.</li></ul><h2 id="打包插件修改"><a href="#打包插件修改" class="headerlink" title="打包插件修改:"></a>打包插件修改:</h2><h3 id="组件资源插件"><a href="#组件资源插件" class="headerlink" title="组件资源插件"></a>组件资源插件</h3><p><img src="https://upload-images.jianshu.io/upload_images/166866-699498d0e97ca513.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>需要做的事情:</p><ul><li>需要组合成一个APK, 因为需要被 AssetManger 识别.</li><li>不需要包含代码,</li><li>android 资源尽可能少, 但是需要 AndroidManifest.xml</li><li>flutter_bundle_version. 每次编译都应不同, 用于 ResourceExtractor 更新版本逻辑.</li><li>flutter_engine_version 获取 flutter sdk 版本, 相同版本才能升级, 防止因为版本实现不同导致的 bug.</li><li>flutter_bridge_version 是一个 md5. 是对所有自定义的  <code>MethodChannel.MethodCallHandler</code> 进行 ABI 格式化. 即 APK 具有一样的扩展能力.相同版本才能升级.</li><li>保留 isolate_snapshot_data, isolate_snapshot_instr 文件.<h3 id="lib-插件"><a href="#lib-插件" class="headerlink" title="lib 插件"></a>lib 插件</h3>Flutter 模块 一般情况我们是以 aar 的形式依赖. 需要修改上传到 maven 的AAR 如下.<br><img src="https://upload-images.jianshu.io/upload_images/166866-78ce6a0fdb15a568.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></li><li>保留 vm_snapshot_data, vm_snapshot_instr 文件.</li><li>保留 flutter_bundle_version ,flutter_engine_version,flutter_bridge_version 作用如上.</li></ul><h2 id="flutter-gradle-修改"><a href="#flutter-gradle-修改" class="headerlink" title="flutter.gradle 修改"></a>flutter.gradle 修改</h2><ul><li>copy  {flutter sdk}\flutter\packages\flutter_tools\gradle\flutter.gradle</li><li>修改 release  依赖为自定义的 flutter jar.</li></ul><h1 id="尾巴"><a href="#尾巴" class="headerlink" title="尾巴"></a>尾巴</h1><p>  更详情的分析留在后面。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://dim.red&quot;&gt;dim.red&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://flutter.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Flutter&lt;/a&gt; : Flutter allows you to build beautiful native apps on iOS and Android from a single codebase.  具有跨平台, 高性能的优势.&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Android 中的引用类型初探</title>
    <link href="http://dim.red/2018/11/18/android_reference_exploration/"/>
    <id>http://dim.red/2018/11/18/android_reference_exploration/</id>
    <published>2018-11-17T16:00:00.000Z</published>
    <updated>2018-11-20T13:04:39.381Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://dim.red">dim.red</a></p><h1 id="引用种类"><a href="#引用种类" class="headerlink" title="引用种类"></a>引用种类</h1><ul><li><p>强引用:在 GC 中如果发现一个对象是可达的，那么 GC 在任何情况都不会回收这个对象</p></li><li><p><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/ref/SoftReference.html" target="_blank" rel="noopener">软引用(SoftReference)</a>：在 GC 中如果发现一个对象是软可达的 。那么 GC 可以根据内存情况清除这些对象。并且保证在抛出 OutOfMemoryError 异常之前。所有的软引用的对象是已经回收过。 </p></li><li><p><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/ref/WeakReference.html" target="_blank" rel="noopener">弱引用(WeakReference)</a>：在 GC 中如果发现一个对象是软可达的，GC 会回收这些对象。</p></li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/ref/PhantomReference.html" target="_blank" rel="noopener">虚引用(PhantomReference)</a>：在 GC 中如果发现是一个幽灵引用的时候，GC 会回收这些对象。</li></ul><p>总结： 强引用在任何情况都不会被回收。软引用在 GC 可以被回收。弱引用和虚引用在 GC 中会尽可能回收。<br><a id="more"></a></p><h1 id="GC-流程简介"><a href="#GC-流程简介" class="headerlink" title="GC 流程简介"></a>GC 流程简介</h1><p>Android GC 主要分为 标记 和 清除 阶段、 通过定义两个 Bitmap， Live Bitmap 和 Mark Bitmap ， 前者表示上次 GC 存活的对象。后者表示这次 GC 存活的对象。 Mark Bitmap 存在 而 Live Bitmap 不存在的为当前 GC 回收的对象。 GC 结束的时候将  Mark Bitmap  设置为 Live Bitmap。 不管并行还是串行GC， 或者 ART 的 GC 基本流程类似。</p><h2 id="Reference-状态。"><a href="#Reference-状态。" class="headerlink" title="Reference 状态。"></a>Reference 状态。</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Reference&lt;T&gt; &#123;</span><br><span class="line">    ...</span><br><span class="line">    volatile T referent; </span><br><span class="line"></span><br><span class="line">    final ReferenceQueue&lt;? super T&gt; queue; </span><br><span class="line"></span><br><span class="line">    Reference queueNext;</span><br><span class="line"></span><br><span class="line">    Reference&lt;?&gt; pendingNext;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参数介绍：</p><ul><li>referent：引用对象， referent 回收的时候设置为 null。</li><li>queue ：声明的队列。 不为空的时候，在 referent 被回收以后，最终 Reference 会被添加到队列中去。</li><li>queueNext ：默认为 null， 在 <code>Enqueued</code> 状态表示同一个 queue 下，下一个 Reference 节点。</li><li>pendingNext：默认为 null ，在 <code>Pending</code> 的时候，表示下一个待处理 Reference 节点</li></ul><h3 id="状态装换"><a href="#状态装换" class="headerlink" title="状态装换"></a>状态装换</h3><p>Reference  有 4 种状态 <code>Active</code>,<code>Pending</code>,<code>Enqueued</code>,<code>Inactive</code>。<br><img src="https://upload-images.jianshu.io/upload_images/166866-1200f9eaa9dae130.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><ul><li>queue 不为空：</li></ul><p>声明的时候默认为  <code>Active</code> 状态（ queueNext  为空 ，pendingNext 为空 ）。在 GC 发现 referent 对象可以被回收，回收 referent ，设置 referent 为 null ， 将 Reference 放在 clear 队列当中。 状态为 <code>Pending</code> 状态（ queueNext  为空 ，pendingNext 不为空 ），GC 会唤醒 ReferenceQueueDaemon 线程处理引用 clear 队列。 ReferenceQueueDaemon 处理  clear 队列。将  Reference 对象放到 queue 队列里面去。 状态为 <code>Enqueued</code> 状态（ queueNext  不为空 ，pendingNext 为 Reference ）。 当 queue  调用 poll() 将 Reference 获取出来。 状态为 <code>Inactive</code>（ queueNext 为 ReferenceQueue.sQueueNextUnenqueued，pendingNext 为 Reference）。</p><ul><li>queue 为空</li></ul><p>声明的时候默认为  <code>Active</code> 状态（queueNext  为空 ，pendingNext 为空 ）。在 GC 发现 referent 对象可以被回收，回收 referent ，设置 referent 为 null 。状态为 <code>Inactive</code> （queueNext  为空 ，pendingNext 为空 ）。</p><h1 id="Reference-处理流程。"><a href="#Reference-处理流程。" class="headerlink" title="Reference 处理流程。"></a>Reference 处理流程。</h1><h3 id="虚拟机启动"><a href="#虚拟机启动" class="headerlink" title="虚拟机启动"></a>虚拟机启动</h3><p>虚拟机启动的时候会启动守护线程。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public final class Daemons&#123;</span><br><span class="line">   public static void start() &#123;</span><br><span class="line">        ReferenceQueueDaemon.INSTANCE.start(); // 引用队列处理。 </span><br><span class="line">        FinalizerDaemon.INSTANCE.start(); // 处理 finalize 线程</span><br><span class="line">        FinalizerWatchdogDaemon.INSTANCE.start(); // 监听 finalize 方法超时。</span><br><span class="line">        HeapTaskDaemon.INSTANCE.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="加载链接类"><a href="#加载链接类" class="headerlink" title="加载链接类"></a>加载链接类</h3><p>在 虚拟机加载和链接类的时候，会对 Class 进行引用类型判断。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> */</span><br><span class="line">enum ClassFlags &#123;</span><br><span class="line"> ...</span><br><span class="line">    CLASS_ISREFERENCE          = (1&lt;&lt;27), // class is a soft/weak/phantom ref</span><br><span class="line">                                          // only ISREFERENCE is set --&gt; soft</span><br><span class="line">    CLASS_ISWEAKREFERENCE      = (1&lt;&lt;26), // class is a weak reference</span><br><span class="line">    CLASS_ISFINALIZERREFERENCE = (1&lt;&lt;25), // class is a finalizer reference</span><br><span class="line">    CLASS_ISPHANTOMREFERENCE   = (1&lt;&lt;24), // class is a phantom reference</span><br><span class="line"></span><br><span class="line"> ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">static void loadMethodFromDex(ClassObject* clazz, const DexMethod* pDexMethod,</span><br><span class="line">    Method* meth)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    if (dvmCompareNameDescriptorAndMethod(&quot;finalize&quot;, &quot;()V&quot;, meth) == 0) &#123;</span><br><span class="line"></span><br><span class="line">        if (clazz-&gt;classLoader != NULL ||</span><br><span class="line">            strcmp(clazz-&gt;descriptor, &quot;Ljava/lang/Enum;&quot;) != 0)</span><br><span class="line">        &#123;</span><br><span class="line">            SET_CLASS_FLAG(clazz, CLASS_ISFINALIZABLE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加载类的时候如果发现自定义了 finalize 方法， 那么会在 class 的 <code>accessFlags</code> 对象打上 <code>CLASS_ISFINALIZABLE</code> 标志。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">bool dvmLinkClass(ClassObject* clazz)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line"> </span><br><span class="line">    if (strcmp(clazz-&gt;descriptor, &quot;Ljava/lang/Object;&quot;) == 0) &#123;</span><br><span class="line">        /* Don&apos;t finalize objects whose classes use the</span><br><span class="line">         * default (empty) Object.finalize().</span><br><span class="line">         */</span><br><span class="line">        CLEAR_CLASS_FLAG(clazz, CLASS_ISFINALIZABLE);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">       </span><br><span class="line">        if (IS_CLASS_FLAG_SET(clazz-&gt;super, CLASS_ISFINALIZABLE)) &#123;</span><br><span class="line">            SET_CLASS_FLAG(clazz, CLASS_ISFINALIZABLE);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /* See if this class descends from java.lang.Reference</span><br><span class="line">         * and set the class flags appropriately.</span><br><span class="line">         */</span><br><span class="line">        if (IS_CLASS_FLAG_SET(clazz-&gt;super, CLASS_ISREFERENCE)) &#123;</span><br><span class="line">            u4 superRefFlags;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">            superRefFlags = GET_CLASS_FLAG_GROUP(clazz-&gt;super,</span><br><span class="line">                    CLASS_ISREFERENCE |</span><br><span class="line">                    CLASS_ISWEAKREFERENCE |</span><br><span class="line">                    CLASS_ISFINALIZERREFERENCE |</span><br><span class="line">                    CLASS_ISPHANTOMREFERENCE);</span><br><span class="line">            SET_CLASS_FLAG(clazz, superRefFlags);</span><br><span class="line">        &#125; else if (clazz-&gt;classLoader == NULL &amp;&amp;</span><br><span class="line">                clazz-&gt;super-&gt;classLoader == NULL &amp;&amp;</span><br><span class="line">                strcmp(clazz-&gt;super-&gt;descriptor,</span><br><span class="line">                       &quot;Ljava/lang/ref/Reference;&quot;) == 0)</span><br><span class="line">        &#123;</span><br><span class="line">            u4 refFlags;</span><br><span class="line"></span><br><span class="line">            refFlags = CLASS_ISREFERENCE;</span><br><span class="line">            if (strcmp(clazz-&gt;descriptor,</span><br><span class="line">                       &quot;Ljava/lang/ref/SoftReference;&quot;) == 0)</span><br><span class="line">            &#123;</span><br><span class="line">            &#125; else if (strcmp(clazz-&gt;descriptor,</span><br><span class="line">                       &quot;Ljava/lang/ref/WeakReference;&quot;) == 0)</span><br><span class="line">            &#123;</span><br><span class="line">                refFlags |= CLASS_ISWEAKREFERENCE;</span><br><span class="line">            &#125; else if (strcmp(clazz-&gt;descriptor,</span><br><span class="line">                       &quot;Ljava/lang/ref/FinalizerReference;&quot;) == 0)</span><br><span class="line">            &#123;</span><br><span class="line">                refFlags |= CLASS_ISFINALIZERREFERENCE;</span><br><span class="line">            &#125;  else if (strcmp(clazz-&gt;descriptor,</span><br><span class="line">                       &quot;Ljava/lang/ref/PhantomReference;&quot;) == 0)</span><br><span class="line">            &#123;</span><br><span class="line">                refFlags |= CLASS_ISPHANTOMREFERENCE;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                /* No-one else is allowed to inherit directly</span><br><span class="line">                 * from Reference.</span><br><span class="line">                 */</span><br><span class="line">//xxx is this the right exception?  better than an assertion.</span><br><span class="line">                dvmThrowLinkageError(&quot;illegal inheritance from Reference&quot;);</span><br><span class="line">                goto bail;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            SET_CLASS_FLAG(clazz, refFlags);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   ...</span><br><span class="line">    return okay;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>链接类的时候:<br>当一个 Class 是 <code>SoftReference</code> 或者它的派生类则它的 <code>accessFlags</code> 会被设置为 <code>CLASS_ISREFERENCE</code> 。<br>当一个 Class 是 WeakReference 或者 它的派生类则它的 <code>accessFlags</code> 被设置为<code>CLASS_ISREFERENCE</code> | <code>CLASS_ISPHANTOMREFERENCE</code>。<br>当一个 Class 是 <code>PhantomReference</code> 或者 它的派生类则它的 <code>accessFlags</code> 被设置为 <code>CLASS_ISREFERENCE</code> | <code>CLASS_ISPHANTOMREFERENCE</code>。<br>当一个 Class 是 <code>FinalizerReference</code> 则它的 <code>accessFlags</code> 被设置为 <code>CLASS_ISREFERENCE</code> | <code>CLASS_ISFINALIZERREFERENCE</code>。 它没有派生类， 因为 <code>FinalizerReference</code> 是 Final 。<br>当一个 Class 拥有自定义的 <code>finalize()</code>方法， 或者父类拥有<code>finalize()</code>方法， 那么就会被打上 <code>CLASS_ISFINALIZABLE</code> 标识。 这里有一个是例外 。<code>Object</code>的 <code>finalize()</code>是一个空实现。 它又是所有类的父类。 它会被清除 <code>CLASS_ISFINALIZABLE</code> 标识。因为如果不这样， 所有的类都将被打上 <code>CLASS_ISFINALIZABLE</code>。</p><h3 id="对象初始化。"><a href="#对象初始化。" class="headerlink" title="对象初始化。"></a>对象初始化。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/* File: c/OP_INVOKE_OBJECT_INIT_RANGE.cpp */</span><br><span class="line">HANDLE_OPCODE(OP_INVOKE_OBJECT_INIT_RANGE /*&#123;vCCCC..v(CCCC+AA-1)&#125;, meth@BBBB*/)</span><br><span class="line">    &#123;</span><br><span class="line">     ...</span><br><span class="line">         */</span><br><span class="line">        if (IS_CLASS_FLAG_SET(obj-&gt;clazz, CLASS_ISFINALIZABLE)) &#123;</span><br><span class="line">            EXPORT_PC();</span><br><span class="line">            dvmSetFinalizable(obj);</span><br><span class="line">            if (dvmGetException(self))</span><br><span class="line">                GOTO_exceptionThrown();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">     ...</span><br><span class="line">        FINISH(3);</span><br><span class="line">    &#125;</span><br><span class="line">OP_END</span><br></pre></td></tr></table></figure><p>在类初始化的时候， 会根据 class 是否有 <code>CLASS_ISFINALIZABLE</code>， 即 拥有 自定义 finalize 方法。 那么会调用 <code>dvmSetFinalizable</code>， <code>dvmSetFinalizable</code> 内部调用了 Java 的 <code>FinalizerReference.add</code> 方法。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public final class FinalizerReference&lt;T&gt; extends Reference&lt;T&gt;&#123;</span><br><span class="line">    // This queue contains those objects eligible for finalization.</span><br><span class="line">    public static final ReferenceQueue&lt;Object&gt; queue = new ReferenceQueue&lt;Object&gt;();</span><br><span class="line"></span><br><span class="line">    public static void add(Object referent) &#123;</span><br><span class="line">        FinalizerReference&lt;?&gt; reference = new FinalizerReference&lt;Object&gt;(referent, queue);</span><br><span class="line">        synchronized (LIST_LOCK) &#123;</span><br><span class="line">            reference.prev = null;</span><br><span class="line">            reference.next = head;</span><br><span class="line">            if (head != null) &#123;</span><br><span class="line">                head.prev = reference;</span><br><span class="line">            &#125;</span><br><span class="line">            head = reference;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里生成了一个新的引用 <code>FinalizerReference</code> 来持有对象，所有的<code>FinalizerReference</code> 设置同一个 <code>queue</code> 。同时将所有的 <code>FinalizerReference</code> 串联起来。</p><h1 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h1><p>标记动作就是从 根集 对象开始标记，在标记对象的时候，会根据对象的引用类型，添加到对应的引用队列中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">*</span><br><span class="line"> * Process the &quot;referent&quot; field in a java.lang.ref.Reference.  If the</span><br><span class="line"> * referent has not yet been marked, put it on the appropriate list in</span><br><span class="line"> * the gcHeap for later processing.</span><br><span class="line"> */</span><br><span class="line">static void delayReferenceReferent(Object *obj, GcMarkContext *ctx)</span><br><span class="line">&#123;</span><br><span class="line">   ...</span><br><span class="line">       if (pending == NULL &amp;&amp; referent != NULL &amp;&amp; !isMarked(referent, ctx)) &#123;</span><br><span class="line">        Object **list = NULL;</span><br><span class="line">        if (isSoftReference(obj)) &#123;</span><br><span class="line">            list = &amp;gcHeap-&gt;softReferences;</span><br><span class="line">        &#125; else if (isWeakReference(obj)) &#123;</span><br><span class="line">            list = &amp;gcHeap-&gt;weakReferences;</span><br><span class="line">        &#125; else if (isFinalizerReference(obj)) &#123;</span><br><span class="line">            list = &amp;gcHeap-&gt;finalizerReferences;</span><br><span class="line">        &#125; else if (isPhantomReference(obj)) &#123;</span><br><span class="line">            list = &amp;gcHeap-&gt;phantomReferences;</span><br><span class="line">        &#125;</span><br><span class="line">        assert(list != NULL);</span><br><span class="line">        enqueuePendingReference(obj, list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>接下来处理 4 种引用队列。 软引用， 弱引用， 虚引用， finalizer 引用队列<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">void dvmHeapProcessReferences(Object **softReferences, bool clearSoftRefs,</span><br><span class="line">                              Object **weakReferences,</span><br><span class="line">                              Object **finalizerReferences,</span><br><span class="line">                              Object **phantomReferences)</span><br><span class="line">&#123;</span><br><span class="line"> ...</span><br><span class="line">    /*</span><br><span class="line">     * Unless we are in the zygote or required to clear soft</span><br><span class="line">     * references with white references, preserve some white</span><br><span class="line">     * referents.</span><br><span class="line">     */</span><br><span class="line">    if (!gDvm.zygote &amp;&amp; !clearSoftRefs) &#123;</span><br><span class="line">        preserveSomeSoftReferences(softReferences);</span><br><span class="line">    &#125;</span><br><span class="line">    /*</span><br><span class="line">     * Clear all remaining soft and weak references with white</span><br><span class="line">     * referents.</span><br><span class="line">     */</span><br><span class="line">    clearWhiteReferences(softReferences);</span><br><span class="line">    clearWhiteReferences(weakReferences);</span><br><span class="line">    /*</span><br><span class="line">     * Preserve all white objects with finalize methods and schedule</span><br><span class="line">     * them for finalization.</span><br><span class="line">     */</span><br><span class="line">    enqueueFinalizerReferences(finalizerReferences);</span><br><span class="line">    /*</span><br><span class="line">     * Clear all f-reachable soft and weak references with white</span><br><span class="line">     * referents.</span><br><span class="line">     */</span><br><span class="line">    clearWhiteReferences(softReferences);</span><br><span class="line">    clearWhiteReferences(weakReferences);</span><br><span class="line">    /*</span><br><span class="line">     * Clear all phantom references with white referents.</span><br><span class="line">     */</span><br><span class="line">    clearWhiteReferences(phantomReferences);</span><br><span class="line">    /*</span><br><span class="line">     * At this point all reference lists should be empty.</span><br><span class="line">     */</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">static void clearWhiteReferences(Object **list)</span><br><span class="line">&#123;</span><br><span class="line">    GcMarkContext *ctx = &amp;gDvm.gcHeap-&gt;markContext;</span><br><span class="line">    size_t referentOffset = gDvm.offJavaLangRefReference_referent;</span><br><span class="line">    while (*list != NULL) &#123;</span><br><span class="line">        Object *ref = dequeuePendingReference(list);</span><br><span class="line">        Object *referent = dvmGetFieldObject(ref, referentOffset);</span><br><span class="line">        if (referent != NULL &amp;&amp; !isMarked(referent, ctx)) &#123;</span><br><span class="line">            /* Referent is white, clear it. */</span><br><span class="line">            clearReference(ref);</span><br><span class="line">            if (isEnqueuable(ref)) &#123;</span><br><span class="line">                enqueueReference(ref);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">static void enqueueReference(Object *ref)</span><br><span class="line">&#123;</span><br><span class="line">    assert(ref != NULL);</span><br><span class="line">    assert(dvmGetFieldObject(ref, gDvm.offJavaLangRefReference_queue) != NULL);</span><br><span class="line">    assert(dvmGetFieldObject(ref, gDvm.offJavaLangRefReference_queueNext) == NULL);</span><br><span class="line">    enqueuePendingReference(ref, &amp;gDvm.gcHeap-&gt;clearedReferences);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>对于弱引用，虚引用， 如果他们没有被标记，那么他们所持有的对象将会回收，referent 设置为 null 。 而他们本身根据 queue 是否为空进入不同状态， 为空将进入<code>Inactive</code> 状态。 不为空 进入<code>Pending</code> 状态。 所有的引用类型会被添加到 Clear 队列中。 此时加入的队列并不是他们自己的 queue 。<br>对软引用来说. 并不会全部回收， 默认情况会回收一半。除非是即将发生 OOM 才会全部回收。这也是软引用和 弱引用，虚引用的主要区别。<br>对于 <code>FinalizerReferences</code> 队列来说的话， 需要调用 <code>enqueueFinalizerReferences</code> 方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">static void enqueueFinalizerReferences(Object **list)</span><br><span class="line">&#123;</span><br><span class="line">    GcMarkContext *ctx = &amp;gDvm.gcHeap-&gt;markContext;</span><br><span class="line">    size_t referentOffset = gDvm.offJavaLangRefReference_referent;</span><br><span class="line">    size_t zombieOffset = gDvm.offJavaLangRefFinalizerReference_zombie;</span><br><span class="line">    bool hasEnqueued = false;</span><br><span class="line">    while (*list != NULL) &#123;</span><br><span class="line">        Object *ref = dequeuePendingReference(list);</span><br><span class="line">        Object *referent = dvmGetFieldObject(ref, referentOffset);</span><br><span class="line">        if (referent != NULL &amp;&amp; !isMarked(referent, ctx)) &#123;</span><br><span class="line">            markObject(referent, ctx);</span><br><span class="line">            dvmSetFieldObject(ref, zombieOffset, referent);</span><br><span class="line">            clearReference(ref);</span><br><span class="line">            enqueueReference(ref);</span><br><span class="line">            hasEnqueued = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (hasEnqueued) &#123;</span><br><span class="line">        processMarkStack(ctx);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于还需要执行 finalizer 方法。 所以需要将还没执行过 finalizer 方法并且未标记的对象标记，防止执行 finalizer 方法前对象被销毁了。然后将 Reference 添加到 Clear 队列。</p><p>注: 将 Reference 加入自身的 queue  方法 和  finalizer 方法均不在 GC 过程中调用。因为 GC 时间是宝贵的。 </p><p>处理后续  Clear 队列 交给了守护线程 ReferenceQueueDaemon 。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">private static class ReferenceQueueDaemon extends Daemon &#123;</span><br><span class="line">    private static final ReferenceQueueDaemon INSTANCE = new ReferenceQueueDaemon();</span><br><span class="line"></span><br><span class="line">    ReferenceQueueDaemon() &#123;</span><br><span class="line">        super(&quot;ReferenceQueueDaemon&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override public void runInternal() &#123;</span><br><span class="line">        while (isRunning()) &#123;</span><br><span class="line">            Reference&lt;?&gt; list;</span><br><span class="line">            try &#123;</span><br><span class="line">                synchronized (ReferenceQueue.class) &#123;</span><br><span class="line">                    while (ReferenceQueue.unenqueued == null) &#123;</span><br><span class="line">                        ReferenceQueue.class.wait();</span><br><span class="line">                    &#125;</span><br><span class="line">                    list = ReferenceQueue.unenqueued; // </span><br><span class="line">                    ReferenceQueue.unenqueued = null;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125; catch (OutOfMemoryError e) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            // 添加到自己的 queue</span><br><span class="line">            ReferenceQueue.enqueuePending(list);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>ReferenceQueue.unenqueued 就是 Clear 队列。将引用添加到自己的 queue 里面。 状态由 <code>Pending</code> 变更为 <code>Enqueued</code> 。</p><p>对于 <code>FinalizerReference</code> 对象的 finalize 方法。 它的处理交给 <code>FinalizerDaemon</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">private static class FinalizerDaemon extends Daemon &#123;</span><br><span class="line"></span><br><span class="line">       private final ReferenceQueue&lt;Object&gt; queue = FinalizerReference.queue;</span><br><span class="line">       @Override public void runInternal() &#123;</span><br><span class="line"></span><br><span class="line">           while (isRunning()) &#123;</span><br><span class="line">               try &#123;</span><br><span class="line">                   ...</span><br><span class="line">                   FinalizerReference&lt;?&gt; finalizingReference = (FinalizerReference&lt;?&gt;)queue.poll();</span><br><span class="line">                   ...</span><br><span class="line">                   doFinalize(finalizingReference);</span><br><span class="line">               &#125; catch (InterruptedException ignored) &#123;</span><br><span class="line">               &#125; catch (OutOfMemoryError ignored) &#123;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       private void doFinalize(FinalizerReference&lt;?&gt; reference) &#123;</span><br><span class="line">           FinalizerReference.remove(reference);</span><br><span class="line">           Object object = reference.get();</span><br><span class="line">           reference.clear();</span><br><span class="line">           try &#123;</span><br><span class="line">               object.finalize();</span><br><span class="line">           &#125; catch (Throwable ex) &#123;    </span><br><span class="line">           &#125; finally &#123;</span><br><span class="line">               finalizingObject = null;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>它是处理是从 <code>FinalizerReference</code> 的 queue 获取 <code>FinalizerReference</code>。 这里 queue 里面存的 <code>FinalizerReference</code> 已经是<code>Enqueued</code> 说明它持有的对象，已经应该需要销毁了。 所有获取的对象然后调用他们的  finalize 方法， 同时拦截所有的异常。并且不做处理。直接结束。 下次的 GC 就可以直接带走这些对象。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://dim.red&quot;&gt;dim.red&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;引用种类&quot;&gt;&lt;a href=&quot;#引用种类&quot; class=&quot;headerlink&quot; title=&quot;引用种类&quot;&gt;&lt;/a&gt;引用种类&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;强引用:在 GC 中如果发现一个对象是可达的，那么 GC 在任何情况都不会回收这个对象&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/lang/ref/SoftReference.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;软引用(SoftReference)&lt;/a&gt;：在 GC 中如果发现一个对象是软可达的 。那么 GC 可以根据内存情况清除这些对象。并且保证在抛出 OutOfMemoryError 异常之前。所有的软引用的对象是已经回收过。 &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/lang/ref/WeakReference.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;弱引用(WeakReference)&lt;/a&gt;：在 GC 中如果发现一个对象是软可达的，GC 会回收这些对象。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/lang/ref/PhantomReference.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;虚引用(PhantomReference)&lt;/a&gt;：在 GC 中如果发现是一个幽灵引用的时候，GC 会回收这些对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;总结： 强引用在任何情况都不会被回收。软引用在 GC 可以被回收。弱引用和虚引用在 GC 中会尽可能回收。&lt;br&gt;
    
    </summary>
    
      <category term="android" scheme="http://dim.red/categories/android/"/>
    
    
  </entry>
  
  <entry>
    <title>Gradle Configuration</title>
    <link href="http://dim.red/2018/11/03/gradle_configuration_exploration/"/>
    <id>http://dim.red/2018/11/03/gradle_configuration_exploration/</id>
    <published>2018-11-02T16:00:00.000Z</published>
    <updated>2018-11-03T05:43:54.776Z</updated>
    
    <content type="html"><![CDATA[<h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><p>Gradle：4.4.1</p><h1 id="Configuration-介绍"><a href="#Configuration-介绍" class="headerlink" title="Configuration 介绍"></a>Configuration 介绍</h1><p>通过声明的方式定义了一组依赖。Gradle 通过声明的方式查找对应依赖产物和他们的自身的依赖产物。它代表一组文件。只是这些文件是根据声明信息从本地或远程仓库中获取的。<br> <a id="more"></a></p><h1 id="Configuration-状态"><a href="#Configuration-状态" class="headerlink" title="Configuration 状态"></a>Configuration 状态</h1><p>状态分为三个 UNRESOLVED（未解析），RESOLVED（解析成功）/ RESOLVED_WITH_FAILURES（解析失败）<br>从未解析到解析成功或解析失败主要涉及两个过程，一 解析依赖图，二 获取产物。</p><h2 id="一-解析依赖图"><a href="#一-解析依赖图" class="headerlink" title="一 解析依赖图"></a>一 解析依赖图</h2><p>主要的功能是使用广度优先算法遍历解析依赖图。同时解决依赖图中相同依赖的版本冲突。</p><h3 id="解析冲突策略"><a href="#解析冲突策略" class="headerlink" title="解析冲突策略"></a>解析冲突策略</h3><p>解决版本冲突方式主要使用 3 种策略：</p><h4 id="1-版本优先："><a href="#1-版本优先：" class="headerlink" title="1 版本优先："></a>1 版本优先：</h4><p><code>LatestModuleConflictResolver</code><br>一个版本号版本被分为2两部分。<code>数字版本号</code>+<code>限定版本号</code>。<code>数字版本号</code>开始的数字的部分。剩下的为<code>限定版本号</code>在通常版本号分为<br><img src="https://upload-images.jianshu.io/upload_images/166866-82e5000c68d848d2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>eg：1.2.3-bate3，[1,2,3] 为<code>数字版本号</code>，[bate,3] 为 <code>限定版本号</code><br>比较原则</p><ol><li><code>数字版本号</code>比较大小，逐个比较数字部分，数字大的版本号大<br>eg： 1.2.3 &gt; 1.1.19 ，1.2.3.1 &gt; 1.2.3 </li><li><code>限定版本号</code>比较大小，数字 &gt; final &gt; release &gt; rc &gt; (任意非数字字符)  &gt; dev 。任意非数字字符比较方式是逐个比较 Char 的 ASCII码值。</li><li><code>数字版本号</code>大的版本号大。</li><li><code>数字版本号</code> 相同，没有<code>限定版本号</code> 大于有<code>限定版本号</code>。<br>eg：1.2.3 &gt;1.2.3-beta</li><li><code>数字版本号</code> 相同，<code>限定版本号</code>大的版本号大。<br>eg: 1.2.3-final &gt; 1.2.3-release &gt; 1.2.3-rc3 &gt; 1.2.3-rc  &gt; 1.2.3-beta &gt; 1.2.3-dev </li><li><code>数字版本号</code>相同，非 SNAPSHOT 大于 SNAPSHOT版本。<br>eg:1.2.3-beta &gt; 1.2.3-SNAPSHOT(注意全部大小)</li><li>版本声明顺序不影响版本号的比较。</li><li>一个依赖版本被选中，那么它的父节点也要被选中。</li></ol><h5 id="版本比较中的魔幻"><a href="#版本比较中的魔幻" class="headerlink" title="版本比较中的魔幻"></a>版本比较中的魔幻</h5><p>Q：版本 0.1.1-20181030.154719-1 跟 0.1.1-beta 哪个版本比较新？<br>A：0.1.1-beta。 虽然<code>数字版本号</code> 相同，限定版本 [20181030,154719,1] 大于 [beta]，但是 0.1.1-20181030.154719-1 满足正则<code>(.+)-\\d{8}\\.\\d{6}-\\d+·</code>会被解析成 0.1.1-SNAPSHOT 中的 20181030.154719-1版本 , 所以 0.1.1-20181030.154719-1 是个 SNAPSHOT 版本。对应比较原则中的第6原则，非 SNAPSHOT 大于 SNAPSHOT版本。</p><p>Q：版本 0.1.1-20181030.154719-1 跟 0.1.1-SNAPSHOT 哪个版本比较新？<br>A： 0.1.1-20181030.154719-1 </p><p>Q：1.2.1-SNAPSHOT VS 1.2.0<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">情况A：</span><br><span class="line">&apos;com.dim.red:one:1.2.0&apos;</span><br><span class="line">&apos;com.dim.red:one:1.2.1-SNAPSHOT&apos;</span><br><span class="line">情况B：</span><br><span class="line">&apos;com.dim.red:one:1.2.1-SNAPSHOT&apos;</span><br><span class="line">&apos;com.dim.red:one:1.2.0&apos;</span><br></pre></td></tr></table></figure></p><p>1.2.0 跟 1.2.1-SNAPSHOT 哪个版本比较,谁比较新？情况 A 和情况 B 会有不同吗？<br>A: 通过比较原则中 1 和 6 。那么 1.2.1-SNAPSHOT 不管在情况 A 和情况 B 中都应该始终大于 1.2.0 。但是在 Gradle 在 4.4 - 4.6 版本中存在一个BUG。<br>将导致的问题是情况 A 1.2.0 版本大于 1.2.1-SNAPSHOT。 情况 B 1.2.1-SNAPSHOT 大于 1.2.0。具体的原因可以比对版本 4.4.1 和 4.10.2 的实现。<br><a href="https://github.com/gradle/gradle/blob/v4.4.1/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/resolveengine/LatestModuleConflictResolver.java" target="_blank" rel="noopener">LatestModuleConflictResolver.select(details) （4.4.1）</a><br><a href="https://github.com/gradle/gradle/blob/v4.10.2/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/resolveengine/LatestModuleConflictResolver.java" target="_blank" rel="noopener">LatestModuleConflictResolver.select(details)（4.10.2 ） </a></p><p>Q：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">情况A</span><br><span class="line">com.dim.red:a:2.0.0</span><br><span class="line">\--- com.dim.red:b:1.2.0</span><br><span class="line">com.dim.red:c:1.0</span><br><span class="line">\--- com.dim.red:a:2.2.0</span><br><span class="line">     \--- com.dim.red:b:1.0.0</span><br><span class="line">情况B</span><br><span class="line">com.dim.red:c:1.0.0</span><br><span class="line">\--- com.dim.red:a:2.2.0</span><br><span class="line">     \--- com.dim.red:b:1.0.0</span><br><span class="line">com.dim.red:a:2.0.0</span><br><span class="line">\--- com.dim.red:b:1.2.0</span><br></pre></td></tr></table></figure></p><p>依赖 com.dim.red:b 会选中什么版本？情况 A 和情况 B 会有不同吗？<br>A：通过比较原则中 7 和 8。所以应该是 c:1.0，a:2.2.0，b:1.0.0。<br>但是在 Gradle 的不同版本实现中表现却不一样。在 Gradle 4.9 以下情况 A 会选中版本 c:1.0.0，a:2.2.0，b:1.2.0。而情况 B 选中版本 c:1.0.0，a:2.2.0，b:1.0.0  这里明显是一个BUG。 4.9 修正这个BUG。原因在于 4.9 以下在版本比较中没有过滤掉父节点为空的版本。但是 4.9 的版本中存在一个新的BUG #7050 。该 BUG 在5.0-rc中修复。但是 Gradle 5.0 - rc 的版本还不兼容现有的 Android Gradle Plugin 3.2.1 版本。 </p><h4 id="2-严格模式"><a href="#2-严格模式" class="headerlink" title="2 严格模式"></a>2 严格模式</h4><p><code>StrictConflictResolver</code><br> 不允许出现版本冲突。当出现版本冲突的时候，需要手动强制声明锁定版本。 </p><h4 id="3-项目优先"><a href="#3-项目优先" class="headerlink" title="3 项目优先"></a>3 项目优先</h4><p><code>ProjectDependencyForcingResolver</code><br>本地项目版本大于远程依赖版本。当没有远程或多个本地项目，使用版本优先算法进行比较。</p><h4 id="强制声明锁定版本"><a href="#强制声明锁定版本" class="headerlink" title="强制声明锁定版本"></a>强制声明锁定版本</h4><p>声明以后，在发生版本冲突的时候会直接选择锁定版本。而不需要经过策略。<br>锁定版本方式有两种：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">implementation (&apos;com.google.code.gson:gson:2.8.5&apos;)&#123;</span><br><span class="line">    force = true </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>或<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">configurations.all &#123;</span><br><span class="line">    resolutionStrategy &#123; </span><br><span class="line">        force &apos;com.google.code.gson:gson:2.8.5‘</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="策略设置"><a href="#策略设置" class="headerlink" title="策略设置"></a>策略设置</h3><p>默认策略为版本优先。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">configurations.all &#123;</span><br><span class="line">    resolutionStrategy &#123; </span><br><span class="line">    // 默认为版本优先模式</span><br><span class="line">//       failOnVersionConflict() // 切换策略为严格模式</span><br><span class="line">//       preferProjectModules() // 切换策略为项目优先模式。</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>解析依赖图是一件复杂的事情。Gradle 在上面做的并不好。 或许在 5.0 上会有更稳定，更健壮的表现。所以我们需要特别关心最终打到 APK 的依赖版本。可以使用命令 gradlew :{moduleName}:dependencies  或参考 <a href="https://dim.red/2018/02/05/android_dependency_analyse_code/">输出 Apk 所有的依赖</a> 文章分析 APK 的依赖。</p><h2 id="二-获取产物"><a href="#二-获取产物" class="headerlink" title="二 获取产物"></a>二 获取产物</h2><h3 id="缓存策略"><a href="#缓存策略" class="headerlink" title="缓存策略"></a>缓存策略</h3><p>在获取产物过程中，会先从缓存中获取。如果缓存有效。则直接从缓存中获取。缓存无效则请求远程仓库。<br>设置缓存策略：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">configurations.all &#123;</span><br><span class="line">  resolutionStrategy &#123;</span><br><span class="line">    // cache dynamic versions for 10 minutes</span><br><span class="line">    cacheDynamicVersionsFor 10*60, &apos;seconds&apos;</span><br><span class="line">    // don&apos;t cache changing modules at all</span><br><span class="line">    cacheChangingModulesFor 0, &apos;seconds&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里可以配置两种缓存规则，</p><ul><li><p>第一种是生效在动态版本上，动态版本包括最新版本和区间版本。最新版本是版本号使用<code>latest.</code>开头。 区间版本包括使用 <code>+</code> 和使用开闭区间<code>[()]</code>限制。</p></li><li><p>第二种是生效在可变版本上。可变版本指的用 <code>-SNAPSHOT</code> 结尾的版本。注意全部为大写</p></li></ul><p>默认缓存时间是一天。<br>所有非动态且非可变版本的依赖的缓存不受缓存策略的影响，默认是一直有效的。</p><h3 id="属性匹配"><a href="#属性匹配" class="headerlink" title="属性匹配"></a>属性匹配</h3><p>在获取产物的时候可能会遇到一个异常。</p><pre><code>Could not resolve all files for configuration &apos;:app:dim&apos;.   &gt; Could not resolve project :lib.     Required by:         project :app      &gt; Cannot choose between the following configurations of project :test1:          - debugApiElements          - debugRuntimeElements          - releaseApiElements          - releaseRuntimeElements</code></pre><p>这是在Gradle 3.0 以上会出现的问题。 原因在于依赖是可以存在多个变种。在没有属性值匹配的时候会找到多个的产物。Gradle 会抛出异常。因为 Gradle 也不知道应该返回哪一个变种。这个时候需要对 <code>Configuration</code> 加上属性，来筛选出唯一的变种。<br>Gradle 支持属性值的转换。通过定义一些 <code>Transform</code>  提供一些属性转换规则。在属性匹配不上的时候，尝试组合一条最短的 <code>Transform</code> 路径， 进行转换匹配。 筛选出唯一的产物。关于属性匹配和 <code>Transform</code> 相关知识。这里就不展开聊，可以查看相关链接 Gradle Transform 初探 了解更多细节。</p><h1 id="相关"><a href="#相关" class="headerlink" title="相关"></a>相关</h1><p><a href="https://docs.oracle.com/middleware/1212/core/MAVEN/maven_version.htm#MAVEN8855" target="_blank" rel="noopener">Understanding Maven Version Numbers</a><br><a href="https://dim.red/2018/01/25/gradle_transform_%20exploration/">Gradle Transform 初探</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;环境&quot;&gt;&lt;a href=&quot;#环境&quot; class=&quot;headerlink&quot; title=&quot;环境&quot;&gt;&lt;/a&gt;环境&lt;/h1&gt;&lt;p&gt;Gradle：4.4.1&lt;/p&gt;
&lt;h1 id=&quot;Configuration-介绍&quot;&gt;&lt;a href=&quot;#Configuration-介绍&quot; class=&quot;headerlink&quot; title=&quot;Configuration 介绍&quot;&gt;&lt;/a&gt;Configuration 介绍&lt;/h1&gt;&lt;p&gt;通过声明的方式定义了一组依赖。Gradle 通过声明的方式查找对应依赖产物和他们的自身的依赖产物。它代表一组文件。只是这些文件是根据声明信息从本地或远程仓库中获取的。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Gradle Task  UP-TO-DATE</title>
    <link href="http://dim.red/2018/08/24/gradle_task_UP-TO-DATE/"/>
    <id>http://dim.red/2018/08/24/gradle_task_UP-TO-DATE/</id>
    <published>2018-08-23T16:00:00.000Z</published>
    <updated>2018-11-06T16:58:10.525Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://dim.red">dim.red</a><br>环境：Gradle 4.4.1</p><h2 id="相关"><a href="#相关" class="headerlink" title="相关"></a>相关</h2><p>Task 输入输出注解<br>@Input，@InputFile，@InputFiles，@InputDirectory， @OutputFile，@OutputFiles，@OutputDirectory，@OutputDirectories，@Destroys，@LocalState，@Nested，@Inject，@OptionValues<br>@PathSensitive<br>@Classpath<br>@CompileClasspath<br><a id="more"></a></p><h1 id="0x00"><a href="#0x00" class="headerlink" title="0x00"></a>0x00</h1><p>Gradle 为了加快构建速度, 加入了快照缓存的概念。<br>当你的 Task 输出不需要变更。Gradle 会跳转执行过程，同时 Task 在输出打上 UP-TO-DATE 标识。</p><h1 id="0x01"><a href="#0x01" class="headerlink" title="0x01"></a>0x01</h1><p>怎样的判断一个 Task 输出不需要变更 ？<br>其中一个条件是比对当前执行状态和上次执行状态的不同。<br>HistoricalTaskExecution： 表示上次执行状态, 是从快照中反序列化出来的。<code>TaskExecutionSnapshotSerializer.read()</code><br>CurrentTaskExecution：表示当前执行状态，是根据当前 Task 的输入输出生成的。 <code>CacheBackedTaskHistoryRepository.createExecution</code>   </p><p>比对具体逻辑 <code>TaskUpToDateState</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">this.allTaskChanges = new ErrorHandlingTaskStateChanges(task, new SummaryTaskStateChanges(MAX_OUT_OF_DATE_MESSAGES, </span><br><span class="line">previousSuccessState,</span><br><span class="line">noHistoryState, </span><br><span class="line">taskTypeState, </span><br><span class="line">inputPropertiesState, </span><br><span class="line">outputFileChanges, </span><br><span class="line">inputFileChanges, </span><br><span class="line">discoveredInputFilesChanges</span><br><span class="line">));</span><br></pre></td></tr></table></figure></p><p>这里经过 7 个校验，全部验证通过说明这次执行相对上次没有变更，可以直接使用上次执行的输出。</p><ul><li>previousSuccessState：判断之前执行是否成功。</li><li>noHistoryState：判断是否有执行记录。</li><li>taskTypeState：比对 Task 和 Action 的实现。具体是比较 ClassLoader 的 Hash 。</li><li>inputPropertiesState：比对 InputPropert  变更。</li><li>outputFileChanges：比对 OutputFie 变更。</li><li>inputFileChanges：比对 InputFie 变更。</li><li>discoveredInputFilesChanges：比对 Task 中新增的 Input 变更 。</li></ul><h1 id="InputPropert"><a href="#InputPropert" class="headerlink" title="InputPropert"></a>InputPropert</h1><p>Map\&lt;String, Object&gt; 类型<br>来自注解 @Input 或API <code>Task.getInput.property</code>  和 <code>Task.getInput.propertys</code> 。</p><p>@Input 可以被序列化和反序列化的类型。支持的类型有 基本类型，枚举，Serializable 和 Name 扩展类型。<br><img src="https://upload-images.jianshu.io/upload_images/166866-96d872ae45d60060.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"> </p><h1 id="InputFile"><a href="#InputFile" class="headerlink" title="InputFile"></a>InputFile</h1><p>文件类型<br>来自注解  @InputFile @@InputFiles @InputDirectory 或 API<br><code>Task.getInput.file</code>， <code>Task.getInput.files</code>，<code>Task.getInput.dir</code> </p><h1 id="OutputFile"><a href="#OutputFile" class="headerlink" title="OutputFile"></a>OutputFile</h1><p>文件类型<br>来自注解 @OutputDirectory @OutputDirectories @OutputFile @OutputFiles 或 API <code>Task.getInput.dir</code>，<code>Task.getInput.dirs</code>，<code>Task.getInput.file</code>，<code>Task.getInput.files</code> </p><p>文件的比较主要分为3种， </p><ul><li>一般的文件：比较文件的的 Hash，Hash 是由文件 Normalized Name 和 文件的内容计算出来的 MD5。</li><li>Classpath文件： @Classpath 注释。这种类型在计算 jar 的Hash, 会先对 jar 文件里面的 ZipEntry 进行排序再和 Normalized Name 一起算出 MD5. 这样就不会因ZipEntry 排序导致的 MD5 不同。</li><li>CompileClassPath：@CompileClasspath 注释。 在 Classpath 的基础上, 对 Jar 中的 class 进行 ABI 格式化, 即当  jar 提供的接口不变，则 Jar 的 MD5 不变。 这种类型的加入也是使依赖从 compile 升级到  implementation 的关键。</li></ul><p>Normalized Name 的策略是注解 @PathSensitive 来确定的。 </p><ul><li>ABSOLUTE：文件的绝对位置。</li><li>RELATIVE：文件的相对位置</li><li>NAME_ONLY：文件名</li><li>NONE：忽略<br>默认值为 ABSOLUTE<br>具体实现查看代码<code>InputPathNormalizationStrategy</code></li></ul><p>@Nested 是自定义的类型。 是一组或者多组相关输入输出的集合。内部使用上面的注解来定义输入和输出。</p><p>注：注解可以声明字段或者 get 方法。但是注解要生效一定要有对应的 get 方法。</p><h1 id="0x01-1"><a href="#0x01-1" class="headerlink" title="0x01"></a>0x01</h1><p>Task 通过注解的方式定义输入和输出。<br>Gradle 中定义 Task 。<br><img src="https://upload-images.jianshu.io/upload_images/166866-943b0afc95a6700f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>通过接受一个 Class 类型来声明一个 Task 。<br>Class\<task>  -&gt;  Class\&lt;Task_Decorated&gt;  -&gt; Task_Decorated </task></p><p><img src="https://upload-images.jianshu.io/upload_images/166866-081ad9bc5cdd11b8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br> Class\<task> 会经过 ClassGenerator , TaskFactory,AnnotationProcessingTaskFactory 生成  Task_Decorated 对象。Task_Decorated 是对 Task 的扩展。</task></p><ul><li>ClassGenerator：使用 ASM 对原始的类进行分析，生成 Task 的子类 Task_Decorated，并且实现新的接口，增加新的方法和字段。使之具有扩展的能力。</li><li>TaskFactory：主要设置 Task_Decorated 合适的实例化方法。(为Task 构造方法注入 Service 对象)</li><li>AnnotationProcessingTaskFactory：反射获取 Task 的注解信息，通过一系列的 PropertyAnnotationHandler 处理 Task 类解析出对应 Input 和 Output 。</li></ul><h1 id="0x02"><a href="#0x02" class="headerlink" title="0x02"></a>0x02</h1><p>Task 的执行由 TaskExecuter 执行的。<br><code>TaskExecutionServices.createTaskExecuter()</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">TaskExecuter createTaskExecuter(TaskArtifactStateRepository repository,</span><br><span class="line">                                    TaskOutputCacheCommandFactory taskOutputCacheCommandFactory,</span><br><span class="line">                                    BuildCacheController buildCacheController,</span><br><span class="line">                                    StartParameter startParameter,</span><br><span class="line">                                    ListenerManager listenerManager,</span><br><span class="line">                                    TaskInputsListener inputsListener,</span><br><span class="line">                                    BuildOperationExecutor buildOperationExecutor,</span><br><span class="line">                                    AsyncWorkTracker asyncWorkTracker,</span><br><span class="line">                                    BuildOutputCleanupRegistry cleanupRegistry,</span><br><span class="line">                                    TaskOutputFilesRepository taskOutputFilesRepository,</span><br><span class="line">                                    BuildScanPluginApplied buildScanPlugin) &#123;</span><br><span class="line"></span><br><span class="line">        boolean taskOutputCacheEnabled = startParameter.isBuildCacheEnabled();</span><br><span class="line">        boolean scanPluginApplied = buildScanPlugin.isBuildScanPluginApplied();</span><br><span class="line">        TaskOutputsGenerationListener taskOutputsGenerationListener = listenerManager.getBroadcaster(TaskOutputsGenerationListener.class);</span><br><span class="line"></span><br><span class="line">        TaskExecuter executer = new ExecuteActionsTaskExecuter(</span><br><span class="line">            taskOutputsGenerationListener,</span><br><span class="line">            listenerManager.getBroadcaster(TaskActionListener.class),</span><br><span class="line">            buildOperationExecutor,</span><br><span class="line">            asyncWorkTracker</span><br><span class="line">        );</span><br><span class="line">        boolean verifyInputsEnabled = Boolean.getBoolean(&quot;org.gradle.tasks.verifyinputs&quot;);</span><br><span class="line">        if (verifyInputsEnabled) &#123;</span><br><span class="line">            executer = new VerifyNoInputChangesTaskExecuter(repository, executer);</span><br><span class="line">        &#125;</span><br><span class="line">        executer = new OutputDirectoryCreatingTaskExecuter(executer);</span><br><span class="line">        if (taskOutputCacheEnabled) &#123;</span><br><span class="line">            executer = new SkipCachedTaskExecuter(</span><br><span class="line">                buildCacheController,</span><br><span class="line">                taskOutputsGenerationListener,</span><br><span class="line">                taskOutputCacheCommandFactory,</span><br><span class="line">                executer</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">        executer = new SkipUpToDateTaskExecuter(executer);</span><br><span class="line">        executer = new ResolveTaskOutputCachingStateExecuter(taskOutputCacheEnabled, executer);</span><br><span class="line">        if (verifyInputsEnabled || taskOutputCacheEnabled || scanPluginApplied) &#123;</span><br><span class="line">            executer = new ResolveBuildCacheKeyExecuter(executer, buildOperationExecutor);</span><br><span class="line">        &#125;</span><br><span class="line">        executer = new ValidatingTaskExecuter(executer);</span><br><span class="line">        executer = new SkipEmptySourceFilesTaskExecuter(inputsListener, cleanupRegistry, taskOutputsGenerationListener, executer);</span><br><span class="line">        executer = new CleanupStaleOutputsExecuter(cleanupRegistry, taskOutputFilesRepository, buildOperationExecutor, executer);</span><br><span class="line">        executer = new ResolveTaskArtifactStateTaskExecuter(repository, executer);</span><br><span class="line">        executer = new SkipTaskWithNoActionsExecuter(executer);</span><br><span class="line">        executer = new SkipOnlyIfTaskExecuter(executer);</span><br><span class="line">        executer = new ExecuteAtMostOnceTaskExecuter(executer);</span><br><span class="line">        executer = new CatchExceptionTaskExecuter(executer);</span><br><span class="line">        return executer;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>这是一个装饰者模式。</p><ul><li>CatchExceptionTaskExecuter：拦截执行中出现的异常。</li><li>ExecuteAtMostOnceTaskExecuter：确保 Task 只执行一次。</li><li>SkipOnlyIfTaskExecuter：支持 Task.OnlyIf . Task.onlyIf 为 false 将跳过该任务的执行。 </li><li>SkipTaskWithNoActionsExecuter：过滤没有 Action 的 Task。(默认第一个 Action 是 Task 中的被 @TaskAction 的方法)</li><li>ResolveTaskArtifactStateTaskExecuter：从快照中反序列化出上次执行的状态(HistoricalTaskExecution)。</li><li>CleanupStaleOutputsExecuter：负责清除非 Task 执行中生成的文件</li><li>SkipEmptySourceFilesTaskExecuter：判断存在 Output 存在时 Source 文件不为空。Source 文件是输入文件中被 @SkipWhenEmpty 注释的属性。</li><li>ValidatingTaskExecuter：验证 input 和 output 。比如 input 的文件要存在等等。 </li><li>ResolveBuildCacheKeyExecuter：计算当前执行 Task 的 CacheKey，基于 TaskPath，input , output , Action 等信息， 作为后面从缓存中获取数据的 key。</li><li>ResolveTaskOutputCachingStateExecuter: 设置 Task Output 的缓存状态。</li><li>SkipUpToDateTaskExecuter：是否能直接跳过执行过程，逻辑主要是有几个， 一，task 的输入输出没有变更， 二 Task 输出 upToDate 为true，三，Gradle 执行命令没有使用 rerun-tasks 参数, 同时执行成功会保存当前 Task 状态(CurrentTaskExecution)的快照, 其中包括 InputPropert ，InputFile，OutputFile。 InputPropert 是将它序列化，而 InputFile，OutputFile 是保存的的文件的 Normalized Name 和 Hash，并不保存文件本身。默认保存在项目中(.gradle/4.4.1/taskHistory/taskHistory.bin)文件下。而这些将成为下一个执行时候从 <code>ResolveTaskArtifactStateTaskExecuter</code> 反序列化出来。</li><li>SkipCachedTaskExecuter：缓存有效的时候。尝试从根据 CacheKey 把 OutputFile 文件加载进来， 这里的缓存的来源可以是本地的文件也可是是远程的 Http 服务。同时在 Task 执行完成以后，将Task 输出缓存起来，同样可是缓存在本地或者远程。<br>默认情况本地存储是开启的，位置在全局的 .gradle/caches/build-cache-1/,<br>远程 Http 服务是关闭的。</li><li>OutputDirectoryCreatingTaskExecuter：Output 文件不存在自动创建</li><li>VerifyNoInputChangesTaskExecuter：验证输入在执行过程中是否有变更。</li><li>ExecuteActionsTaskExecuter: 执行被注解 @TaskAction 的方法和添加进来的 Action 。  </li></ul><p>需要注意的是这里有两种东西，一种是快照由 SkipUpToDateTaskExecuter 存储的是执行的状态，不包括 Output 的实体。另一种缓存是由 SkipCachedTaskExecuter 存储，是 Output 的实体而不是状态。</p><h1 id="0x03"><a href="#0x03" class="headerlink" title="0x03"></a>0x03</h1><p>当 Task 满足以下 4 个条件其中一个，则 Gradle 跳转执行过程。</p><ol><li>当一个 Task 定义了输出，Task 的 Output.upToDate 为 true，Task Source 为空。Gradle 将跳过该任务的执行。 Output 被标识 NO-SOURCE， Output 为空。</li><li>当一个 Task 定义了输出，Task 的 Output.upToDate 为 true，Task Source 不为空， Task 的输入和输出没有变更。Output 被标识 UP-TO-DATE，Gradle 将跳过该任务的执行。 使用上次的 Output 。</li><li>Task 的 OnlyIf 为 false, Gradle 将跳过该任务的执行。Output 被标识 SKIPPED  Output 为空。</li><li>支持缓存。缓存存在且有效，Gradle 将跳过该任务的执行。Output 被标识 FROM-CACHE，使用从缓存解压的 Output 。</li></ol><h1 id="0x04-尾巴"><a href="#0x04-尾巴" class="headerlink" title="0x04 尾巴"></a>0x04 尾巴</h1><p>Gradle 的代码相对比较松散, 而 Task 这块的代码相对比较集中。通过本章当中的一些关键节点可以很方便的进行学习和深入了解。 </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://dim.red&quot;&gt;dim.red&lt;/a&gt;&lt;br&gt;环境：Gradle 4.4.1&lt;/p&gt;
&lt;h2 id=&quot;相关&quot;&gt;&lt;a href=&quot;#相关&quot; class=&quot;headerlink&quot; title=&quot;相关&quot;&gt;&lt;/a&gt;相关&lt;/h2&gt;&lt;p&gt;Task 输入输出注解&lt;br&gt;@Input，@InputFile，@InputFiles，@InputDirectory， @OutputFile，@OutputFiles，@OutputDirectory，@OutputDirectories，@Destroys，@LocalState，@Nested，@Inject，@OptionValues&lt;br&gt;@PathSensitive&lt;br&gt;@Classpath&lt;br&gt;@CompileClasspath&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>一种新的修改字节码的思路</title>
    <link href="http://dim.red/2018/05/13/idea_by_modify/"/>
    <id>http://dim.red/2018/05/13/idea_by_modify/</id>
    <published>2018-05-12T16:00:00.000Z</published>
    <updated>2018-08-25T08:43:16.979Z</updated>
    
    <content type="html"><![CDATA[<p>博客地址: <a href="http://dim.red">dim.red</a></p><h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>分析最近的 Crash , 排在前列基本是第三方SDK导致. 遇到这样的问题, 我们需要寻求官方的支持, 但是官方的支持总是来得比较晚. 在Android上, 第三方SDK一般是两种, 一种是jar, 一种是so. so的修改成本过大, 我们放弃它, 我们现在探讨对 jar 的修改.<br><a id="more"></a></p><h1 id="0x02-问题"><a href="#0x02-问题" class="headerlink" title="0x02 问题"></a>0x02 问题</h1><p>在之前 <a href="http://dim.red/2017/12/04/aop/">使用AOP来为第三方SDK打CALL</a> 文章 我们使用 AOP 对第三方 SDK 的问题进行修复. 貌似能这样解决这个问题.<br>但是 AOP 存在局限性:<br>1、它不够直观. 定义的规则需要通过编译后才能确定.<br>2、学习成本较高.<br>3、可操作的范围不够大. 只能切方法.<br>例子:<br>在一些因素下,我们升级某个推送SDK版本. 但是发现有大量的NPE异常出现. 通过反编译 jar 定位问题.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">private Handler p = null;</span><br><span class="line">private void b() &#123;</span><br><span class="line">      if (this.p != null) &#123;</span><br><span class="line">          this.p.removeMessages(2);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">          this.p = new Handler(Looper.getMainLooper(), new com.xxx.b(this));</span><br><span class="line">      &#125;</span><br><span class="line">      this.p.sendEmptyMessageDelayed(2, 3000L);</span><br><span class="line"> &#125;</span><br><span class="line">private void c() &#123;</span><br><span class="line">      if (this.p != null) &#123;</span><br><span class="line">          this.p.removeMessages(2);</span><br><span class="line">          this.p = null;</span><br><span class="line">      &#125;</span><br><span class="line"> &#125;</span><br><span class="line">public void d()&#123;</span><br><span class="line">...</span><br><span class="line">  // 代码块A  开始</span><br><span class="line">  if(p != null)&#123;</span><br><span class="line">    this.p.sendEmptyMessageDelayed(3, 3000L);</span><br><span class="line">  &#125;</span><br><span class="line">  // 代码块A  结束</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>异常发生在方法<code>this.p.sendEmptyMessageDelayed(2, 3000L);</code>.在一个判断空还会出现NPE, 说明这是一个多线程并发下的bug.  通过分析我们需要</p><ol><li>对b c 方法使用synchronized 修饰</li><li>对代码块A 进行 synchronized(this) 包裹</li></ol><p>在这种场景下使用AOP将费力不讨好.</p><h1 id="0x03-解决方案"><a href="#0x03-解决方案" class="headerlink" title="0x03 解决方案"></a>0x03 解决方案</h1><p>我们可以尝试使用一种更简单的方式来处理这件事情. 输入一个原始的 jar , 经过转换生成新的 jar. </p><ul><li>步骤1: 对 jar 中需要修改的 class 反编译成 java 文件.</li><li>步骤2: 对 java 文件进行代码逻辑上的 bug fix.</li><li>步骤3: 使用 javac 编译 java 文件成 class 文件.</li><li>步骤4: 替换 jar 中对应的修改的 class 文件生成新的 jar 文件.</li></ul><h1 id="0x04-问题"><a href="#0x04-问题" class="headerlink" title="0x04 问题"></a>0x04 问题</h1><p>Q : javac 编译失败.<br>A: 当你 java 调用的方法不在原有的 jar 中, 导致 javac 编译的时候找不到对应的方法,抛出异常.<br>解决方式:使用 asm 对 jar 中进行指令分析, 对指令 invokestatic, invokevirtual , invokeinterface , invokedynamic ( android 上可以忽略这个指令)  和 getfield , getstatic 指令的分析. 我们可以生成一个空的实现的jar , 来为 javac 编译提供环境支持.</p><p>Q : 内部类的问题.<br>A: 匿名内部的生成的规则是 <code>外部类类名$Number</code>. Number 是在源码中出现的位置. 当你新增和调整位置的时候会导致生成的类和之前的类不匹配. 解决方式. 在对外部类操作的时候, 直接对匿名内部类进行删除. 等 javac 命令的生成新的内部类直接替换进去.</p><h1 id="0x05-改进"><a href="#0x05-改进" class="headerlink" title="0x05 改进"></a>0x05 改进</h1><p>通过和 idea  结合提供一整套的解决方案. </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;博客地址: &lt;a href=&quot;http://dim.red&quot;&gt;dim.red&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h1&gt;&lt;p&gt;分析最近的 Crash , 排在前列基本是第三方SDK导致. 遇到这样的问题, 我们需要寻求官方的支持, 但是官方的支持总是来得比较晚. 在Android上, 第三方SDK一般是两种, 一种是jar, 一种是so. so的修改成本过大, 我们放弃它, 我们现在探讨对 jar 的修改.&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>动态日志实践</title>
    <link href="http://dim.red/2018/05/03/dylog_exploration/"/>
    <id>http://dim.red/2018/05/03/dylog_exploration/</id>
    <published>2018-05-02T16:00:00.000Z</published>
    <updated>2018-08-25T08:43:17.012Z</updated>
    
    <content type="html"><![CDATA[<p>博客地址: <a href="http://dim.red">dim.red</a><br>项目开源: <a href="https://github.com/zzz40500/DynamicLog" target="_blank" rel="noopener">DynamicLog</a></p><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>当线上问题出现的时候. 往往需要之前的埋点进行问题定位. 但是埋点个数是有限的. 现有的埋点往往不够排查出具体的问题. 所以我们需要一个更灵活的埋点方案. 要求是可以动态的输出任何方法的入参和出参.<br><a id="more"></a></p><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>拦截原有的业务方法的入口和出口. </p><p>原本:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class O &#123;</span><br><span class="line">    private static final String TAG = &quot;O&quot;;</span><br><span class="line">    public int method1(int i) &#123;</span><br><span class="line">        Log.d(TAG, &quot;method1() called with: i = [&quot; + i + &quot;]&quot;);</span><br><span class="line">        return i * i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>处理后:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public class O &#123;</span><br><span class="line">    private static final String TAG = &quot;O&quot;;</span><br><span class="line">    public static volatile MethodMonitor s_Monitor_1;</span><br><span class="line"></span><br><span class="line">    public int method1(int i) &#123;</span><br><span class="line">        //方法开始</span><br><span class="line">        int methodId = 11;</span><br><span class="line">        Point point = null;</span><br><span class="line">        if (s_Monitor_1 != null &amp;&amp; s_Monitor_1.hotMethodEnter(methodId)) &#123;</span><br><span class="line">            point = new Point();</span><br><span class="line">            point.setThisObject(this);</span><br><span class="line">            Object[] var2 = new Object[0];</span><br><span class="line">            point.setArg(var2);</span><br><span class="line">            s_Monitor_1.methodEnter(point);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //原有方法执行</span><br><span class="line">        Log.d(TAG, &quot;method1() called with: i = [&quot; + i + &quot;]&quot;);</span><br><span class="line">        int result = i * i;</span><br><span class="line"></span><br><span class="line">        //方法结束</span><br><span class="line">        if (s_Monitor_1 != null &amp;&amp; s_Monitor_1.hotMethodReturn(0)) &#123;</span><br><span class="line">            if (point == null) &#123;</span><br><span class="line">                point = new Point();</span><br><span class="line">                point.setThisObject(this);</span><br><span class="line">                Object[] var3 = new Object[0];</span><br><span class="line">                point.setArg(var3);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            point.setReturnObject((Integer)result);</span><br><span class="line">            s_Monitor_1.methodReturn(point, methodId);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>做法:<br>为所有的 class 分配一个静态的 s_Monitor_1 对象. 同时为 class 下所有的方法分配一个独有的 methodId . 当 s_Monitor_1 对象不为空, methodId 匹配即命中规则.</p><h2 id="编译过程过程"><a href="#编译过程过程" class="headerlink" title="编译过程过程:"></a>编译过程过程:</h2><p><img src="https://upload-images.jianshu.io/upload_images/166866-11d08eb2dfad03aa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="编译过程"></p><h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h3><p>Monitor Plugin<br>在编译期间进行字节码注入. 同时生成 monitorMapping.txt 用来描述方法和 <code>methodId</code> 的映射关系.</p><p>注: 在字节码过程中我们发现有些方法是不需要注入的. 比如 abstract , 桥接方法 和 access$方法.</p><p>服务端可以通过 mapping.txt 找到混淆以后的类名,再通过 monitorMapping.txt 获取到 methodId 两则组合成命令往客户端发送.</p><h1 id="尾巴"><a href="#尾巴" class="headerlink" title="尾巴"></a>尾巴</h1><p>是用热修复的思想来做做动态日志.</p><h1 id="相关"><a href="#相关" class="headerlink" title="相关"></a>相关</h1><p><a href="https://tech.meituan.com/android_holmes.html" target="_blank" rel="noopener">美团点评 - Android动态日志系统Holmes</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;博客地址: &lt;a href=&quot;http://dim.red&quot;&gt;dim.red&lt;/a&gt;&lt;br&gt;项目开源: &lt;a href=&quot;https://github.com/zzz40500/DynamicLog&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;DynamicLog&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;当线上问题出现的时候. 往往需要之前的埋点进行问题定位. 但是埋点个数是有限的. 现有的埋点往往不够排查出具体的问题. 所以我们需要一个更灵活的埋点方案. 要求是可以动态的输出任何方法的入参和出参.&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>插件化方案对比</title>
    <link href="http://dim.red/2018/03/31/plugin_framework_%20exploration/"/>
    <id>http://dim.red/2018/03/31/plugin_framework_ exploration/</id>
    <published>2018-03-30T16:00:00.000Z</published>
    <updated>2018-08-25T08:43:17.076Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://dim.red">dim.red</a></p><h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>市面上的插件化，已经百花齐放，趋于完善。<br>主流的开源框架主要的代表有 Alibaba 的 Atlas , 360 的 Replugin 和 DIDI 的 VirtualAPK 。<br>实现插件化的技术难点</p><ul><li>代码的加载:</li><li>资源的加载</li><li>四大组件动态加载</li><li>配套的打包插件<a id="more"></a><h1 id="0x01-实现原理"><a href="#0x01-实现原理" class="headerlink" title="0x01 实现原理"></a>0x01 实现原理</h1><h2 id="1-代码加载"><a href="#1-代码加载" class="headerlink" title="1. 代码加载"></a>1. 代码加载</h2>主要分为两种：第一种是将所有的代码加载在同一个ClassLoader，第二种是插件使用自定义的 ClassLoder 分别加载插件代码。 Atlas 和 Replugin,VirtualAPK 使用的都是后者，使用后者的优势就是控制的粒度更细。<h2 id="2-资源的加载"><a href="#2-资源的加载" class="headerlink" title="2. 资源的加载"></a>2. 资源的加载</h2>资源的加载要先解决一个问题，就是资源ID 的重复。方案有两种：第一种是使用不同的 Resource 加载插件资源来避免资源ID重复，第二种方式是共用一个 Resource ，通过修改插件的 Resource 的 PP 段来避免资源ID重复。第一种方式编译就不需要过多的参与，修改 PP 段的方式有两种，一种是修改 aapt 的 C 代码 ， 生成自定义的aapt。还有一种是直接的对 arsc 进行解析，修改pp段，回写成新的arsc 。看起来更极客，但是难度也更大，需要对arsc 有很深的理解，以及在不同版本下的异同。在这几个框架中，Replugin 使用的是多个 Resource 的方案。 Atlas 使用的是自定义的 aapt ,。VirtualAPK 使用的 Small 方式操作arsc。Replugin对比其他两个方案有个缺点, 他没有公共资源的概念，比如你3个插件都使用了support 包，那它需要把 support 包的资源全部打进 3个插件中。</li></ul><h2 id="3-四大组件"><a href="#3-四大组件" class="headerlink" title="3.  四大组件:"></a>3.  四大组件:</h2><h4 id="3-1-VirtualAPK"><a href="#3-1-VirtualAPK" class="headerlink" title="3.1 VirtualAPK"></a>3.1 VirtualAPK</h4><p>VirtualAPK  使用的是是预埋的方式。<br>Activity 当启动 插件 Activity 的会在启动的时候被替换成占坑的 Activity，然后Hook ActivityThread 的 H 和 Instrumentation 类，在对应的回调中替换回插件的 Activity .。达到欺骗系统的效果。<br>BroadcastReceiver 是将所有的静态注册转成动态注册。<br>Service 是将所有的插件 service 转成代理的Service ，在Service 的onStartCommand 方法中，重新模拟了插件 service 的声明周期。<br>ContentProvider 是将所有的插件 ContentProvider 调用转成调用代理的ContentProvider , 然后将真实的 ContentProvider 信息放在Uri 中, 通过解析Uri 获取插件的真实的 ContentProvider 信息。</p><h4 id="3-2-Atlas"><a href="#3-2-Atlas" class="headerlink" title="3.2 Atlas"></a>3.2 Atlas</h4><p>Atlas 插件的四大组件是直接埋在宿主的 App 的 Manifest 中，通过监听 ClassLoader  的 findClass方法，当是插件的相关 Activity 或者 ContentProvider ，初始化好对应的插件，然后使用对应的插件 ClassLoader 加载，同时 Atlas 也支持动态添加的四大组件，该方式跟VirtualAPK 实现原理一致。</p><h4 id="3-2-RePlugin"><a href="#3-2-RePlugin" class="headerlink" title="3.2 RePlugin"></a>3.2 RePlugin</h4><p>RePlugin 使用的方式比较新颖，在启动的 Activity 时候替换成了合适的占坑的Activity ，同时记录占坑 Activity 和 真实 Activity 的映射关系，然后ClassLoader的 loadClass方法中，load 占坑 Activity 类的的时候，根据占坑组件跟真实组件的映射关系, 加载真实的组件. 这样的好处是，避免了过多的 Hook 系统组件。<br>BroadcastReceiver：同VirtualAPK<br>ContentProvider：同VirtualAPK<br>Service：是直接在UI线程调用了service 的相关生命周期的方法，同时启动一个Service 来提高service所在进程优先级。</p><h2 id="4-配套的打包插件"><a href="#4-配套的打包插件" class="headerlink" title="4.  配套的打包插件"></a>4.  配套的打包插件</h2><p>待续</p><h1 id="0x03-框架对比"><a href="#0x03-框架对比" class="headerlink" title="0x03 框架对比"></a>0x03 框架对比</h1><h2 id="1-VirtualAPK"><a href="#1-VirtualAPK" class="headerlink" title="1. VirtualAPK:"></a>1. VirtualAPK:</h2><p>优点</p><ul><li>整体代码偏少, 可以符合官方的 “轻量”. </li><li>扩增了android.jar 的api, 使 反射改为直接调用hide api</li></ul><p>缺陷</p><ul><li>ContentProvider 支持有问题, 不支持在主进程的ContentProvider</li><li>Activity 支持多进程, 只支持Launch Model</li><li>Service 的多进程只支持两个进程</li><li>BroadcastReceiver 不支持多进程</li><li>开发有感知, 使用CP 没有在代码实现的时候修改</li><li>代码实现不优雅, 开发感知明显</li><li>插件管理逻辑丢失, 需要手动管理. 每次使用插件都要自行加载</li><li>Hook 太多系统的API</li><li>不支持内嵌插件</li><li>不支持插件依赖</li></ul><h2 id="2-Atlas"><a href="#2-Atlas" class="headerlink" title="2. Atlas"></a>2. Atlas</h2><p>优点</p><ul><li>插件的四大组件是直接声明在宿主中. 所以四大组件多进程支持都是完整的.</li><li>代码实现比较优雅., </li><li>完整的插件管理逻辑</li><li>支持插件依赖</li></ul><p>缺陷</p><ul><li>宿主打包插件实现比较复杂，hook 了大量 Android Gradle Plugin 2.x 的代码。</li><li>Hook 太多系统的API</li></ul><h2 id="3-RePlugin"><a href="#3-RePlugin" class="headerlink" title="3. RePlugin"></a>3. RePlugin</h2><p>优点</p><ul><li>开发的感知少, 得益于编译时期的字节码修改</li><li>多进程支持完美, 和Activity 的 Launch Model</li><li>Hook 系统api 较少</li></ul><p>缺陷</p><ul><li>资源没法复用, 插件包过大</li><li>不支持插件依赖</li><li>需要一个 GuardService 进程，用于管理插件信息。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://dim.red&quot;&gt;dim.red&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h1&gt;&lt;p&gt;市面上的插件化，已经百花齐放，趋于完善。&lt;br&gt;主流的开源框架主要的代表有 Alibaba 的 Atlas , 360 的 Replugin 和 DIDI 的 VirtualAPK 。&lt;br&gt;实现插件化的技术难点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;代码的加载:&lt;/li&gt;
&lt;li&gt;资源的加载&lt;/li&gt;
&lt;li&gt;四大组件动态加载&lt;/li&gt;
&lt;li&gt;配套的打包插件
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>输出 Apk 所有的依赖</title>
    <link href="http://dim.red/2018/02/05/android_dependency_analyse_code/"/>
    <id>http://dim.red/2018/02/05/android_dependency_analyse_code/</id>
    <published>2018-02-04T16:00:00.000Z</published>
    <updated>2018-08-25T15:07:34.378Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://dim.red">dim.red</a>  </p><h1 id="一-作用"><a href="#一-作用" class="headerlink" title="一 作用"></a>一 作用</h1><p>因为 Gradle 的依赖发生冲突的时候, 会解决冲突, 默认是使用最高的版本, 但是也会因为 force 字段的关系选择较低的版本, 我们往往需要知道打到APK里面依赖的具体版本.</p><p>代码片段<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">project.getGradle().addBuildListener(new BuildListener() &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    void buildStarted(Gradle gradle) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    void settingsEvaluated(Settings settings) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    void projectsLoaded(Gradle gradle) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    void projectsEvaluated(Gradle gradle) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    void buildFinished(BuildResult result) &#123;</span><br><span class="line"></span><br><span class="line">        project.android.applicationVariants.each &#123; variant -&gt;</span><br><span class="line">            if (variant.getAssemble().state.executed) &#123;</span><br><span class="line">                if (this.gradle.gradleVersion &gt;= &quot;4.1&quot;) &#123;</span><br><span class="line">                    // android plugin 3.0 以上</span><br><span class="line">                    def runtime = project.configurations.create(&quot;d_analyse&quot; + variant.runtimeConfiguration.name);</span><br><span class="line">                    runtime.setCanBeConsumed(false);</span><br><span class="line">                    runtime.extendsFrom(variant.runtimeConfiguration);</span><br><span class="line">                    runtime.getAttributes().attribute(Attribute.of(&quot;artifactType&quot;, String.class), &quot;jar&quot;)</span><br><span class="line">                    variant.runtimeConfiguration.getAttributes().keySet().forEach(&#123;</span><br><span class="line">                        runtime.getAttributes().attribute(it, variant.runtimeConfiguration.getAttributes().getAttribute(it));</span><br><span class="line">                    &#125;)</span><br><span class="line">                    println(&quot;$&#123;variant.name&#125;  analyse&quot;)</span><br><span class="line">                    println(&quot;runtime dependency &quot;)</span><br><span class="line">                    println(&quot;------------------&quot;)</span><br><span class="line">                    runtime.resolvedConfiguration.resolvedArtifacts.forEach(&#123;</span><br><span class="line">                        def id = it.moduleVersion.id;</span><br><span class="line">                        println(id.group + &quot; &quot; + id.name + &quot; &quot; + id.version)</span><br><span class="line">                    &#125;)</span><br><span class="line">                    println(&quot;------------------\n &quot;)</span><br><span class="line">                    def packageC = project.configurations.create(&quot;d_analyse_&quot; + variant.compileConfiguration.name);</span><br><span class="line">                    packageC.setCanBeConsumed(false);</span><br><span class="line">                    packageC.extendsFrom(variant.compileConfiguration);</span><br><span class="line">                    packageC.getAttributes().attribute(Attribute.of(&quot;artifactType&quot;, String.class), &quot;jar&quot;)</span><br><span class="line">                    variant.compileConfiguration.getAttributes().keySet().forEach(&#123;</span><br><span class="line">                        packageC.getAttributes().attribute(it, variant.compileConfiguration.getAttributes().getAttribute(it));</span><br><span class="line">                    &#125;)</span><br><span class="line">                    println(&quot;package dependency &quot;)</span><br><span class="line">                    println(&quot;------------------&quot;)</span><br><span class="line">                    packageC.resolvedConfiguration.resolvedArtifacts.forEach(&#123;</span><br><span class="line">                        def id = it.moduleVersion.id;</span><br><span class="line">                        println(id.group + &quot; &quot; + id.name + &quot; &quot; + id.version)</span><br><span class="line">                    &#125;)</span><br><span class="line">                    println(&quot;------------------\n &quot;)</span><br><span class="line">                    println(&quot;\n &quot;)</span><br><span class="line"></span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    // android plugin 3.0  以下</span><br><span class="line">                    def appPlugin = project.plugins.findPlugin(&quot;com.android.application&quot;);</span><br><span class="line">                    appPlugin.variantManager.variantDataList.forEach(&#123;</span><br><span class="line">                        def variantDependencies = it.variantDependency;</span><br><span class="line"></span><br><span class="line">                        if (variant.name == variantDependencies.name) &#123;</span><br><span class="line">                            println(&quot;$&#123;variant.name&#125;  analyse&quot;)</span><br><span class="line">                            def runtime = project.configurations.create(&quot;d_analyse&quot; + variantDependencies.compileConfiguration.name);</span><br><span class="line">                            runtime.setCanBeConsumed(false)</span><br><span class="line">                            runtime.extendsFrom(variantDependencies.compileConfiguration);</span><br><span class="line">                            println(&quot;runtime dependency &quot;)</span><br><span class="line">                            println(&quot;------------------&quot;)</span><br><span class="line">                            runtime.resolvedConfiguration.resolvedArtifacts.forEach(&#123;</span><br><span class="line">                                def id = it.moduleVersion.id;</span><br><span class="line">                                println(id.group + &quot; &quot; + id.name + &quot; &quot; + id.version)</span><br><span class="line">                            &#125;)</span><br><span class="line">                            println(&quot;------------------\n &quot;)</span><br><span class="line"></span><br><span class="line">                            def packageC = project.configurations.create(&quot;d_analyse&quot; + variantDependencies.packageConfiguration.name);</span><br><span class="line">                            packageC.setCanBeConsumed(false)</span><br><span class="line">                            packageC.extendsFrom(variantDependencies.packageConfiguration);</span><br><span class="line">                            println(&quot;package dependency &quot;)</span><br><span class="line">                            println(&quot;------------------&quot;)</span><br><span class="line">                            packageC.resolvedConfiguration.resolvedArtifacts.forEach(&#123;</span><br><span class="line">                                def id = it.moduleVersion.id;</span><br><span class="line">                                println(id.group + &quot; &quot; + id.name + &quot; &quot; + id.version)</span><br><span class="line">                            &#125;)</span><br><span class="line">                            println(&quot;------------------\n &quot;)</span><br><span class="line">                            println(&quot;\n &quot;)</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                    &#125;)</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://dim.red&quot;&gt;dim.red&lt;/a&gt;  &lt;/p&gt;
&lt;h1 id=&quot;一-作用&quot;&gt;&lt;a href=&quot;#一-作用&quot; class=&quot;headerlink&quot; title=&quot;一 作用&quot;&gt;&lt;/a&gt;一 作用&lt;/h1&gt;&lt;p&gt;因为 Gradle 的依赖发生冲突的时候, 会解决冲突, 默认是使用最高的版本, 但是也会因为 force 字段的关系选择较低的版本, 我们往往需要知道打到APK里面依赖的具体版本.&lt;/p&gt;
&lt;p&gt;代码片段&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Gradle Transform 初探</title>
    <link href="http://dim.red/2018/01/25/gradle_transform_%20exploration/"/>
    <id>http://dim.red/2018/01/25/gradle_transform_ exploration/</id>
    <published>2018-01-24T16:00:00.000Z</published>
    <updated>2018-11-06T16:54:02.793Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://dim.red">dim.red</a><br>环境: gradle 4.1 ,  Android Plugin 2.3.0 ,  Android Plugin 3.0.0</p><p>#0x00 背景<br>去年的时候写个 <a href="http://dim.red/2017/04/05/android_plugin_transform_%20exploration/">Android Plugin Transform 初探</a> . 现在我们接着之前的脚步来学习 Gradle 下的 Transform . 同时熟悉一下 Android Plugin 在该规则下的应用.<br><a id="more"></a></p><p>#0x01 历史<br>Android Plugin 是在1.5.0-beta1 版本加入的.  1.5.0 的 Release 是在2015 年的 11 月.<br>Gradle 的 Transform api 是在 3.5 版本引入的. 3.5.0 的 Release 是在 2017 年的 4 月.<br>相似的命名, 相似的功能,<br>[^_^]: <img src="http://upload-images.jianshu.io/upload_images/166866-fe4983cf873b02d7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Android plugin 1.5.0 "><br><img src="http://upload-images.jianshu.io/upload_images/166866-a3240722fd4ae530.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Gradle 3.5 "></p><p>#0x02 使用<br>Gradle 中 Configuration 代表一组依赖关系.而 Transform 是作用在依赖的产物上, 将产物 A 根据一定规则转换成产物 B.<br>依赖的产物默认有一个属性<code>ArtifactAttributes.ARTIFACT_FORMAT</code>, 远程依赖默认为文件的后缀名. 本地依赖的情况比较复杂,具体看应用的插件. </p><p>先看一个比较全的应用 </p><p>Lib 工程提供 Configuration. 供主工程消费.  </p><h2 id="1-Lib-工程"><a href="#1-Lib-工程" class="headerlink" title="1 Lib 工程"></a>1 Lib 工程</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Configuration apLib = project.configurations.create(&quot;apLib&quot;);</span><br><span class="line">        apLib.setDescription(&quot;ap  elements &quot; );</span><br><span class="line">        // 能被其他 project 的消费</span><br><span class="line">        apLib.setCanBeConsumed(true);</span><br><span class="line">        // 设置当前的 Configuration 的属性. 供请求 Configuration 的属性匹配</span><br><span class="line">        apLib.getAttributes().attribute(Attribute.of(&quot;Type&quot;, String.class), &quot;ap&quot;)</span><br><span class="line">        // 声明一个variants apVar , 设置 apVar 属性为 ap, 同时为apVar 设置最终产物 /lib/demo.ap</span><br><span class="line">        apLib.getOutgoing().variants(new Action&lt;NamedDomainObjectContainer&lt;ConfigurationVariant&gt;&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            void execute(NamedDomainObjectContainer&lt;ConfigurationVariant&gt; configurationVariants) &#123;</span><br><span class="line"></span><br><span class="line">                configurationVariants.create(&quot;apVar&quot;, &#123; variant -&gt;</span><br><span class="line">                    variant.artifact(new File(&quot;/lib/demo.ap&quot;), &#123; artifact -&gt;</span><br><span class="line">                        artifact.setType(&quot;ap&quot;);</span><br><span class="line">                    &#125;)</span><br><span class="line">                    variant.getAttributes().attribute(Attribute.of(&quot;artifactType&quot;, String.class), &quot;ap&quot;)</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><p>这里声明了一个 apLib 的 Configuration  . 并且为这个apLib 设置了一些属性,这些属性将在后面查找提供作用, 同时为 apLib 设置它的产物 . 也可以为这个 artifact 设置依赖任务 (<code>artifact.builtBy(Task)</code>) , 解析的时候依赖任务是不会被强制执行的。什么时候被执行呢？ Configuration  可以被当一组 Task 被另外一个 Task 依赖 。 TaskA dependOn ConfigurationA. 当 TaskA 被执行之前所有的 ConfigurationA 的 Artifact 设置的依赖Task 会被执行。或者将 ConfigurationA 设置成 TaskA 的 @InputFlies，Gradle 在自动将 TaskA 依赖 ConfigurationA 。  </p><h2 id="2-主工程"><a href="#2-主工程" class="headerlink" title="2 主工程"></a>2 主工程</h2><p>定义一个 apC . 获取 apC 依赖上所有 ap 类型的文件.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Configuration apC = project.configurations.create(&quot;apC&quot;);</span><br><span class="line">//主动依赖 Lib 工程</span><br><span class="line">project.getDependencies().add(&quot;apC&quot;, project.project(&apos;:lib&apos;));</span><br><span class="line"></span><br><span class="line">//定义 apC 属性,  主要用来匹配 lib 生成的 apLib 的属性</span><br><span class="line">apC.getAttributes().attribute(Attribute.of(&quot;Type&quot;, String.class), &quot;ap&quot;)</span><br><span class="line">apC.getIncoming().artifactView(&#123;</span><br><span class="line">   config -&gt;</span><br><span class="line">         config.attributes &#123;</span><br><span class="line">            // 定义属性, 用于匹配 apLib apVar 的属性</span><br><span class="line">             container -&gt; container.attribute(Attribute.of(&quot;artifactType&quot;, String.class), &quot;ap&quot;)</span><br><span class="line">         &#125;</span><br><span class="line">&#125;).getArtifacts().getArtifactFiles().getFiles(); //  /lib/demo.ap</span><br></pre></td></tr></table></figure></p><p>数据流向:   根据 apC 的属性匹配到 lib 工程的 apLib 的属性. 根据 container 的属性匹配到了 apVar  的属性. 获取到产物.<br>属性的匹配默认是调用两个值的 equals 方法. 当然你可以自己定义一个匹配策略和一个解决匹配冲突的的策略.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AttributeMatchingStrategy attributeMatchingStrategy = project.getDependencies().getAttributesSchema().attribute(Attribute.of(&quot;artifactType&quot;, String.class)); // 获取规则</span><br><span class="line">attributeMatchingStrategy.compatibilityRules.add(TypeCompatibilityRules.class); // 定义新的匹配策</span><br><span class="line">attributeMatchingStrategy.disambiguationRules.add(TypeDisambiguationRules.class); // 定义解决冲突的策</span><br></pre></td></tr></table></figure></p><p>到这里. 我们还没有讲到 Transform 的应用. 属性匹配是 Transform 的基础. 当匹配不成功的时候, 会根据 Transform 定义的 <code>From</code> 和 <code>To</code> 尝试组成转化规则. 下面是一个简单的转换<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">DependencyHandler dependencies = project.getDependencies();</span><br><span class="line">        dependencies.registerTransform(&#123;</span><br><span class="line">            it.getFrom().attribute(ArtifactAttributes.ARTIFACT_FORMAT, &quot;ap&quot;);</span><br><span class="line">            it.getTo().attribute(Attribute.of(&quot;artifactType&quot;, String.class), &quot;ap-info&quot;);</span><br><span class="line">            it.artifactTransform(ApInfoTransform.class);</span><br><span class="line">        &#125;);</span><br><span class="line"> apC.getIncoming().artifactView(&#123;</span><br><span class="line">            config -&gt;</span><br><span class="line">                config.attributes &#123;</span><br><span class="line">                    container -&gt; container.attribute(Attribute.of(&quot;artifactType&quot;, String.class), &quot;ap-info&quot;)</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;).getArtifacts().getArtifactFiles().getFiles();</span><br></pre></td></tr></table></figure></p><p>定义了一个转换规则: 由 ap 转化成 ap-info .具体转换在 ApInfoTransform</p><p>数据的流向是: 根据 apC 的属性匹配到 lib 工程的 apLib 的属性.  container 的属性没有找到能够匹配的属性. 但是匹配到了 ApInfoTransform 的<code>To</code>, ApInfoTransform 的 From 匹配到了 apVar  的属性. 至此组成了一个转化规则, 由 apVar 获取到的产物,需经过 ApInfoTransform 转化后返回. </p><p>#0x03 Android Plugin 的应用</p><p>Android Plugin 正式使用 Gradle Transform 是在 3.0 上.  </p><h3 id="1-Android-Plugin-2-3-0-实现"><a href="#1-Android-Plugin-2-3-0-实现" class="headerlink" title="1. Android Plugin 2.3.0 实现"></a>1. Android Plugin 2.3.0 实现</h3><p><img src="http://upload-images.jianshu.io/upload_images/166866-d59cec6322fd8bbb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="2.3.0"></p><p>处理的是 AAR  </p><ol><li>AAR 的来源有两个: 一种是 AAR 依赖 通过网络下载或本地获取, 一种是 Android Library Module 通过 bundleXX 任务打包出来的 AAR.</li><li>Application Plugin 通过依赖关系收集所有的AAR, 再通过 PrepareLibraryTask 将所有 AAR 文件的解压, 用 AndroidDependency 来管理这些 AAR . 通过自己管理这些目录. 组织出不同的资源目录, 如 jar ,Jni,Aidl,Proguard …<h3 id="2-Android-Plugin-3-0-0-实现"><a href="#2-Android-Plugin-3-0-0-实现" class="headerlink" title="2. Android Plugin 3.0.0 实现"></a>2. Android Plugin 3.0.0 实现</h3><img src="http://upload-images.jianshu.io/upload_images/166866-ddf9f2221fb04c59.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3.0"><br>处理的是 attribute 产物<br>这里的 attribute 产物来源主要是两种,<br>一种是 AAR 依赖, 通过网络下载AAR, 通过 ExtractAarTransform 将  ARTIFACT_FORMAT 为 aar 转化成 android-exploded-aar 的产物. 再通过不不同的 AarTransform 将 ARTIFACT_FORMAT 为 android-exploded-aar 转化成不同的属性的产物.<br>一种是通过使用 Android Library Module . 通过往 Configuration 输出不同属性的产物.  </li></ol><h3 id="3-对比"><a href="#3-对比" class="headerlink" title="3. 对比:"></a>3. 对比:</h3><p>对比 2.3.0 来说 通过将 Transform 的功能将 AAR 文件的处理的时机和缓存全部移交给了 Gradle,<br>好处  </p><ol><li>Transform 的处理是只有一次, 可以节省多余重复的解压. </li><li>缓存是全局的. 所有的工程都能复用同一个缓存.  </li></ol><p>同时由于 Gradle 并没有对 AAR 依赖做特别的适配, 导致在2.3.0 上处理依赖的时候,需要对依赖进行二次管理,   Android Plugin 3.0.0 不需要这些额外的处理,只需要通过定义不同的 Transform 获取到对应的产物就好了. </p><h1 id="0x03-Android-Plugin-Transform-和-Gradle-Transform"><a href="#0x03-Android-Plugin-Transform-和-Gradle-Transform" class="headerlink" title="0x03 Android Plugin Transform 和 Gradle Transform"></a>0x03 Android Plugin Transform 和 Gradle Transform</h1><ul><li>维度不同<br>Android Plugin Transform 有两个维度一个是 ContentType ,一个是 Scope,  一个产物只有一个ContentType 和 Scope , Gradle 维度是 Attribute ,一个产物有多个 Attribute. </li><li>扩展能力不同<br>Android Plugin Transform 不支持自定义 ContentType , Gradle 支持自定义 Attribute . </li><li>缓存不同<br>Android Plugin Transform 将结果记录是在一个大的文件目录下, 通过不同的文件名称来表示不同 Scope 下的 ContentType.<br>Gradle Transform 是将 Transform 输出的结果记录在 Gradle 的文件缓存中,<br>由于记录的方式不同, 导致的结果是 Android plugin Transform 的一个输入对应一个输出,即使你并不对输入做任何操作, 也需要将输入的文件 copy 到输出的文件夹下.才能被下一个 Transform 正确识别. 而 Gradle Transform 不同, 记录是结果, 你完全可以不对输出目录做任何的事情, 直接将原有的输出地址返回回去. </li><li>缓存范围不同<br>Android Plugin Transform 缓存是 Application 级别的. 在 build/intermediates/transforms/目录下以transforms名称命名的.<br>Gradle Transform 是全局的, 在.gradle/caches/transforms-1/files-1.1/下, 文件名称是由所有关键信息进行 hash 算出来的. </li><li>应用不同<br>Gradle Transform 应用的是依赖的产物。 将产物A 转化成 产物B, 不支持同属性的转化.<br>Android  Plugin Transform 应用的是打包过程中的产物如 so, classs, res,dex。 这些信息大部分是由依赖产物加工而来的。支持相同ContentType 的转化. </li></ul><h1 id="0x04-总结"><a href="#0x04-总结" class="headerlink" title="0x04 总结"></a>0x04 总结</h1><p>通过上述的对比, 我们可以知道 两个 Transform 应用在不同场景, Gradle Transform  是对依赖进行处理. 这种处理是全局性的.而 Android  Plugin Transform 是对打包过程中中间产物的再处理, 是针对 Application 的. </p><h2 id="0x05-尾巴"><a href="#0x05-尾巴" class="headerlink" title="0x05 尾巴"></a>0x05 尾巴</h2><p>这一块的代码看蛮久的, 因为涉及的代码比较多, 面比较广, 需要有一个比较好的耐心和比较久的时间. 通过这一块的梳理, 对 Android plugin 3.0 和 Gradle 4.1 的依赖的管理有更好的理解.  </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://dim.red&quot;&gt;dim.red&lt;/a&gt;&lt;br&gt;环境: gradle 4.1 ,  Android Plugin 2.3.0 ,  Android Plugin 3.0.0&lt;/p&gt;
&lt;p&gt;#0x00 背景&lt;br&gt;去年的时候写个 &lt;a href=&quot;http://dim.red/2017/04/05/android_plugin_transform_%20exploration/&quot;&gt;Android Plugin Transform 初探&lt;/a&gt; . 现在我们接着之前的脚步来学习 Gradle 下的 Transform . 同时熟悉一下 Android Plugin 在该规则下的应用.&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Android 脚本自动化 SDK 原理 • View Hierarchy 的获取</title>
    <link href="http://dim.red/2017/12/24/sasuke_sdk_view_hierarchy/"/>
    <id>http://dim.red/2017/12/24/sasuke_sdk_view_hierarchy/</id>
    <published>2017-12-23T16:00:00.000Z</published>
    <updated>2018-08-25T08:43:17.120Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://dim.red">dim.red</a></p><h1 id="View-Hierarchy"><a href="#View-Hierarchy" class="headerlink" title="View Hierarchy"></a>View Hierarchy</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在脚本录制回放过程中, 我们需要获取 View Hierarchy 的意图有三个.</p><ul><li>将  View Hierarchy  结合 App 截图 发送给前端. 前端用这两个做可视化显示.</li><li>在录制中.需要获取  View Hierarchy   遍历控件, 对控件进行监听.</li><li>在回放中. 需要根据  View Hierarchy  找到 回放操作 对应的控件.<a id="more"></a></li></ul><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><p><img src="http://upload-images.jianshu.io/upload_images/166866-893ca5a585c7e7d9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="实例1"></p><h3 id="方式一-activity-onResume"><a href="#方式一-activity-onResume" class="headerlink" title="方式一: activity onResume"></a>方式一: activity onResume</h3><p>原理: ContentView 在 Activity 的onResume 里添加到屏幕上.<br>优点: 实现简单<br>缺点: 获取的视图不全面. 类似Dialog , PopWindow<br>在 实例1 中只能获取 Activity 层级, 领圣诞礼卷的对话框就获取不到了.</p><h3 id="方式二-hook-LayoutInflater"><a href="#方式二-hook-LayoutInflater" class="headerlink" title="方式二: hook LayoutInflater"></a>方式二: hook LayoutInflater</h3><p>原理: res 的 layout  资源通过 LayoutInflater 解析成 View.<br>优点: 覆盖了所有从layout资源里面加载的控件<br>缺点: 系统兼容性问题, 能兼容 90% 以上的情况. </p><h3 id="方式三-hook-WindowManager"><a href="#方式三-hook-WindowManager" class="headerlink" title="方式三: hook WindowManager"></a>方式三: hook WindowManager</h3><p>原理: 一个View 要显示在屏幕上, 都需要调用 WindowManager.add(XX) 方法.<br>优点: 覆盖了所有情况<br>缺点: 系统兼容性问题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">        Class&lt;?&gt; windowManagerGlobal = Class.forName(&quot;android.view.WindowManagerGlobal&quot;);</span><br><span class="line">        Object windowManagerGlobalInstance = on(windowManagerGlobal).call(&quot;getInstance&quot;).get();</span><br><span class="line">        Object mViewsObject = on(windowManagerGlobalInstance).field(&quot;mViews&quot;).get();</span><br><span class="line">        Object mParamsObject = on(windowManagerGlobalInstance).field(&quot;mParams&quot;).get();</span><br><span class="line">        ArrayList&lt;View&gt; mViews = (ArrayList&lt;View&gt;) mViewsObject;</span><br><span class="line">        ArrayList&lt;WindowManager.LayoutParams&gt; mParams = (ArrayList&lt;WindowManager.LayoutParams&gt;) mParamsObject;</span><br><span class="line">        ObserverArrayList&lt;View&gt; observerArrayList = createViews();</span><br><span class="line">        ObserverArrayList&lt;WindowManager.LayoutParams&gt; paramsObserverArrayList = createParams();</span><br><span class="line">        observerArrayList.addAll(mViews);</span><br><span class="line">        paramsObserverArrayList.addAll(mParams);</span><br><span class="line">        on(windowManagerGlobalInstance).set(&quot;mViews&quot;, observerArrayList);</span><br><span class="line">        on(windowManagerGlobalInstance).set(&quot;mParams&quot;, paramsObserverArrayList);</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://dim.red&quot;&gt;dim.red&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;View-Hierarchy&quot;&gt;&lt;a href=&quot;#View-Hierarchy&quot; class=&quot;headerlink&quot; title=&quot;View Hierarchy&quot;&gt;&lt;/a&gt;View Hierarchy&lt;/h1&gt;&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;在脚本录制回放过程中, 我们需要获取 View Hierarchy 的意图有三个.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将  View Hierarchy  结合 App 截图 发送给前端. 前端用这两个做可视化显示.&lt;/li&gt;
&lt;li&gt;在录制中.需要获取  View Hierarchy   遍历控件, 对控件进行监听.&lt;/li&gt;
&lt;li&gt;在回放中. 需要根据  View Hierarchy  找到 回放操作 对应的控件.
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Android 脚本自动化 SDK 原理</title>
    <link href="http://dim.red/2017/12/23/sasuke_sdk/"/>
    <id>http://dim.red/2017/12/23/sasuke_sdk/</id>
    <published>2017-12-22T16:00:00.000Z</published>
    <updated>2018-08-25T15:11:43.267Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://dim.red">dim.red</a><br><a id="more"></a></p><h1 id="一-录制"><a href="#一-录制" class="headerlink" title="一. 录制"></a>一. 录制</h1><ul><li><a href="https://www.jianshu.com/p/3a7c189d13f9" target="_blank" rel="noopener">View Hierarchy 的获取</a></li><li>事件录制</li><li>Xpath 优化 </li></ul><h1 id="二-回放"><a href="#二-回放" class="headerlink" title="二. 回放"></a>二. 回放</h1><ul><li>控件的寻找</li><li>事件回放</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://dim.red&quot;&gt;dim.red&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>小技巧︰ 动态代理 巧用</title>
    <link href="http://dim.red/2017/12/16/inovel_dynamic_proxy/"/>
    <id>http://dim.red/2017/12/16/inovel_dynamic_proxy/</id>
    <published>2017-12-15T16:00:00.000Z</published>
    <updated>2018-08-25T08:43:17.067Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://dim.red">dim.red</a></p><p>#背景<br>android 的中设置监听有两种. </p><ul><li>一种 setOnXXListener (eg View.setOncClickListener()) .</li><li>一种 addOnXXXListener (TextView.addTextWatchListener());<br>两种的区别是第一种内部只会保存一个listener, 每次调用就是覆盖.<br>第二种内部会保存一个List, 每次调用的时候就是添加一个监听器.<a id="more"></a></li></ul><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public interface OnStatusListener &#123;</span><br><span class="line">    void onChange();</span><br><span class="line">    void onChange1();</span><br><span class="line">    void onChange2();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="优化前"><a href="#优化前" class="headerlink" title="优化前"></a>优化前</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class StastusManager &#123;</span><br><span class="line"></span><br><span class="line">    private List&lt;OnStatusListener&gt; onStatusListeners = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public void addOnStastusListener(OnStatusListener onStatusListener) &#123;</span><br><span class="line">        onStatusListeners.add(onStatusListener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void removeOnStatusListener(OnStatusListener onStatusListener) &#123;</span><br><span class="line">        onStatusListeners.remove(onStatusListener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void onChange() &#123;</span><br><span class="line">        for (OnStatusListener onStatusListener : onStatusListeners) &#123;</span><br><span class="line">            onStatusListener.onChange();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public void onChange1() &#123;</span><br><span class="line">        for (OnStatusListener onStatusListener : onStatusListeners) &#123;</span><br><span class="line">            onStatusListener.onChange1();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public void onChange2() &#123;</span><br><span class="line">        for (OnStatusListener onStatusListener : onStatusListeners) &#123;</span><br><span class="line">            onStatusListener.onChange2();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当接口方法多了以后, 相似代码就变更多了.<br>我们使用动态代理 优化一下相似代码  </p><h2 id="优化后"><a href="#优化后" class="headerlink" title="优化后"></a>优化后</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class StastusManager &#123;</span><br><span class="line"></span><br><span class="line">    private DynamicInterface&lt;OnStatusListener&gt; onStatusListeners = DynamicFactory.newObject(OnStatusListener.class);</span><br><span class="line"></span><br><span class="line">    public void addOnStastusListener(OnStatusListener onStatusListener) &#123;</span><br><span class="line">        onStatusListeners.addT(onStatusListener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void removeOnStatusListener(OnStatusListener onStatusListener) &#123;</span><br><span class="line">        onStatusListeners.removeT(onStatusListener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void onChange() &#123;</span><br><span class="line">        onStatusListeners.castT().onChange();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void onChange1() &#123;</span><br><span class="line">        onStatusListeners.castT().onChange1();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void onChange2() &#123;</span><br><span class="line">        onStatusListeners.castT().onChange2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优化以后没有了 List 类和每次的 for 循环. 现在还不能感觉到这个方式的好处. 当你有大量的 addXXlistener 你会发现, 比起之前的方式. 这种更加的优雅.<br>下面是实现的关键代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Created by dim on 2017/12/16.</span><br><span class="line"> */</span><br><span class="line">@Keep</span><br><span class="line">public interface DynamicInterface&lt;T extends Object&gt; &#123;</span><br><span class="line"></span><br><span class="line">    void addT(T t);</span><br><span class="line"></span><br><span class="line">    void removeT(T t);</span><br><span class="line"></span><br><span class="line">    T castT();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Created by dim on 2017/12/16.</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">public class DynamicFactory &#123;</span><br><span class="line"></span><br><span class="line">    public static &lt;T&gt; DynamicInterface&lt;T&gt; newObject(final Class&lt;T&gt; cls) &#123;</span><br><span class="line"></span><br><span class="line">        if (!cls.isInterface()) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;API declarations must be interfaces.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (cls.getInterfaces().length &gt; 0) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;API interfaces must not extend other interfaces.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return (DynamicInterface&lt;T&gt;) Proxy.newProxyInstance(cls.getClassLoader(),</span><br><span class="line">                new Class&lt;?&gt;[]&#123;cls, DynamicInterface.class&#125;, new InvocationHandler() &#123;</span><br><span class="line">                    private List&lt;T&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">                    @Override</span><br><span class="line">                    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line"></span><br><span class="line">                        if (method.getName().equals(&quot;addT&quot;) || method.getName().equals(&quot;removeT&quot;)) &#123;</span><br><span class="line">                            if (args != null &amp;&amp; args.length == 1 &amp;&amp; cls.isInstance(args[0])) &#123;</span><br><span class="line">                                if (method.getName().equals(&quot;addT&quot;)) &#123;</span><br><span class="line">                                    list.add((T) args[0]);</span><br><span class="line">                                &#125; else if (method.getName().equals(&quot;removeT&quot;)) &#123;</span><br><span class="line">                                    list.remove((T) args[0]);</span><br><span class="line">                                &#125;</span><br><span class="line">                                return null;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        if (method.getName().equals(&quot;castT&quot;) &amp;&amp; args == null) &#123;</span><br><span class="line">                            return proxy;</span><br><span class="line">                        &#125;</span><br><span class="line">                        Class&lt;?&gt; returnType = method.getReturnType();</span><br><span class="line">                        if (returnType.isAssignableFrom(boolean.class)) &#123;</span><br><span class="line"></span><br><span class="line">                            boolean object = true;</span><br><span class="line">                            for (T t : list) &#123;</span><br><span class="line">                                if (!(boolean) method.invoke(t, args)) &#123;</span><br><span class="line">                                    object = false;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                            return object;</span><br><span class="line">                        &#125; else if (returnType.isAssignableFrom(Boolean.class)) &#123;</span><br><span class="line">                            Boolean object = Boolean.TRUE;</span><br><span class="line">                            Boolean temp;</span><br><span class="line">                            for (T t : list) &#123;</span><br><span class="line">                                if ((temp = (Boolean) method.invoke(t, args)) != null &amp;&amp; !temp) &#123;</span><br><span class="line">                                    object = Boolean.FALSE;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                            return object;</span><br><span class="line">                        &#125; else if (returnType.isAssignableFrom(Void.class) || returnType.isAssignableFrom(void.class)) &#123;</span><br><span class="line">                            for (T t : list) &#123;</span><br><span class="line">                                method.invoke(t, args);</span><br><span class="line">                            &#125;</span><br><span class="line">                            return null;</span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">                            throw new IllegalArgumentException(&quot;returnType must boolean Boolean Void void&quot;);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://dim.red&quot;&gt;dim.red&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;#背景&lt;br&gt;android 的中设置监听有两种. &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一种 setOnXXListener (eg View.setOncClickListener()) .&lt;/li&gt;
&lt;li&gt;一种 addOnXXXListener (TextView.addTextWatchListener());&lt;br&gt;两种的区别是第一种内部只会保存一个listener, 每次调用就是覆盖.&lt;br&gt;第二种内部会保存一个List, 每次调用的时候就是添加一个监听器.
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>借助微信 构建 Android Project 编译通知</title>
    <link href="http://dim.red/2017/12/14/wechat_notify_system/"/>
    <id>http://dim.red/2017/12/14/wechat_notify_system/</id>
    <published>2017-12-13T16:00:00.000Z</published>
    <updated>2018-08-25T11:00:15.143Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://dim.red">dim.red</a>  </p><h1 id="一-背景"><a href="#一-背景" class="headerlink" title="一 背景"></a>一 背景</h1><p> 最近萌生一个想法, 在项目编译成功的时候给自己发送一条微信.</p><p><img src="http://upload-images.jianshu.io/upload_images/166866-cdd29a90b64b6e43.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="效果图.png"><br><a id="more"></a></p><h1 id="二-原理"><a href="#二-原理" class="headerlink" title="二 原理"></a>二 原理</h1><p>我们需要跟微信进行交互 , 为了达到这个效果 . 我们在 微信 App 内开启一个 Http 服务. 当项目编译完成以后发起一个 Http 请求.  Http 服务响应这个请求. 将获取的数据转发发送给自己 . </p><h1 id="三-实现"><a href="#三-实现" class="headerlink" title="三 实现"></a>三 实现</h1><h2 id="1-Http-服务"><a href="#1-Http-服务" class="headerlink" title="1 Http 服务."></a>1 Http 服务.</h2><p> 我们在 <strong><a href="https://github.com/TKkk-iOSer/WeChatPlugin-MacOS" target="_blank" rel="noopener">WeChatPlugin-MacOS</a></strong> 的基础上做扩展 . 同时使用第三方库 GCDWebServer 进行快速的搭建 Http服务 .</p><h3 id="1-1-添加-GCDWebServer-依赖"><a href="#1-1-添加-GCDWebServer-依赖" class="headerlink" title="1.1 添加 GCDWebServer 依赖"></a>1.1 添加 GCDWebServer 依赖</h3><p>将原有的 [WeChatPlugin-MacOS] 项目 转换成 cocoapods 管理 .<br>将 GCDWebServer 添加到 Podfile<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">platform :osx, &apos;10.10&apos;</span><br><span class="line">inhibit_all_warnings!</span><br><span class="line"></span><br><span class="line">target &apos;WeChatPlugin&apos; do</span><br><span class="line">  pod &apos;GCDWebServer&apos;</span><br><span class="line">end</span><br></pre></td></tr></table></figure></p><h3 id="1-2-开启-Http-服务"><a href="#1-2-开启-Http-服务" class="headerlink" title="1.2 开启 Http 服务"></a>1.2 开启 Http 服务</h3><p>WeChatPlugin/sources/Category/WeChat+hook.h<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;GCDWebServer/GCDWebServer.h&gt;</span><br><span class="line">#import &lt;GCDWebServer/GCDWebServerDataResponse.h&gt;</span><br></pre></td></tr></table></figure></p><p>WeChatPlugin/sources/Category/WeChat+hook.m<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">static GCDWebServer *server;</span><br><span class="line">+ (void)setup &#123;</span><br><span class="line">   </span><br><span class="line">    server = [[GCDWebServer alloc] init];       </span><br><span class="line">    [server addHandlerForMethod:@&quot;GET&quot; path:@&quot;/wechat/notify&quot; requestClass:[GCDWebServerRequest class] processBlock:^GCDWebServerResponse * _Nullable(__kindof GCDWebServerRequest * _Nonnull request) &#123;</span><br><span class="line">        NSString *msg = [request.query[@&quot;msg&quot;] lowercaseString] ? : @&quot;&quot;;</span><br><span class="line">        NSString *currentUserName = [objc_getClass(&quot;CUtility&quot;) GetCurrentUserName];</span><br><span class="line">        MessageService *service = [[objc_getClass(&quot;MMServiceCenter&quot;) defaultCenter] getService:objc_getClass(&quot;MessageService&quot;)];</span><br><span class="line">        [service SendTextMessage:currentUserName toUsrName:currentUserName msgText:msg atUserList:nil];</span><br><span class="line">        return [GCDWebServerDataResponse responseWithJSONObject:@&#123;@&quot;success&quot;:@&quot;true&quot;&#125;];</span><br><span class="line">    &#125;];</span><br><span class="line"> </span><br><span class="line">    [server startWithOptions:@&#123;GCDWebServerOption_Port: @(9090),</span><br><span class="line">                                    GCDWebServerOption_BindToLocalhost: @(YES)&#125; error:nil];</span><br><span class="line">    ...</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><h2 id="2-发送-Http-请求"><a href="#2-发送-Http-请求" class="headerlink" title="2 发送 Http 请求"></a>2 发送 Http 请求</h2><h3 id="2-1-设置监听器"><a href="#2-1-设置监听器" class="headerlink" title="2.1 设置监听器"></a>2.1 设置监听器</h3><p>在 <code>/Users/{username}/.gradle</code> 下建立一个文件 <code>init.gradle</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">allprojects &#123;</span><br><span class="line"></span><br><span class="line">    if (project.getProperties().get(&quot;notiy&quot;, false)) &#123;</span><br><span class="line">        project.pluginManager.withPlugin(&quot;com.android.application&quot;, &#123;</span><br><span class="line">            def pj = project;</span><br><span class="line">            def projectName = project.rootProject.name + &quot;:&quot; + pj.name;</span><br><span class="line">            def clock = new org.gradle.internal.time.Clock()</span><br><span class="line">            pj.getGradle().addBuildListener(new BuildListener() &#123;</span><br><span class="line"></span><br><span class="line">                @Override</span><br><span class="line">                void buildStarted(Gradle gradle) &#123;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                @Override</span><br><span class="line">                void settingsEvaluated(Settings settings) &#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                @Override</span><br><span class="line">                void projectsLoaded(Gradle gradle) &#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                @Override</span><br><span class="line">                void projectsEvaluated(Gradle gradle) &#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                @Override</span><br><span class="line">                void buildFinished(BuildResult result) &#123;</span><br><span class="line"></span><br><span class="line">                    boolean isAssembleTask = false</span><br><span class="line">                    pj.android.applicationVariants.each &#123; variant -&gt;</span><br><span class="line">                        if (variant.getAssemble().state.executed) &#123;</span><br><span class="line">                            isAssembleTask = true</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    def sp = pj.gradle.startParameter</span><br><span class="line">                    def t = sp.taskNames[0] as String</span><br><span class="line"></span><br><span class="line">                    NameMatcher nameMatcher = new NameMatcher()</span><br><span class="line">                    def taskName = nameMatcher.find(t, pj.tasks.asMap.keySet());</span><br><span class="line">                    taskName = taskName == null ? t : taskName;</span><br><span class="line"></span><br><span class="line">                    if (isAssembleTask || (result.failure != null &amp;&amp; (taskName.startsWith(&quot;assemble&quot;) || taskName.startsWith(&quot;install&quot;)))) &#123;</span><br><span class="line">                        String msg;</span><br><span class="line">                        if (result.failure == null) &#123;</span><br><span class="line">                            msg = &quot;项目 : $&#123;projectName&#125; \n任务 : $&#123;taskName&#125; \n编译 : 成功\n&quot; +</span><br><span class="line">                                    &quot;耗时 : $&#123;clock.elapsed&#125;&quot;</span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">                            msg = &quot;项目 : $&#123;projectName&#125; \n任务 : $&#123;taskName&#125; \n编译 : 失败\n&quot; +</span><br><span class="line">                                    &quot;错误 : $&#123;result.failure.getMessage()&#125;\n&quot; +</span><br><span class="line">                                    &quot;耗时 : $&#123;clock.elapsed&#125;&quot;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        (&quot;curl -X GET   http://localhost:9090/wechat/notify?msg=&quot; +</span><br><span class="line">                                URLEncoder.encode(msg, &quot;UTF-8&quot;)).execute()</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line"></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里在 gradle init 的时候加入监听 , 监听所有 android 项目的编译 ,  判断编译命令中是否包含参数 notiy , 并且 notity 为 true , 如果判断成功当编译完成 , 使用 curl 将编译结果发送 Http 服务 .  </p><h3 id="2-2-命令行使用"><a href="#2-2-命令行使用" class="headerlink" title="2.2 命令行使用"></a>2.2 命令行使用</h3><p>在原有的编译命令添加额外参数 <code>-P notiy=true</code><br>eg:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./gradlew assembleDebug -P notiy=true</span><br></pre></td></tr></table></figure></p><h3 id="2-3-优化"><a href="#2-3-优化" class="headerlink" title="2.3 优化"></a>2.3 优化</h3><p>为了优化体验.我们可以将参数设置成默认.<br>因为 Android 项目的编译触发有两种方式: 命令行 和 idea . 这里的优化也分为两种情况,<br>情况一 : 命令行<br>修改 gradlew 文件末端 , 添加 <code>&quot;-P&quot; &quot;notiy=true&quot;</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exec &quot;$JAVACMD&quot; &quot;$&#123;JVM_OPTS[@]&#125;&quot; -classpath &quot;$CLASSPATH&quot; org.gradle.wrapper.GradleWrapperMain &quot;$@&quot; &quot;-P&quot; &quot;notiy=true&quot;</span><br></pre></td></tr></table></figure></p><p>情况二 : Idea<br>配置添加 <code>-P notiy=true</code><br><img src="http://upload-images.jianshu.io/upload_images/166866-cefbcf8ca5ccc88d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://dim.red&quot;&gt;dim.red&lt;/a&gt;  &lt;/p&gt;
&lt;h1 id=&quot;一-背景&quot;&gt;&lt;a href=&quot;#一-背景&quot; class=&quot;headerlink&quot; title=&quot;一 背景&quot;&gt;&lt;/a&gt;一 背景&lt;/h1&gt;&lt;p&gt; 最近萌生一个想法, 在项目编译成功的时候给自己发送一条微信.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/166866-cdd29a90b64b6e43.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;效果图.png&quot;&gt;&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>使用 AOP 来为第三方 SDK 打 CALL</title>
    <link href="http://dim.red/2017/12/04/aop/"/>
    <id>http://dim.red/2017/12/04/aop/</id>
    <published>2017-12-03T16:00:00.000Z</published>
    <updated>2018-08-25T08:43:16.992Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://dim.red">dim.red</a></p><h1 id="一-背景"><a href="#一-背景" class="headerlink" title="一 背景"></a>一 背景</h1><p>android 的版本的更替往往需要开发者进行跟进.</p><p>Notification 在Android 8.0 上需要做一些兼容的工作.<a href="https://developer.android.com/guide/topics/ui/notifiers/notifications.html" target="_blank" rel="noopener">官方指导文档</a><br><a id="more"></a></p><h2 id="二-适配"><a href="#二-适配" class="headerlink" title="二 适配"></a>二 适配</h2><p>适配工作分为两步</p><h3 id="1-根据一个channelId-生成NotificationChannel-作为推送通道"><a href="#1-根据一个channelId-生成NotificationChannel-作为推送通道" class="headerlink" title="1 根据一个channelId 生成NotificationChannel 作为推送通道"></a>1 根据一个channelId 生成NotificationChannel 作为推送通道</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public static void init(Context ctx) &#123;</span><br><span class="line">       if (SDK_INT &gt;= 26) &#123;</span><br><span class="line">           String channelId = &quot;dim&quot;;</span><br><span class="line">           NotificationManager manager = (NotificationManager) Application.getApplicationContext().getSystemService(Context.NOTIFICATION_SERVICE);</span><br><span class="line">           if (manager != null) &#123;</span><br><span class="line">               NotificationChannel taco = manager.getNotificationChannel(channelId);</span><br><span class="line">               if (taco == null) &#123;</span><br><span class="line">                   int importance = NotificationManager.IMPORTANCE_HIGH;</span><br><span class="line">                   NotificationChannel channel = new NotificationChannel(channelId, channelId, importance);</span><br><span class="line">                   channel.setDescription(TACO_CHANNEL);</span><br><span class="line">                   manager.createNotificationChannel(channel);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="2-所有的通知需要设置-channelId"><a href="#2-所有的通知需要设置-channelId" class="headerlink" title="2 所有的通知需要设置 channelId:"></a>2 所有的通知需要设置 channelId:</h3><p>设置的方式:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new Notification.Builder(ctx).setChannelId(channelId);</span><br></pre></td></tr></table></figure></p><p>到此兼容的工作算是完成了.<br>但是这里的兼容只是局限在我们自己的业务代码.</p><h2 id="三-业务外的代码怎么办呢"><a href="#三-业务外的代码怎么办呢" class="headerlink" title="三. 业务外的代码怎么办呢?"></a>三. 业务外的代码怎么办呢?</h2><p>比如说在个推的GetuiSDK2.10.3.5 并没有对 Notification 做相关的处理.</p><p>Q: 怎么办?<br>A: 使用 AOP 为第三方 SDK 修BUG , 适配新特性 . </p><p> AOP 的实现有很多方式,这里我们会讲3种方式来实现这个效果.</p><h4 id="一-使用-lancet-饿了么开源的-AOP-框架"><a href="#一-使用-lancet-饿了么开源的-AOP-框架" class="headerlink" title="一. 使用 lancet  ( 饿了么开源的 AOP 框架 )"></a>一. 使用 <a href="https://github.com/eleme/lancet" target="_blank" rel="noopener">lancet</a>  ( 饿了么开源的 AOP 框架 )</h4><p>引入:<a href="https://github.com/eleme/lancet" target="_blank" rel="noopener">https://github.com/eleme/lancet</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public class NotifactionFix &#123;</span><br><span class="line"></span><br><span class="line">     public static final String CHANNEL = &quot;dim&quot;;</span><br><span class="line"></span><br><span class="line">    @Proxy(&quot;notify&quot;)</span><br><span class="line">    @TargetClass(&quot;android.app.NotificationManager&quot;)</span><br><span class="line">    public void notify(int id, Notification notification) &#123;</span><br><span class="line">        if (SDK_INT &gt;= 26) &#123;</span><br><span class="line">            maybeSetChannelId(notification);</span><br><span class="line">        &#125;</span><br><span class="line">        Origin.callVoid();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Proxy(&quot;notify&quot;)</span><br><span class="line">    @TargetClass(&quot;android.app.NotificationManager&quot;)</span><br><span class="line">    public void notify(String tag, int id, Notification notification) &#123;</span><br><span class="line">        maybeSetChannelId(notification);</span><br><span class="line">        Origin.callVoid();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   public static void maybeSetChannelId(Notification notification) &#123;</span><br><span class="line">        if (SDK_INT &gt;= 26) &#123;</span><br><span class="line">            if (TextUtils.isEmpty(notification.getChannelId())) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    Field mChannelId = Notification.class.getDeclaredField(&quot;mChannelId&quot;);</span><br><span class="line">                    mChannelId.setAccessible(true);</span><br><span class="line">                    mChannelId.set(notification,CHANNEL);</span><br><span class="line">                &#125; catch (NoSuchFieldException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; catch (IllegalAccessException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="二-使用-aspectjX"><a href="#二-使用-aspectjX" class="headerlink" title="二 使用 aspectjX"></a>二 使用 <a href="https://github.com/HujiangTechnology/gradle_plugin_android_aspectjx" target="_blank" rel="noopener">aspectjX</a></h4><p>引入 :<a href="https://github.com/HujiangTechnology/gradle_plugin_android_aspectjx" target="_blank" rel="noopener">https://github.com/HujiangTechnology/gradle_plugin_android_aspectjx</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">@Aspect</span><br><span class="line">public class NotificationFix &#123;</span><br><span class="line"></span><br><span class="line">    public static final String CHANNEL = &quot;dim&quot;;</span><br><span class="line"></span><br><span class="line">    private static NotificationFix sNotificationFix = new NotificationFix();</span><br><span class="line"></span><br><span class="line">    public static NotificationFix aspectOf() &#123;</span><br><span class="line">        return sNotificationFix;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Pointcut(&quot;call(public void android.app.NotificationManager.notify(..))&quot;)</span><br><span class="line">    void notificationManager_notifyMethod() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Before(&quot;notificationManager_notifyMethod()&quot;)</span><br><span class="line">    public void hookNotificationManager_notifyMethod(JoinPoint joinPoint) &#123;</span><br><span class="line">        Log.e(&quot;dim&quot;, &quot;hookNotificationManager_notifyMethod: &quot;);</span><br><span class="line">        for (Object arg : joinPoint.getArgs()) &#123;</span><br><span class="line">            if (arg != null &amp;&amp; arg instanceof Notification) &#123;</span><br><span class="line">                maybeSetChannelId((Notification) arg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   public static void maybeSetChannelId(Notification notification) &#123;</span><br><span class="line">        if (SDK_INT &gt;= 26) &#123;</span><br><span class="line">            if (TextUtils.isEmpty(notification.getChannelId())) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    Field mChannelId = Notification.class.getDeclaredField(&quot;mChannelId&quot;);</span><br><span class="line">                    mChannelId.setAccessible(true);</span><br><span class="line">                    mChannelId.set(notification, CHANNEL);</span><br><span class="line">                &#125; catch (NoSuchFieldException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; catch (IllegalAccessException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="三-使用-ASM-框架"><a href="#三-使用-ASM-框架" class="headerlink" title="三 使用 ASM 框架."></a>三 使用 ASM 框架.</h4><h5 id="3-1-Android-Plugin-处理"><a href="#3-1-Android-Plugin-处理" class="headerlink" title="3.1 Android Plugin 处理"></a>3.1 Android Plugin 处理</h5><p>在androisjd 打包中加入对 class 的处理<br>引入’ compile ‘org.ow2.asm:asm:6.0_ALPHA’’</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">byte[] process(byte[] src) &#123;</span><br><span class="line">       try &#123;</span><br><span class="line">           ClassReader classReader = new ClassReader(src);</span><br><span class="line">           ClassWriter cw = new ClassWriter(classReader, ClassWriter.COMPUTE_MAXS);</span><br><span class="line">           classReader.accept(new AopClassVisitor(cw, sasukeExtension), ClassReader.EXPAND_FRAMES);</span><br><span class="line">           return cw.toByteArray();</span><br><span class="line">       &#125; catch (Exception e) &#123;</span><br><span class="line">           return src;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>AopClassVisitor.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class AopClassVisitor extends ClassVisitor &#123;</span><br><span class="line">     private String className;</span><br><span class="line"></span><br><span class="line">    public AopClassVisitor(ClassWriter cw) &#123;</span><br><span class="line">        super(Opcodes.ASM5, cw);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void visit(int version, int access, String name, String signature, String superName, String[] interfaces) &#123;</span><br><span class="line">        className = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) &#123;</span><br><span class="line">        if (className.equals(&quot;red/dim/hook/NotificationFix&quot;)) &#123;</span><br><span class="line">            return super.visitMethod(access, name, desc, signature, exceptions);</span><br><span class="line">        &#125;</span><br><span class="line">        return new AopMethodVisitor(super.visitMethod(access, name, desc, signature, exceptions));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>AopMethodVisitor.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class AopMethodVisitor extends MethodVisitor &#123;</span><br><span class="line">    AopMethodVisitor(MethodVisitor methodVisitor) &#123;</span><br><span class="line">        super(Opcodes.ASM5, methodVisitor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void visitMethodInsn(int opcode, String owner, String name, String desc, boolean itf) &#123;</span><br><span class="line">        if (opcode == Opcodes.INVOKEINTERFACE</span><br><span class="line">                &amp;&amp; &quot;android/app/NotificationManager&quot;.equals(owner)</span><br><span class="line">                &amp;&amp; &quot;notify&quot;.equals(name)</span><br><span class="line">                &amp;&amp; &quot;(I;Landroid/app/Notification)V&quot;.equals(desc)) &#123;</span><br><span class="line">            visitMethodInsn(Opcodes.INVOKESTATIC, &quot;red/dim/hook/NotificationFix&quot;, &quot;notify&quot;, &quot;(Landroid/app/NotificationManager;I;Landroid/app/Notification)V&quot;, false);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if (opcode == Opcodes.INVOKEINTERFACE</span><br><span class="line">                &amp;&amp; &quot;android/app/NotificationManager&quot;.equals(owner)</span><br><span class="line">                &amp;&amp; &quot;notify&quot;.equals(name)</span><br><span class="line">                &amp;&amp; &quot;(Ljava.lang.String;I;Landroid/app/Notification)V&quot;.equals(desc)) &#123;</span><br><span class="line">            visitMethodInsn(Opcodes.INVOKESTATIC, &quot;red/dim/hook/NotificationFix&quot;, &quot;notify&quot;, &quot;(Landroid/app/NotificationManager;Ljava.lang.String;I;Landroid/app/Notification)V&quot;, false);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        super.visitMethodInsn(opcode, owner, name, desc, itf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>上述的代码通过字节码分析将所有的NotificationManager 的 notify 的两个方法的调用都路由到<br> NotificationFix 的 notify 静态方法上.</p><h5 id="3-2-SDK-处理"><a href="#3-2-SDK-处理" class="headerlink" title="3.2  SDK 处理"></a>3.2  SDK 处理</h5><p>在 SDK 加入处理类<br>red.dim.hook.NotificationFix.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class NotificationFix &#123;</span><br><span class="line"></span><br><span class="line">    public static final String CHANNEL = &quot;dim&quot;;</span><br><span class="line"></span><br><span class="line">    public static void notify(NotificationManager notificationManager, int id, Notification notification) &#123;</span><br><span class="line">        maybeSetChannelId(notification);</span><br><span class="line">        notificationManager.notify(id, notification);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void notify(NotificationManager notificationManager, String tag, int id, Notification notification) &#123;</span><br><span class="line">        maybeSetChannelId(notification);</span><br><span class="line">        notificationManager.notify(tag, id, notification);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void maybeSetChannelId(Notification notification) &#123;</span><br><span class="line">        if (SDK_INT &gt;= 26) &#123;</span><br><span class="line">            if (TextUtils.isEmpty(notification.getChannelId())) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    Field mChannelId = Notification.class.getDeclaredField(&quot;mChannelId&quot;);</span><br><span class="line">                    mChannelId.setAccessible(true);</span><br><span class="line">                    mChannelId.set(notification, CHANNEL);</span><br><span class="line">                &#125; catch (NoSuchFieldException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; catch (IllegalAccessException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="四-总结"><a href="#四-总结" class="headerlink" title="四 总结"></a>四 总结</h1><p>三种 AOP 方式 各有优势</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://dim.red&quot;&gt;dim.red&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;一-背景&quot;&gt;&lt;a href=&quot;#一-背景&quot; class=&quot;headerlink&quot; title=&quot;一 背景&quot;&gt;&lt;/a&gt;一 背景&lt;/h1&gt;&lt;p&gt;android 的版本的更替往往需要开发者进行跟进.&lt;/p&gt;
&lt;p&gt;Notification 在Android 8.0 上需要做一些兼容的工作.&lt;a href=&quot;https://developer.android.com/guide/topics/ui/notifiers/notifications.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;官方指导文档&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>AspectJ 在Android 上的应用和加速</title>
    <link href="http://dim.red/2017/04/23/aspectj_aop/"/>
    <id>http://dim.red/2017/04/23/aspectj_aop/</id>
    <published>2017-04-22T16:00:00.000Z</published>
    <updated>2018-08-25T08:43:16.985Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://dim.red">dim.red</a></p><h1 id="开头"><a href="#开头" class="headerlink" title="开头"></a>开头</h1><p>java上的AOP 框架比较出名的是AspectJ，比较可惜的是这个框架是在gradle上需要一些变换才能使用。<br><a id="more"></a><br>在使用这个框架之前,我们来看AspectJ 命令的几个比较重要的参数：<br>-classpath：class和source 的位置<br>-aspectpath： 定义了切面规则的class<br>-d：指定输出的目录<br>-outjar：指定输出的jar上<br>-inpath：需要处理的.class<br>classpath 的作用是在当解析一个类的时候，当这个类是不在inpath 中，会从classpath 中寻找。<br>在使用AspectJ的时候, 我们用以下几个方面来优化我们的速度。</p><h2 id="一-多线程"><a href="#一-多线程" class="headerlink" title="一 多线程:"></a>一 多线程:</h2><p>首先我们通过android plugin的Transform api ，收集所有的class文件。<br>然后用AspectJ处理所有的class.输出到对应的目录下。<br>这里我们为了保证transform灵活性，我们不将所有的class 合并成一个jar，而是每个输入对应一个输出。同时使用多线程来为这个过程加速。<br>在后续的使用我们发现单纯的直接用多线程来处理这个问题，会引发一个异常，异常如下：<br><img src="http://upload-images.jianshu.io/upload_images/166866-df7277b830e682a9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="异常.png"><br>通过分析可以发现问题是出现在CompilerAdapter 类下，具体是因为CompilerAdapter 会被注入到相关类中。而注入的是同一个实例，在多线程下操作中，一并发就会导致一些bug， 我们重新编写CompilerAdapter 类。在对应的field上用ThreadLocal 包裹，使在参数实例在多线程下隔离，这样就简单的解决问题。</p><p>这里有个比较有意思的点是：AspectJ AOP 框架对自身的代码进行了AOP编程。</p><h2 id="二-指定精确的aspectpath"><a href="#二-指定精确的aspectpath" class="headerlink" title="二 指定精确的aspectpath"></a>二 指定精确的aspectpath</h2><p>为了加速aspectJ的处理过程， 我们会将aspectpath对应的class 找出来，然后在AspectJ处理的时候将参数指向给aspectpath。 我们通过用ASM 框架解析类，查找所有被Lorg/aspectj/lang/annotation/Aspect 注释的类，收集到一个单独的文件夹中。这样可以为AspectJ处理提升速度。<br>同时为了加快查找aspectpath 的文件。<br>我们支持了对Android library 和Java Library 的aspectpath 文件进行标注。在主项目中查找aspectpath 文件的时候，可以根据这个标注更快的收集.</p><ul><li>Android Library 我们定义2个Transform ，一个针对Class，收集和分析class，一个针对资源，将上个Transform收集的结果写入Java Resource 中的NOTICE文件。</li><li>Java Library 则是在jar task 后面分析生成的jar文件.同样把结果写入Java Resource 的 NOTICE文件。</li></ul><p>这里之所以使用NOTICE ，而不使用别的，一是为了兼容Android Plugin 版本的变迁。二是因为 Android Plugin 的Java Resource 的合并是会忽略掉几个特定的文件，而NOTICE就在这几个特定文件中。<br>2.0 Android Plugin 忽略的文件：<br><img src="http://upload-images.jianshu.io/upload_images/166866-dd51e8f4a4147a6c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Android Plugin 2.0 "></p><p>2.3 Android Plugin 忽略的文件：<br><img src="http://upload-images.jianshu.io/upload_images/166866-c3dfb3269a1bc81d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Android Plugin 2.3.png"></p><p>使用NOTICE 好处就是，你用插件处理的jar 包或者aar 在应用到不相干的项目中，在生成的APK不会多余令人困户的配置文件存在。</p><h2 id="三-支持增量："><a href="#三-支持增量：" class="headerlink" title="三 支持增量："></a>三 支持增量：</h2><p>我们几乎所有的Transform 都支持了增量编译，意思是AspectJ 并不会每次都处理所有的class， 他只会处理有变更的class 文件。 除非是你的aspectpath文件出现了变更，即AOP规则变更了, 之前的处理结果已经不可靠了，就会触发一次全量的处理。<br>为了支持这个特性，我们必须手动的为AspectJ 新增一个参数  <code>-infiles</code>。为了这个特性我们必须去修改aspectJ 的源码。修改以下3个类 <code>org.aspectj.ajdt.internal.core.builder.AjBuildManager</code>和<code>org.aspectj.ajdt.internal.core.builder.AjBuildConfig</code> 和<code>org.aspectj.ajdt.ajc.BuildArgParser</code>， 这个特性在持续开发中对于节省时间特别有效。</p><p>因为在一些需求我们需要修改AspectJ的代码，因为AspectJ 的源码编译比较麻烦。我们这里使用修改后的java编译出的class 文件，然后直接覆盖AspectJ jar包中对应的文件上。</p><h1 id="结尾"><a href="#结尾" class="headerlink" title="结尾:"></a>结尾:</h1><p>我们将所有的代码放置在github 上 <a href="https://github.com/zzz40500/AspectJAOP" target="_blank" rel="noopener">AspectJAOP</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://dim.red&quot;&gt;dim.red&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;开头&quot;&gt;&lt;a href=&quot;#开头&quot; class=&quot;headerlink&quot; title=&quot;开头&quot;&gt;&lt;/a&gt;开头&lt;/h1&gt;&lt;p&gt;java上的AOP 框架比较出名的是AspectJ，比较可惜的是这个框架是在gradle上需要一些变换才能使用。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Android Plugin Transform 初探</title>
    <link href="http://dim.red/2017/04/05/android_plugin_transform_%20exploration/"/>
    <id>http://dim.red/2017/04/05/android_plugin_transform_ exploration/</id>
    <published>2017-04-04T16:00:00.000Z</published>
    <updated>2018-11-17T17:59:08.666Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://dim.red">dim.red</a></p><p>环境: android gradle 2.3 </p><p><a href="http://tools.android.com/tech-docs/new-build-system/transform-api" target="_blank" rel="noopener">transform api</a></p><h2 id="一-概况"><a href="#一-概况" class="headerlink" title="一 概况"></a>一 概况</h2><p>transform 开始于1.5.0-beta1 可以用于在android 打包,class转换成dex 过程中,加入开发者自定义的处理逻辑. 他也可以处理native.只是native 这里处理的是so 文件的,再加工难度比较大. </p><h2 id="二-定义"><a href="#二-定义" class="headerlink" title="二 定义"></a>二 定义</h2><p><code>ContentType</code>:<br>CLASSES,<br>RESOURCES,<br>DEX,<br>NATIVE_LIBS,<br>CLASSES_ENHANCED,<br>JACK<br>ContentType表示文件的类型. CLASSES 这个是javac 编译成class文件<br>RESOURCES: 这里的resources 单指Java 的资源.<br>DEX 这个是class 文件dx 编译成的dex 文件.<br>比较可惜的是自定义的 transform 无法处理这些文件. 具体原因看后面.<br><code>Scope:</code><br>        PROJECT(0x01),<br>        PROJECT_LOCAL_DEPS(0x02),<br>        SUB_PROJECTS(0x04),<br>        SUB_PROJECTS_LOCAL_DEPS(0x08),<br>        EXTERNAL_LIBRARIES(0x10),<br>        TESTED_CODE(0x20),<br>        PROVIDED_ONLY(0x40)  </p><p>通过 Scope  和ContentType可以组成一个资源流.即PROJECT 和CLASSES ,表示了主项目中java 编译成的class 组成的一个资源流,SUB_PROJECTS 和 CLASSES ,表示的是本地子项目中的java 编译的class 资源流.</p><h2 id="三-transform-的作用"><a href="#三-transform-的作用" class="headerlink" title="三 transform 的作用"></a>三 transform 的作用</h2><p>transform 是来处理和转换这些流的.<br>transform 中存在两种资源流,一种是会被消费掉.一种只是参与了转换过程.并不会被消费掉.  </p><p>资源流存储在一个资源池. transform 从这个资源池收集这两种流.然后经过一定的规则转换生成新的资源流放到这个池子里. 同时将未消耗的资源流也放回这个池子里去,下一个transform 重复之前的流程.  </p><h3 id="api"><a href="#api" class="headerlink" title="api"></a>api</h3><p><code>Set&lt;ContentType&gt; getInputTypes()</code>:定义了你要处理的类型;<br><code>Set&lt;Scope&gt; getScopes()</code>:你要消耗资源流的范围;<br><code>Set&lt;Scope&gt; getReferencedScopes()</code>:转换过程中需要资源流的范围,在转换过程中不会被消耗,转换结束后, 会将资源流放回资源池去.<br><code>Set&lt;ContentType&gt; getOutputTypes()</code> 转换输出类型,默认是getInputTypes()  </p><h2 id="四-transform工作原理"><a href="#四-transform工作原理" class="headerlink" title="四 transform工作原理"></a>四 transform工作原理</h2><p>对外注册api:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">android.registerTransform(new XTransform());</span><br><span class="line">android.registerTransform(new XTransform(), dependencies)</span><br></pre></td></tr></table></figure></p><p>内部注册api<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TransformManager.addTransform();</span><br></pre></td></tr></table></figure></p><p>gradle 会收集一些原始的资源流, 同时这些流可能还会有依赖task的,类似前置任务,比如说PROJECT 的CLASSES 需要依赖avac 的task 的任务.NATIVE_LIBS 需要依赖于ndk 的task ,这个也是可以理解的, 因为project 的class 产生是需要通过javac 的任务生成的. 同时如果你的transform 需要处理或者依赖这些资源流, 会被自动的被依赖上这些task.当gradle 收集完原始的资源流以后, gradle 开始注册transform,因为注册的transform是有顺序的,所以先注册的先处理资源流, 如果先注册的transform 消耗掉的资源.后续的transform 就无法处理了, 但是他可以处理前面transform 生成的资源流.(比方说有一个transformA 消耗了PROJECT 的CLASSES.同时经过转换生成了PROJECT 的CLASSES, 那下一个transformB如果要消耗和处理PROJECT 的CLASSES,那么他处理的是就是transformA转换的资源流而不是gradle收集资源流.)  </p><p>自定义的transform之所以不能处理Dex 文件,是因为Dex 是由DexTransform|MultiDexTransform 由CLASSES 转成dex, 而自定义的transform 的注册在DexTransform|MultiDexTransform 之前,意思是自定义transform 注册的时候资源池里面还没dex的资源流.所以它无法处理Dex;  </p><h2 id="五-再讲资源流"><a href="#五-再讲资源流" class="headerlink" title="五 再讲资源流"></a>五 再讲资源流</h2><p>说是流,其实是一个个文件的集合.原始的资源流是在Configuration 阶段中,收集成一个个文件的聚合. 而transform 生成的资源流是怎样的是,它其实是一个根目录(build/transforms/xxx)为基准,根据规则生成的一个个目录. gradle 通过TransformOutputProvider这个类帮我们简化这个步骤.  </p><h2 id="六-尾巴"><a href="#六-尾巴" class="headerlink" title="六 尾巴"></a>六 尾巴</h2><ol><li>虽然从getReferencedScopes() 可以获取到资源流,但是你不应该对这个资源流做任何的改动.因为这个可能作为下一个transform的输入. 同时这个资源流里面的文件.可能是一个全局的文件. 你的更改,将不仅仅影响到这个工程.甚至其他工程.   </li></ol><ul><li>颗粒太大:处理是的流,无法处理流里面的单个文件. 就是说如果你只是想单单处理某个文件. 你将不得不处理整个流. 造成多余的copy,以及磁盘的占用.   </li><li>自定义的transform 无法处理Dex   </li><li>自定义的transform 无法使用自定义ContentType</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;http://dim.red&quot;&gt;dim.red&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;环境: android gradle 2.3 &lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://tools.android.com/tech-docs/new-build-system/t
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Gson 解析小技巧</title>
    <link href="http://dim.red/2016/05/27/gson-skill/"/>
    <id>http://dim.red/2016/05/27/gson-skill/</id>
    <published>2016-05-26T16:00:00.000Z</published>
    <updated>2018-08-25T08:43:17.049Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://dim.red">dim.red</a><br>解析 List 的时候官方的使用:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Dim&gt; dims=gson.fromJson(json,new TypeToken&lt;List&lt;Dim&gt;&gt;()&#123;&#125;.getType());</span><br></pre></td></tr></table></figure><p>使用TypeToken 匿名内部类的方式.获取到匿名内部类定义的泛型.<br><a id="more"></a></p><p>当我们封装一个工具类的时候,解析 List 的时候不可避免要传递一个 TypeToken 匿名内部类的进来.<br>有什么办法只传递<code>Dim</code> 而不用写很长的 TypeToken 呢?<br>方式其实很简单,就是为 Gson 构造一个正确的 Type 给它.</p><p>TypeFactory是一个工具类简单封装.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Created by dim on 16/5/27.</span><br><span class="line"> */</span><br><span class="line">public class TypeFactory &#123;</span><br><span class="line"></span><br><span class="line">    public static Type $List(Type type) &#123;</span><br><span class="line">        return $Gson$Types.newParameterizedTypeWithOwner(null, List.class, type);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Type $Set(Type type) &#123;</span><br><span class="line">        return $Gson$Types.newParameterizedTypeWithOwner(null, Set.class, type);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Type $HashMap(Type type, Type type2) &#123;</span><br><span class="line">        return $Gson$Types.newParameterizedTypeWithOwner(null, HashMap.class, type, type2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Type $Map(Type type, Type type2) &#123;</span><br><span class="line">        return $Gson$Types.newParameterizedTypeWithOwner(null, Map.class, type, type2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Type $Parameterized(Type ownerType, Type rawType, Type... typeArguments) &#123;</span><br><span class="line">        return $Gson$Types.newParameterizedTypeWithOwner(ownerType, rawType, typeArguments);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Type $Array(Type type) &#123;</span><br><span class="line">        return $Gson$Types.arrayOf(type);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Type $SubtypeOf(Type type) &#123;</span><br><span class="line">        return $Gson$Types.subtypeOf(type);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Type $SupertypeOf(Type type) &#123;</span><br><span class="line">        return $Gson$Types.supertypeOf(type);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Dim&gt; dims = gson.fromJson(json, TypeFactory.$List(Dim.class));</span><br></pre></td></tr></table></figure></p><p>再使用静态导入方法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import static com.dim.TypeFactory.*;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">List&lt;Dim&gt; dims = gson.fromJson(json, $List(Dim.class));</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>一些复杂的泛型<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">List&lt;Dim&gt; dims = gson.fromJson(json, $List(Dim.class));</span><br><span class="line">List&lt;List&lt;Dim&gt;&gt; dimss= gson.fromJson(json,$List($List(Dim.class)));</span><br><span class="line">Dim[] dimArray=gson.fromJson(json,$Array(Dim.class));</span><br><span class="line">Set&lt;Dim&gt; dimSet=gson.fromJson(json,$Set(Dim.class));</span><br><span class="line">Map&lt;String,Dim&gt; dimMap=gson.fromJson(json,$Map(String.class,Dim.class));</span><br><span class="line">Map&lt;String,List&lt;Dim&gt;&gt; dimsMap=gson.fromJson(json,$Map(String.class,$List(Dim.class)));</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://dim.red&quot;&gt;dim.red&lt;/a&gt;&lt;br&gt;解析 List 的时候官方的使用:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;List&amp;lt;Dim&amp;gt; dims=gson.fromJson(json,new TypeToken&amp;lt;List&amp;lt;Dim&amp;gt;&amp;gt;()&amp;#123;&amp;#125;.getType());&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;使用TypeToken 匿名内部类的方式.获取到匿名内部类定义的泛型.&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>lv 和 rv 的缓存比较(初稿)</title>
    <link href="http://dim.red/2016/03/07/rv_lv_cmp/"/>
    <id>http://dim.red/2016/03/07/rv_lv_cmp/</id>
    <published>2016-03-06T16:00:00.000Z</published>
    <updated>2018-08-25T08:43:17.089Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://dim.red">dim.red</a></p><h2 id="lv的缓存"><a href="#lv的缓存" class="headerlink" title="lv的缓存"></a>lv的缓存</h2><a id="more"></a><h3 id="存储-View-结构"><a href="#存储-View-结构" class="headerlink" title="存储 View 结构"></a>存储 View 结构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public void setViewTypeCount(int viewTypeCount) &#123;</span><br><span class="line">    if (viewTypeCount &lt; 1) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;Can&apos;t have a viewTypeCount &lt; 1&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    //noinspection unchecked</span><br><span class="line">    ArrayList&lt;View&gt;[] scrapViews = new ArrayList[viewTypeCount];</span><br><span class="line">    for (int i = 0; i &lt; viewTypeCount; i++) &#123;</span><br><span class="line">        scrapViews[i] = new ArrayList&lt;View&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    mViewTypeCount = viewTypeCount;</span><br><span class="line">    mCurrentScrap = scrapViews[0];</span><br><span class="line">    mScrapViews = scrapViews;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>存储View 的是ArrayList<view>[],并且数组大小为viewTypeCount , 这也是为什么我们在多 type 的时候需要指定type的个数了.</view></p><h3 id="屏幕外的缓存"><a href="#屏幕外的缓存" class="headerlink" title="屏幕外的缓存"></a>屏幕外的缓存</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Put a view into the ScrapViews list. These views are unordered.</span><br><span class="line"> *</span><br><span class="line"> * @param scrap The view to add</span><br><span class="line"> */</span><br><span class="line">void addScrapView(View scrap, int position) &#123;</span><br><span class="line">    AbsListView.LayoutParams lp = (AbsListView.LayoutParams) scrap.getLayoutParams();</span><br><span class="line">    if (lp == null) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    lp.scrappedFromPosition = position;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    if (mViewTypeCount == 1) &#123;</span><br><span class="line">        mCurrentScrap.add(scrap);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        mScrapViews[viewType].add(scrap);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @return A view from the ScrapViews collection. These are unordered.</span><br><span class="line"> */</span><br><span class="line">View getScrapView(int position) &#123;</span><br><span class="line">    if (mViewTypeCount == 1) &#123;</span><br><span class="line">        return retrieveFromScrap(mCurrentScrap, position);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        int whichScrap = mAdapter.getItemViewType(position);</span><br><span class="line">        if (whichScrap &gt;= 0 &amp;&amp; whichScrap &lt; mScrapViews.length) &#123;</span><br><span class="line">            return retrieveFromScrap(mScrapViews[whichScrap], position);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static View retrieveFromScrap(ArrayList&lt;View&gt; scrapViews, int position) &#123;</span><br><span class="line">    int size = scrapViews.size();</span><br><span class="line">    if (size &gt; 0) &#123;</span><br><span class="line">        // See if we still have a view for this position.</span><br><span class="line">        for (int i=0; i&lt;size; i++) &#123;</span><br><span class="line">            View view = scrapViews.get(i);</span><br><span class="line">            if (((AbsListView.LayoutParams)view.getLayoutParams())</span><br><span class="line">                    .scrappedFromPosition == position) &#123;</span><br><span class="line">                scrapViews.remove(i);</span><br><span class="line">                return view;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return scrapViews.remove(size - 1);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="注意"><a href="#注意" class="headerlink" title="注意:"></a>注意:</h4><p>代码为api 21的,各个系统版本不同可能代码有所不同,但是核心的思想是一样的.</p><h2 id="rv的缓存"><a href="#rv的缓存" class="headerlink" title="rv的缓存"></a>rv的缓存</h2><h3 id="根据-Position-获取-View-视图"><a href="#根据-Position-获取-View-视图" class="headerlink" title="根据 Position 获取 View 视图"></a>根据 Position 获取 View 视图</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">View getViewForPosition(int position, boolean dryRun) &#123;</span><br><span class="line">     ...</span><br><span class="line">    // 0) If there is a changed scrap, try to find from there</span><br><span class="line">    if (mState.isPreLayout()) &#123;</span><br><span class="line">        holder = getChangedScrapViewForPosition(position);</span><br><span class="line">        fromScrap = holder != null;</span><br><span class="line">    &#125;</span><br><span class="line">    // 1) Find from scrap by position</span><br><span class="line">    if (holder == null) &#123;</span><br><span class="line">        holder = getScrapViewForPosition(position, INVALID_TYPE, dryRun);</span><br><span class="line">       ...</span><br><span class="line">    &#125;</span><br><span class="line">    if (holder == null) &#123;</span><br><span class="line">       ...</span><br><span class="line">        // 2) Find from scrap via stable ids, if exists</span><br><span class="line">        if (mAdapter.hasStableIds()) &#123;</span><br><span class="line">            holder = getScrapViewForId(mAdapter.getItemId(offsetPosition), type, dryRun);</span><br><span class="line">            if (holder != null) &#123;</span><br><span class="line">                // update position</span><br><span class="line">                holder.mPosition = offsetPosition;</span><br><span class="line">                fromScrap = true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (holder == null &amp;&amp; mViewCacheExtension != null) &#123;</span><br><span class="line">            // We are NOT sending the offsetPosition because LayoutManager does not</span><br><span class="line">            // know it.</span><br><span class="line">            final View view = mViewCacheExtension</span><br><span class="line">                    .getViewForPositionAndType(this, position, type);</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        if (holder == null) &#123; // fallback to recycler</span><br><span class="line">            // try recycler.</span><br><span class="line">            // Head to the shared pool.</span><br><span class="line">            if (DEBUG) &#123;</span><br><span class="line">                Log.d(TAG, &quot;getViewForPosition(&quot; + position + &quot;) fetching from shared &quot;</span><br><span class="line">                        + &quot;pool&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            holder = getRecycledViewPool().getRecycledView(type);</span><br><span class="line">            if (holder != null) &#123;</span><br><span class="line">                holder.resetInternal();</span><br><span class="line">                if (FORCE_INVALIDATE_DISPLAY_LIST) &#123;</span><br><span class="line">                    invalidateDisplayListInt(holder);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (holder == null) &#123;</span><br><span class="line">            holder = mAdapter.createViewHolder(RecyclerView.this, type);</span><br><span class="line">            if (DEBUG) &#123;</span><br><span class="line">                Log.d(TAG, &quot;getViewForPosition created new ViewHolder&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    boolean bound = false;</span><br><span class="line">    if (mState.isPreLayout() &amp;&amp; holder.isBound()) &#123;</span><br><span class="line">        // do not update unless we absolutely have to.</span><br><span class="line">        holder.mPreLayoutPosition = position;</span><br><span class="line">    &#125; else if (!holder.isBound() || holder.needsUpdate() || holder.isInvalid()) &#123;</span><br><span class="line">        if (DEBUG &amp;&amp; holder.isRemoved()) &#123;</span><br><span class="line">            throw new IllegalStateException(&quot;Removed holder should be bound and it should&quot;</span><br><span class="line">                    + &quot; come here only in pre-layout. Holder: &quot; + holder);</span><br><span class="line">        &#125;</span><br><span class="line">        final int offsetPosition = mAdapterHelper.findPositionOffset(position);</span><br><span class="line">        holder.mOwnerRecyclerView = RecyclerView.this;</span><br><span class="line">        mAdapter.bindViewHolder(holder, offsetPosition);</span><br><span class="line">        attachAccessibilityDelegate(holder.itemView);</span><br><span class="line">        bound = true;</span><br><span class="line">        if (mState.isPreLayout()) &#123;</span><br><span class="line">            holder.mPreLayoutPosition = position;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    final ViewGroup.LayoutParams lp = holder.itemView.getLayoutParams();</span><br><span class="line">    final LayoutParams rvLayoutParams;</span><br><span class="line">    if (lp == null) &#123;</span><br><span class="line">        rvLayoutParams = (LayoutParams) generateDefaultLayoutParams();</span><br><span class="line">        holder.itemView.setLayoutParams(rvLayoutParams);</span><br><span class="line">    &#125; else if (!checkLayoutParams(lp)) &#123;</span><br><span class="line">        rvLayoutParams = (LayoutParams) generateLayoutParams(lp);</span><br><span class="line">        holder.itemView.setLayoutParams(rvLayoutParams);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        rvLayoutParams = (LayoutParams) lp;</span><br><span class="line">    &#125;</span><br><span class="line">    rvLayoutParams.mViewHolder = holder;</span><br><span class="line">    rvLayoutParams.mPendingInvalidate = fromScrap &amp;&amp; bound;</span><br><span class="line">    return holder.itemView;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里可以看出<br>holder 分别从以下几个地方被赋值: </p><ol><li>当mState.isPreLayout() 为 true 有也就是动画的时候.<br>getChangedScrapViewForPosition<br>从mChangedScrap 中获取到配置position ,position 配置不到的话,当mAdapter.hasStableIds() 为 true 的话,匹配getItemId 的值.值得注意当我们的 LayoutManger 支持动画的时候,他的onLayoutChildren 会被调用两个,一次为Pre-Layout,一种是 Real-Layout, 而mChangedScrap中的 View 在只会在Pre-Layout.返回的目的是为了 LayoutManager 在Pre-Layout中不会空白了一块.可以正确布局.</li></ol><ul><li>getScrapViewForPosition() 从mAttachedScrap 中匹配position , 配置不到的话从mCachedViews 去匹配 position 值,</li><li>当mAdapter.hasStableIds() 为 true 的时候.<br>getScrapViewForId 从mAttachedScrap 中匹配getItemId 以及 ViewType 值,匹配不到的话,尝试从mCachedViews 匹配getItemId 和ViewType.</li><li>当 mViewCacheExtension 不为空的时候 getViewForPositionAndType()从开发者设置ViewCacheExtension  中获取到 View</li><li>getRecycledViewPool().getRecycledView(type)<br>从RecycledViewPool 获取到View</li><li>mAdapter.createViewHolder(RecyclerView.this, type); 创建一个 View .</li></ul><p>我们从上面的是地方可以看出我们的缓存 View 存储在两种类型:<br>Scrap 和recycle:</p><p>Scrap<br>mChangedScrap,mAttachedScrap,mCachedViews.<br>recycle<br>RecycledViewPool.<br>Scrap 之所以比recycle轻量. 因为recycle 一定会有bindViewHolder 的动作.而Scrap 不一定会有.</p><h4 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h4><p>mAdapter.hasStableIds()  表示数据集合中的每一项是否可以代表有惟一的标识符,这个都作用跟Adapter.hasStableIds一致的效果,具体作用在notifyDataSetChanged 体现. eg:你有适配器hasStableIds为 false, 你的列表中删除了第2项,那你使用notifyDataSetChanged 那么你的第2项的展示的数据是第三项的,但是你的 View 还是之前的第2的View.而你hasStableIds 为 true, 并且为他们每个项有一个唯一的 id, 那你删除了第2项,使用notifyDataSetChanged 那么你的第2项的展示的数据是第三项的,你的 View 就是之前第三项.因为 View 跟数据匹配上了.</p><h3 id="屏幕内缓存"><a href="#屏幕内缓存" class="headerlink" title="屏幕内缓存"></a>屏幕内缓存</h3><p>RequestLayout 和NotifyXXX 下的回收.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">void scrapView(View view) &#123;</span><br><span class="line">    final ViewHolder holder = getChildViewHolderInt(view);</span><br><span class="line">    if (holder.hasAnyOfTheFlags(ViewHolder.FLAG_REMOVED | ViewHolder.FLAG_INVALID)</span><br><span class="line">            || !holder.isUpdated() || canReuseUpdatedViewHolder(holder)) &#123;</span><br><span class="line">       ...</span><br><span class="line">        holder.setScrapContainer(this, false);</span><br><span class="line">        mAttachedScrap.add(holder);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if (mChangedScrap == null) &#123;</span><br><span class="line">            mChangedScrap = new ArrayList&lt;ViewHolder&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        holder.setScrapContainer(this, true);</span><br><span class="line">        mChangedScrap.add(holder);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>mChangedScrap: 收集的是界面上被打上UpdateOp.UPDATE的 item,rv 通过notifyItemChanged对 position 所在的ViewHolder 打上flag的.</p><p>mAttachedScrap: 界面上所有非mChangedScrap 的 View</p><h3 id="屏幕外的缓存-1"><a href="#屏幕外的缓存-1" class="headerlink" title="屏幕外的缓存."></a>屏幕外的缓存.</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">private static final int DEFAULT_CACHE_SIZE = 2;</span><br><span class="line">private int mViewCacheMax = DEFAULT_CACHE_SIZE;</span><br><span class="line">/**</span><br><span class="line"> * internal implementation checks if view is scrapped or attached and throws an exception</span><br><span class="line"> * if so.</span><br><span class="line"> * Public version un-scraps before calling recycle.</span><br><span class="line"> */</span><br><span class="line">void recycleViewHolderInternal(ViewHolder holder) &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    if (forceRecycle || holder.isRecyclable()) &#123;</span><br><span class="line">        if (!holder.hasAnyOfTheFlags(ViewHolder.FLAG_INVALID | ViewHolder.FLAG_REMOVED</span><br><span class="line">                | ViewHolder.FLAG_UPDATE)) &#123;</span><br><span class="line">            // Retire oldest cached view</span><br><span class="line">            final int cachedViewSize = mCachedViews.size();</span><br><span class="line">            if (cachedViewSize == mViewCacheMax &amp;&amp; cachedViewSize &gt; 0) &#123;</span><br><span class="line">                recycleCachedViewAt(0);</span><br><span class="line">            &#125;</span><br><span class="line">            if (cachedViewSize &lt; mViewCacheMax) &#123;</span><br><span class="line">                mCachedViews.add(holder);</span><br><span class="line">                cached = true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (!cached) &#123;</span><br><span class="line">            addViewHolderToRecycledViewPool(holder);</span><br><span class="line">            recycled = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    …</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void recycleCachedViewAt(int cachedViewIndex) &#123;</span><br><span class="line">   </span><br><span class="line">    ViewHolder viewHolder = mCachedViews.get(cachedViewIndex);</span><br><span class="line">    </span><br><span class="line">    addViewHolderToRecycledViewPool(viewHolder);</span><br><span class="line">    mCachedViews.remove(cachedViewIndex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void addViewHolderToRecycledViewPool(ViewHolder holder) &#123;</span><br><span class="line">    ViewCompat.setAccessibilityDelegate(holder.itemView, null);</span><br><span class="line">    dispatchViewRecycled(holder);</span><br><span class="line">    holder.mOwnerRecyclerView = null;</span><br><span class="line">    getRecycledViewPool().putRecycledView(holder);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们可以看出 view 的回收是要经过mCachedViews 然后才是RecycledViewPool<br>并且这里的判断条件也是挺有意思:<br>如果mCachedViews 到达 最大值,讲 mCachedViews 第一个压入RecycledViewPool中,然后要回收的 View也压到RecycledViewPool中去.如果不没有到达最大值才压入 mCachedViews 中去.从代码中我们可以看出最大值为2,你也可是使用setViewCacheSize方法设置最大值.</p><p>RecycledViewPool 是最后一级回收了.我们看一下这个RecycledViewPool 的实现.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public static class RecycledViewPool &#123;</span><br><span class="line">    private SparseArray&lt;ArrayList&lt;ViewHolder&gt;&gt; mScrap =</span><br><span class="line">            new SparseArray&lt;ArrayList&lt;ViewHolder&gt;&gt;();</span><br><span class="line">    private SparseIntArray mMaxScrap = new SparseIntArray();</span><br><span class="line">    private int mAttachCount = 0;</span><br><span class="line"></span><br><span class="line">    private static final int DEFAULT_MAX_SCRAP = 5;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">public void putRecycledView(ViewHolder scrap) &#123;</span><br><span class="line">    final int viewType = scrap.getItemViewType();</span><br><span class="line">    final ArrayList scrapHeap = getScrapHeapForType(viewType);</span><br><span class="line">    if (mMaxScrap.get(viewType) &lt;= scrapHeap.size()) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if (DEBUG &amp;&amp; scrapHeap.contains(scrap)) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;this scrap item already exists&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    scrap.resetInternal();</span><br><span class="line">    scrapHeap.add(scrap);</span><br><span class="line">&#125;</span><br><span class="line">…</span><br><span class="line"></span><br><span class="line">private ArrayList&lt;ViewHolder&gt; getScrapHeapForType(int viewType) &#123;</span><br><span class="line">    ArrayList&lt;ViewHolder&gt; scrap = mScrap.get(viewType);</span><br><span class="line">    if (scrap == null) &#123;</span><br><span class="line">        scrap = new ArrayList&lt;&gt;();</span><br><span class="line">        mScrap.put(viewType, scrap);</span><br><span class="line">        if (mMaxScrap.indexOfKey(viewType) &lt; 0) &#123;</span><br><span class="line">            mMaxScrap.put(viewType, DEFAULT_MAX_SCRAP);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return scrap;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们可以看出这里使用了SparseArray&lt;ArrayList<viewholder>&gt;来存储 View,由于SparseArray 可以动态增加,所以我们并不需要手动写明 viewTypeCount. 同时我们也可以看到每种类型缓存最大值为5 ,大于5以后 的 view 会被丢弃.</viewholder></p><p>##对比:</p><ol><li>lv为一 View 为单位. rv 以 ViewHolder 为单位. 设计上 rv 更先进.</li></ol><ul><li>lv对多 type 的缓存机制不太好, 只要被生成 View 都会被缓存起来.<br>eg:当出现大量 type 1 出现以后,在出现大量的 type2, 此时内存中就还有存在大量的 type1和大量的 type2. 而我们现在只有 type2,多余的 type1 一直占有内存不释放..而rv 的滑动时候的缓存是RecycledViewPool +mCachedViews , mCachedViews只有2个,而RecycledViewPool相同 type 最多存储5个.也就像上面的场景, rv 就不会有大量的 type1和 type2 的出现.</li><li>rv 的缓存定制能力更强.你可以自定义一个RecycledViewPool 进去,也能设置mCachedViews 的容量.</li></ul><p>##rv 使用的坑:</p><ol><li>当你的 多type的是个,相同 type 出现在屏幕的数量差值大于5 的时候,并且经常出现的这种情况.比如说你的 type1 这时候在屏幕中是有13个,然后变成3,然后再变成13,这中情况交替出现的时候,会出现频繁的 View 的创建.因为你在13 切换到3 的时候,剩下的10要被缓存起来,但是RecycledViewPool只能缓存5个,mCachedViews最多帮助缓存2个,剩下的 View 就被释放了.当再次切换到13的情况下,就只能创建 View 了,我们可以通过setMaxRecycledViews对RecycledViewPool 缓存最大值的修改.</li></ol><ul><li>出于动画的考量.当你的 数据的改变而你调用notifyItemChanged 的时候.因为此时的 View 被 mChangedScrap 储存.而且mChangedScrap只会在 pre-Layout 中返回,导致你在 real-layout 中得到 View 是一个新的 View, 所以notifyItemChanged 往往导致了一些 View 的创建和界面的图片的闪烁.</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://dim.red&quot;&gt;dim.red&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;lv的缓存&quot;&gt;&lt;a href=&quot;#lv的缓存&quot; class=&quot;headerlink&quot; title=&quot;lv的缓存&quot;&gt;&lt;/a&gt;lv的缓存&lt;/h2&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>自动化打点初探</title>
    <link href="http://dim.red/2016/01/22/automatic_trace/"/>
    <id>http://dim.red/2016/01/22/automatic_trace/</id>
    <published>2016-01-21T16:00:00.000Z</published>
    <updated>2018-08-25T08:43:17.001Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://dim.red">dim.red</a><br>好处:<br>业务逻辑可以和打点逻辑分离.<br>打点更灵活.<br>防止漏打的情况.<br>发包以后可以新增打点:<br><a id="more"></a><br>实现原理:<br>(TalkingData灵动分析技术揭秘（下）)<br><a href="http://www.9miao.com/thread-70467-1-1.html" target="_blank" rel="noopener">http://www.9miao.com/thread-70467-1-1.html</a><br>简单的说:就是给View设置AccessibilityDelegate,而当View 产生了click,long_click 等事件的时候.会在响应原有的Listener方法后.发送消息给<br>AccessibilityDelegate.然后在<code>sendAccessibilityEvent</code>方法下做打点操作.</p><h2 id="设置AccessibilityDelegate"><a href="#设置AccessibilityDelegate" class="headerlink" title="设置AccessibilityDelegate."></a>设置AccessibilityDelegate.</h2><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一:"></a>方法一:</h3><p>在onResume中对activity.getWindow().getDecorView().getRootView()进行向下遍历<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">application.registerActivityLifecycleCallbacks(new Application.ActivityLifecycleCallbacks() &#123;</span><br><span class="line">  @Override</span><br><span class="line">  public void onActivityCreated(Activity activity, Bundle savedInstanceState) &#123;</span><br><span class="line">   </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void onActivityStarted(Activity activity) &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void onActivityResumed(Activity activity) &#123;</span><br><span class="line">    ViewTreeProcess.getInstant().process(activity.getWindow().getDecorView().getRootView());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void onActivityPaused(Activity activity) &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void onActivityStopped(Activity activity) &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void onActivitySaveInstanceState(Activity activity, Bundle outState) &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void onActivityDestroyed(Activity activity) &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h3 id="第2种"><a href="#第2种" class="headerlink" title="第2种:"></a>第2种:</h3><p>拦截LayouInflater 对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/**</span><br><span class="line">* 类:</span><br><span class="line">* Created by dim on 16/1/9.</span><br><span class="line">*/</span><br><span class="line">public class AutoTrackActivity extends AppCompatActivity &#123;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public Object getSystemService(@NonNull String name) &#123;</span><br><span class="line"></span><br><span class="line">    Object object = super.getSystemService(name);</span><br><span class="line">    if (traceEnable() &amp;&amp; object instanceof LayoutInflater) &#123;</span><br><span class="line">      return new TrackLayoutInflater((LayoutInflater) object);</span><br><span class="line">    &#125;</span><br><span class="line">    return object;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public boolean traceEnable() &#123;</span><br><span class="line"></span><br><span class="line">    return false;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>优缺点:<br>第一种对app的浸入性小.只要在Application 注册一下就好了<br>缺点是只遍历activity上面的View, 对类似PopupWindow 和Dialog 这种直接用WindowManger addView 的无能为力.</p><p>第2种对app的浸入性比第一种大,但是并不是并不可接受的.<br>使用AutoTrackActivity 作为activity的基类.或者对getSystemService方法进行拦截.因为要对LayoutInflater 进行代理的.对所有的使用到LayoutInflater的地方都可以覆盖到.像activity,dialog,PopupWindow都有很好的支持.</p><h2 id="定位View"><a href="#定位View" class="headerlink" title="定位View"></a>定位View</h2><p>View 的唯一性.<br>根据context的className+View自身的 Id的String 值.(String 值可以反射R文件得到)+View 的className值确定.<br>当前没有id.向上需要父类的id,如果父类id 没有则记录父类className+getChildAt()值并且继续往上找,直到找到有id的view或者没有父类为止</p><p>##获取额外信息<br>通过给View 设置<code>setTag(int key, final Object tag)</code>.打印的时候获取这个tag,当前view没有,往它的Parent的找.直到没有父控件或者找到tag为止.</p><h2 id="Feature"><a href="#Feature" class="headerlink" title="Feature"></a>Feature</h2><ol><li>配置化打点。</li></ol><ul><li>配置化加点。</li><li>自动获取额外信息。</li><li><del>(已完成)获取fragment信息。</del></li></ul><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>以后把源码放到三帅上面.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://dim.red&quot;&gt;dim.red&lt;/a&gt;&lt;br&gt;好处:&lt;br&gt;业务逻辑可以和打点逻辑分离.&lt;br&gt;打点更灵活.&lt;br&gt;防止漏打的情况.&lt;br&gt;发包以后可以新增打点:&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>android.support.design 学习笔记</title>
    <link href="http://dim.red/2015/11/12/android.support.design_bookmark/"/>
    <id>http://dim.red/2015/11/12/android.support.design_bookmark/</id>
    <published>2015-11-11T16:00:00.000Z</published>
    <updated>2018-11-17T17:57:40.306Z</updated>
    
    <content type="html"><![CDATA[<p>在appcompat 22 的时候,google带来了Support Design,成为实现MD的利器,最近因为要开始使用这个库,稍微过了下库的内容.<br><a id="more"></a></p><p>这次主要通过讲解当前界面是怎么实现的.来学习这个库.<br>布局</p><p><img src="http://upload-images.jianshu.io/upload_images/166866-3fe05924a10c6a35.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="布局"></p><p>看看这个界面的实现,我们主要通过3个方面来了解,</p><ol><li>子控件的宽高的测量   </li></ol><ul><li>子控件的位置摆放</li><li>子控件的事件传递</li></ul><p>##1 测量:<br>因为它们的根控件是CoordinatorLayout .所以我们重点是放在<br>CoordinatorLayout 的onMeasure方法里面:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 省略N多代码</span><br><span class="line">     */</span><br><span class="line">        final Behavior b = lp.getBehavior();</span><br><span class="line">        if (b == null || !b.onMeasureChild(this, child, childWidthMeasureSpec, keylineWidthUsed,</span><br><span class="line">                childHeightMeasureSpec, 0)) &#123;</span><br><span class="line">            onMeasureChild(child, childWidthMeasureSpec, keylineWidthUsed,</span><br><span class="line">                    childHeightMeasureSpec, 0);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 省略N多代码</span><br><span class="line">     */</span><br><span class="line">         </span><br><span class="line">    setMeasuredDimension(width, height);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>子控件的测量交给他们的Behavior,Behavior 不处理,交给CoordinatorLayout处理  ,Behavior 可以在attr中指定. 可以看出ViewPager的Behavior 是AppBarLayout$ScrollingViewBehavior<br>,我们进入ScrollingViewBehavior 中的onMeasureChild方法中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public boolean onMeasureChild(CoordinatorLayout parent, View child,</span><br><span class="line">        int parentWidthMeasureSpec, int widthUsed, int parentHeightMeasureSpec,</span><br><span class="line">        int heightUsed) &#123;</span><br><span class="line">    final int childLpHeight = child.getLayoutParams().height;</span><br><span class="line">    if (childLpHeight == ViewGroup.LayoutParams.MATCH_PARENT</span><br><span class="line">            || childLpHeight == ViewGroup.LayoutParams.WRAP_CONTENT) &#123;</span><br><span class="line">     /**</span><br><span class="line">     * 省略N多代码</span><br><span class="line">     */</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    if (availableHeight == 0) &#123;</span><br><span class="line">       // If the measure spec doesn&apos;t specify a size, use the         current height</span><br><span class="line">         availableHeight = parent.getHeight();</span><br><span class="line">     &#125;</span><br><span class="line">     final int height = availableHeight - header.getMeasuredHeight()</span><br><span class="line">                    + getScrollRange(header);</span><br><span class="line">      final int heightMeasureSpec = View.MeasureSpec.makeMeasureSpec(height,</span><br><span class="line">                    childLpHeight == ViewGroup.LayoutParams.MATCH_PARENT</span><br><span class="line">                            ? View.MeasureSpec.EXACTLY</span><br><span class="line">                            : View.MeasureSpec.AT_MOST);</span><br><span class="line"></span><br><span class="line">            // Now measure the scrolling menu with the correct height</span><br><span class="line">      parent.onMeasureChild(child, parentWidthMeasureSpec,</span><br><span class="line">                    widthUsed, heightMeasureSpec, heightUsed);</span><br><span class="line"></span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看出来当你的ViewPager的高度不设置固定的值得话,他的高度会被ScrollingViewBehavior重新赋值,高度为CoordinatorLayout的高度减去AppBarLayout的可滑动范围.(既getTotalScrollRange())</p><p>可以看出:当前的ViewPager 的高度比我们当前屏幕上看的要高一点.</p><p>AppBarLayout 里面有3个范围比较有意思.<br><code>getTotalScrollRange()</code>:表示总共可以滑动的范围<br>它是计算所有layout_scrollFlags标有scroll 的View 的高度减去所有同时标有scroll 和 exitUntilCollapsed 的 View 的最小高度.</p><p><code>getDownNestedPreScrollRange()</code>:表示当向下滑动可以滑动的范围.<br>它计算了所有layout_scrollFlags同时标记scroll 和 enterAlways 同时不标记 enterAlwaysCollapsed的View 的高度 加上既标记了scroll 和 enterAlways又标记了enterAlwaysCollapsed 的最小高度.<br>产生的效果是:在下滑的过程中AppBarLayout残留在屏幕上的最小高度为 AppBarLayout本身的高度减去getDownNestedPreScrollRange()的高度.</p><p><code>getUpNestedPreScrollRange()</code>:表示当向上滑动可以滑动的范围.<br>这里返回的是getTotalScrollRange().<br>产生的效果是:在上滑的过程中AppBarLayout残留在屏幕上的最小高度为 AppBarLayout本身的高度减去getUpNestedPreScrollRange()的高.</p><p>而这三种范围构成了 AppBarLayout 在 RecyclerView 滑动事件的滑动效果.</p><p>#####主意点:  </p><ol><li>exitUntilCollapsed只有和scroll一起组合才会有效果;</li></ol><ul><li>enterAlwaysCollapsed 要和scroll 和enterAlways一起使用才有效果.</li><li>官方说要把带有scroll flag的view放在前面，这样收回的view才能让正常退出，而固定的view继续留在顶部。<br>那是因为AppBarLayout 是一个 LinearLayout 布局.最后留在屏幕上的东西是 AppBarLayout 的底部,所以需要把要固定的 View 放在最后.</li><li>这里所有的 View 都是 AppBarLayout 的一级 View.二级不太考虑当中,</li></ul><p>下面放出几个例子来加深大家对layout_scrollFlags和3中范围的理解.<br>第一中 正常情况(scroll):<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;android.support.design.widget.AppBarLayout</span><br><span class="line">    android:id=&quot;@+id/appbar&quot;</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">    android:theme=&quot;@style/ThemeOverlay.AppCompat.Dark.ActionBar&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;android.support.v7.widget.Toolbar</span><br><span class="line">        android:id=&quot;@+id/toolbar&quot;</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;100dp&quot;</span><br><span class="line">        android:background=&quot;#f00&quot;</span><br><span class="line">        app:popupTheme=&quot;@style/ThemeOverlay.AppCompat.Light&quot;</span><br><span class="line">        app:layout_scrollFlags=&quot;scroll&quot; /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;android.support.design.widget.TabLayout</span><br><span class="line">        android:id=&quot;@+id/tabs&quot;</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;wrap_content&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;/android.support.design.widget.AppBarLayout&gt;</span><br></pre></td></tr></table></figure></p><p><img src="http://upload-images.jianshu.io/upload_images/166866-44680eb499fbca0e.gif?imageMogr2/auto-orient/strip" alt="demo_0.gif"></p><p>第2种(minHeight +scroll +exitUntilCollapsed)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;android.support.design.widget.AppBarLayout</span><br><span class="line">    android:id=&quot;@+id/appbar&quot;</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">    android:theme=&quot;@style/ThemeOverlay.AppCompat.Dark.ActionBar&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;android.support.v7.widget.Toolbar</span><br><span class="line">        android:id=&quot;@+id/toolbar&quot;</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;100dp&quot;</span><br><span class="line">        android:background=&quot;#f00&quot;</span><br><span class="line">        app:popupTheme=&quot;@style/ThemeOverlay.AppCompat.Light&quot;</span><br><span class="line">        android:minHeight=&quot;20dp&quot;</span><br><span class="line">        app:layout_scrollFlags=&quot;scroll|exitUntilCollapsed&quot; /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;android.support.design.widget.TabLayout</span><br><span class="line">        android:id=&quot;@+id/tabs&quot;</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;wrap_content&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;/android.support.design.widget.AppBarLayout&gt;</span><br></pre></td></tr></table></figure></p><p><img src="http://upload-images.jianshu.io/upload_images/166866-e7cacabb0cd037bd.gif?imageMogr2/auto-orient/strip" alt="demo_1.gif"></p><p>第3种(minHeight +scroll +enterAlways+enterAlwaysCollapsed)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;android.support.design.widget.AppBarLayout</span><br><span class="line">    android:id=&quot;@+id/appbar&quot;</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">    android:theme=&quot;@style/ThemeOverlay.AppCompat.Dark.ActionBar&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;android.support.v7.widget.Toolbar</span><br><span class="line">        android:id=&quot;@+id/toolbar&quot;</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;100dp&quot;</span><br><span class="line">        android:background=&quot;#f00&quot;</span><br><span class="line">        app:popupTheme=&quot;@style/ThemeOverlay.AppCompat.Light&quot;</span><br><span class="line">        android:minHeight=&quot;20dp&quot;</span><br><span class="line">        app:layout_scrollFlags=&quot;scroll|enterAlways|enterAlwaysCollapsed&quot; /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;android.support.design.widget.TabLayout</span><br><span class="line">        android:id=&quot;@+id/tabs&quot;</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;wrap_content&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;/android.support.design.widget.AppBarLayout&gt;</span><br></pre></td></tr></table></figure></p><p><img src="http://upload-images.jianshu.io/upload_images/166866-3fb429866e89ddac.gif?imageMogr2/auto-orient/strip" alt="demo_2.gif"></p><p>##2 位置摆放<br>同样进入CoordinatorLayout 的onLayout方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@Override</span><br><span class="line">protected void onLayout(boolean changed, int l, int t, int r, int b) &#123;</span><br><span class="line">    final int layoutDirection = ViewCompat.getLayoutDirection(this);</span><br><span class="line">    final int childCount = mDependencySortedChildren.size();</span><br><span class="line">    for (int i = 0; i &lt; childCount; i++) &#123;</span><br><span class="line">        final View child = mDependencySortedChildren.get(i);</span><br><span class="line">        final LayoutParams lp = (LayoutParams) child.getLayoutParams();</span><br><span class="line">        final Behavior behavior = lp.getBehavior();</span><br><span class="line"></span><br><span class="line">        if (behavior == null || !behavior.onLayoutChild(this, child, layoutDirection)) &#123;</span><br><span class="line">            onLayoutChild(child, layoutDirection);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>同样可以看到它也是先让Behavior处理.不处理才是CoordinatorLayout自身去处理.<br>同样我们为了查看ViewPager 的摆放,我们进入ScrollingViewBehavior 中的onLayoutChild方法中.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public boolean onLayoutChild(CoordinatorLayout parent, View child, int layoutDirection) &#123;</span><br><span class="line">    // First lay out the child as normal</span><br><span class="line">    super.onLayoutChild(parent, child, layoutDirection);</span><br><span class="line"></span><br><span class="line">    // Now offset us correctly to be in the correct position. This is important for things</span><br><span class="line">    // like activity transitions which rely on accurate positioning after the first layout.</span><br><span class="line">    final List&lt;View&gt; dependencies = parent.getDependencies(child);</span><br><span class="line">    for (int i = 0, z = dependencies.size(); i &lt; z; i++) &#123;</span><br><span class="line">        if (updateOffset(parent, child, dependencies.get(i))) &#123;</span><br><span class="line">            // If we updated the offset, break out of the loop now</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>先调用的父类的onLayoutChild 的方法.然后根据dependencies (其实就是AppBarLayout)的getTopBottomOffsetForScrollingSibling(),其实就是把ViewPager放在AppBarLayout的下方.</p><p>##3 事件传递</p><p>###Touch事件的话<br>CoordinatorLayout是会在onInterceptTouchEvent 对所有的携带Behavior的第一级View 发送通知.如果被哪一个Behavior的onInterceptTouchEvent 的拦截,所以的后续的 Touch动作都分发给这个Behavior.</p><p><img src="http://upload-images.jianshu.io/upload_images/166866-78327a6654ad56c1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="7BE0A9A6-CA47-4FD4-9CFF-6BE1790B86B6.png"></p><p>######注意点:<br>能接受到事件只有第一级的并且携带Behavior的控件.<br>同时这个事件是通知给所有的携带Behavior的控件,也就是说当你的点击事件不在这个 View 的上方,只要这个View 有携带 Behavior 都会收到通知,就是说不管你是点击屏幕上的1还是2,AppBarLayout 都会收到onInterceptTouchEvent事件,所以在复写 Behavior 的onInterceptTouchEvent 要特别注意到这个情况.</p><p>比如说界面一开始往上滑动. 这个时候点击事件是被AppBarLayout的Behavior 拦截的. AppBarLayout的Behavior事件会设置AppBarLayout的setTopAndBottomOffset ,使AppBarLayout产生了往上偏移,所以你可以看到AppBarLayout 往上偏移,那么ViewPager 为啥也向上偏移.因为ViewPager的ScrollingViewBehavior 中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public boolean layoutDependsOn(CoordinatorLayout parent, View child, View dependency) &#123;</span><br><span class="line">    // We depend on any AppBarLayouts</span><br><span class="line">    return dependency instanceof AppBarLayout;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>对AppBarLayout 进行关联,当AppBarLayout 有变化的时候会通知给<br>ScrollingViewBehavior 的onDependentViewChanged 方法中.<br>通过在这个方法中进行对ViewPager的位置也进行偏移.使他们一起往上偏移.所以看起来想两个一起往上偏移,这个也是酷酷的.</p><h3 id="Scroll-事件"><a href="#Scroll-事件" class="headerlink" title="Scroll 事件"></a>Scroll 事件</h3><p>当Touch 事件在ViewPager中. 因为ViewPager中的使用的RecyclerView控件,而RecyclerView 是使用Nest来和其他控件一起处理Scroll事件.RecyclerView 的Nest的事件会一层一层的上传Scroll 事件,被最近的NestedScrollingParent 接受,这里是CoordinatorLayout ,CoordinatorLayout是一个协调者的角色,他将Nest的事件分发给子控件的View的Behavior处理.<br>在这里都会被AppBarLayout的Behavior接受.它会根据getTotalScrollRange,getDownNestedPreScrollRange,getUpNestedPreScrollRange来进行想对应的偏移. 效果在上面已经讲了.</p><p>####关于Nest 来处理 Scroll 事件:<br>当 NestedScrollingChild(下面用Child代替) 要开始滑动的时候会发送 onStartNestedScroll 请求给最近的NestedScrollingParent(下面用Parent代替). 当onStartNestedScroll 返回 true 表示同意一起处理 Scroll 事件的时候时候Child会发送onNestedScrollAccepted 通知 让Parent去做一些准备动作,当Child 要开始滑动的时候,会先发送onNestedPreScroll 请求给Parent ,告诉它我现在要滑动多少米了,你觉得行不行,这时候Parent 根据实际情况告诉Child 现在只允许你滑动多少.然后 Child 根据 onNestedPreScroll 中传递回来的信息对滑动距离做相对应的调整.在滑动的过程中 Child 会发送onNestedScroll通知告知Parent 当前 Child 的滑动情况. 当要进行滑行的时候,会先发送onNestedFling 请求给Parent,告诉它 我现在要滑行了,你说行不行, 这时候Parent会根据情况告诉 Child 你是否可以滑行. Child 通过onNestedFling 返回的 Boolean 值来觉得是否进行滑行.如果要滑行的话,会在滑行的时候发送onNestedFling 通知告知 Parent 滑行情况.当滑动事件结束就会发送onStopNestedScroll 通知 Parent 去做相关操作.</p><p>#####主意点:</p><ol><li>Parent 告知 Child 现在允许你滑动多少是通过<br>onNestedPreScroll中的数组int[] consumed ,consumed[0]表示 Parent 在 X 轴消耗的量, 所以 Child 滑动距离是请求X轴的滑动距离上面减少consumed[0],consumed[1]表示 Y轴上面的消耗.<br>因为consumed是数组,所以Child可以完成可以拿到数据,而不需要onNestedPreScroll 的返回值.</li></ol><ul><li>重点注意讲解中的请求和通知.</li></ul><p>##尾巴<br>详情界面我也大概看了一遍..机制差不多,其实就是多了CollapsingToolbarLayout这个的好玩的控件.所以这个学习笔记不一定有2.呵呵</p><p>同时我会在最近的写一些有意思的 Behavior 出来.</p><p>欢迎大家关注 我的github,我的微博.</p><p><a href="https://github.com/zzz40500/AndroidSweetSheet" target="_blank" rel="noopener">github</a><br><a href="http://weibo.com/u/5579192921/home?wvr=5" target="_blank" rel="noopener">我的新浪</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在appcompat 22 的时候,google带来了Support Design,成为实现MD的利器,最近因为要开始使用这个库,稍微过了下库的内容.&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
