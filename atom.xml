<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>dim&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://dim.red/"/>
  <updated>2019-12-26T13:13:28.038Z</updated>
  <id>http://dim.red/</id>
  
  <author>
    <name>Dim</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>谈 implementation  vs api  maven vs GradleMetadata</title>
    <link href="http://dim.red/2019/12/26/implementation_api_maven_gradle_metadata/"/>
    <id>http://dim.red/2019/12/26/implementation_api_maven_gradle_metadata/</id>
    <published>2019-12-25T16:00:00.000Z</published>
    <updated>2019-12-26T13:13:28.038Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-环境"><a href="#0x00-环境" class="headerlink" title="0x00  环境"></a>0x00  环境</h1><p>Gradle: 4.10.2<br>Android Gradle Plugin: 3.2.0</p><h1 id="0x01-背景"><a href="#0x01-背景" class="headerlink" title="0x01  背景"></a>0x01  背景</h1><p>Android Gradle Plugin 3.0 以后依赖声明使用了 <code>implementation</code> 和 <code>api</code> 来替代原来的 compile 。提供了对依赖进行更细致的控制。<br>这一特性是由 JavaLibraryPlugin 中衍生过来的。 更准确的来说是 JavaBasePlugin 。Android 并不依赖 JavaLibraryPlugin。</p><p>好处:</p><ol><li>隐藏实现细节,  隐藏内部接口。</li><li><p>加快编译速度。</p><p>相关链接: <a href="https://developer.android.com/studio/build/gradle-plugin-3-0-0-migration?hl=zh-cn#new_configurations" target="_blank" rel="noopener">迁移到 Android Plugin for Gradle 3.0.0 - 使用新依赖项配置</a></p><a id="more"></a></li></ol><h1 id="0x02-JavaLibraryPlugin-实现"><a href="#0x02-JavaLibraryPlugin-实现" class="headerlink" title="0x02  JavaLibraryPlugin 实现"></a>0x02  JavaLibraryPlugin 实现</h1><h2 id="2-1-声明方式"><a href="#2-1-声明方式" class="headerlink" title="2.1 声明方式"></a>2.1 声明方式</h2><p>Gradle 是使用 Configuration 表示一组依赖。<br> 如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    compile &apos;com.google.code.gson:gson:2.8.5&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>为名称为 <code>compile</code> 的 <code>Configuration</code> 声明 gson 依赖，版本为 2.8.5。同样的可以为  <code>api</code> ， <code>implementation</code> 或自定义的 <code>Configuration</code> 声明依赖。</p><h2 id="2-2-Configuration"><a href="#2-2-Configuration" class="headerlink" title="2.2 Configuration"></a>2.2 Configuration</h2><p>JavaLibraryPlugin 会生成主要的几个 Configuration：<code>api</code>,<code>compile</code>,<code>compileOnly</code>,<code>compileClasspath (JAVA_API)</code>,<code>implementation</code>,<code>runtime</code>,<code>runtimeOnly</code>,<code>runtimeClasspath (JAVA_RUNTIME)</code>,<code>apiElements (JAVA_API)</code>,<code>runtimeElements (JAVA_RUNTIME_JARS)</code>  .</p><p>Configuration 存在继承关系：</p><ol><li>api 继承 compile</li><li>implementation 继承 compile , api</li><li>compileClasspath 继承  implementation ,  compileOnly</li><li>runtime  继承 compile</li><li>runtimeClasspath  继承  implementation ,  runtime  , runtimeOnly </li><li>apiElements 继承 api</li><li>runtimeElements 继承 runtime ,  runtimeOnly , implementation</li></ol><ul><li>继承： 如果 A 继承了 B。 那么存在在 B 上的依赖。也必将存在 A 上。</li></ul><p>Classpath 类型:<br>compileClasspath runtimeClasspath  总结如下<br><img src="/2019/12/26/implementation_api_maven_gradle_metadata/img1.png" alt="总结1"></p><p>Elements 类型:<br>apiElements runtimeElements 总结如下<br><img src="/2019/12/26/implementation_api_maven_gradle_metadata/img2.png" alt="总结2"><br>这里 Configuration  主要分为 3 种：</p><ol><li>用于声明，不能被解析和获取。如 compile implementation api runtime runtimeOnly 用于声明依赖.</li><li>用于本工程获取消费使用。如 compileClasspath ，runtimeClasspath 用于参与工程的编译或运行。</li><li>提供给其他工程消费使用。如 apiElements<br>runtimeElements 提供其他工程编译或运行时的所需的 ClassPaths。</li></ol><p>JavaLibraryPlugin 将生成的 jar  文件注册在 apiElements 和 runtimeElements 上。<br>将 javac 产生的 class 文件注册在 apiElements  上。注册就能被其他工程通过对应的 Configuration 获取到 。</p><p>主工程通过 compileClasspath (JAVA_API) 可以获取到子工程的 apiElements(JAVA_API)。 同时能获取到子工程的  class 文件以及 apiElements 上的声明依赖（ 来自 api 和 compile 声明）。</p><h5 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h5><p>通过下面例子了解 api 和 implementation 更多的区别：<br><img src="/2019/12/26/implementation_api_maven_gradle_metadata/img3.png" alt="例子">  </p><p>描述: app 用 implementation 方式依赖 lib ，lib 使用 api 方式依赖 libsub1 和 implement 方式依赖了libsub2。 </p><p>以 app 工程 javac task 为例说明:<br>javac task 的实现类 JavaCompile。 该任务将 java 文件编译成 jvm 能执行的 class 。 在这个过程中有两个主要的输入 source 和 classpath。<br>source 是工程中的 java 文件集合。 classpath 是 javac 编译时需要的 class 路径。这里包括 jdk 和工程的依赖 。 依赖的通过 compileClasspath 获取。</p><h6 id="1-隐藏实现细节-隐藏内部接口。"><a href="#1-隐藏实现细节-隐藏内部接口。" class="headerlink" title="1. 隐藏实现细节, 隐藏内部接口。"></a>1. 隐藏实现细节, 隐藏内部接口。</h6><p>compileClasspath 获取链路如下。<br><img src="/2019/12/26/implementation_api_maven_gradle_metadata/img4.png" alt="compileClasspath 获取链路">  </p><p>可知。 app 的  compileClasspath 中只有 lib 和 libsub1 ，libsub2 因为使用 implement 而不出现 app 的编译路径中。<br>这样的好处就是对于 lib 来说，它最小化的对外提供了信息， 屏蔽了 libsub2 的存在。</p><h6 id="2-编译加速。"><a href="#2-编译加速。" class="headerlink" title="2. 编译加速。"></a>2. 编译加速。</h6><p>加速主要是两点</p><p><strong>1. 依托 Gradle 任务的 Task 的 UP-TO-DATE 特性。</strong></p><p>一个任务的输入和输出没有变更。该任务不执行。直接使用上次的输出文件为结果。则该任务为 UP-TO-DATE  。<br>javac 的 classpath 被 <code>@Classpath</code>  和 <code>@CompileClasspath</code> 注解表示。<br>通过之前的文章  <a href="https://dim.red/2018/08/24/gradle_task_UP-TO-DATE/">Gradle Task UP-TO-DATE</a> 可知。在这两个注解下 Gradle 会对 classpath 的 class 文件进行重新排序和 ABI 化。 </p><p>这样的好处在于</p><ol><li>对于 implementation 依赖的 libsub2 发生变更。 如果对 ABI 没有变化。 如修改了方法体或修改私有方法或属性等。只有 libsub2 的 javac task 重新编译。lib 和 app 的 javac task 将跳过执行直接使用上次的输出结果。 </li><li>对于 implementation 依赖的 libsub2 发生变更。 且 ABI  进行了变化。 那么 lib 的 javac task 将重新编译。 app 的 javac task 是否重新编译，取决于  lib 的 ABI 是否发生变化。</li><li>对于 api 依赖的  libsub1 发生变更，如果对 ABI 没有变更。 那么只有libsub1  javac task 重新编译。lib 和 app 的 javac task 使用上次的输出。</li><li>对于 api 依赖的  libsub1 发生变更，如果对 ABI 发生变更。 那么无论如何 libsub1，lib ，app  javac task 都将重新编译。</li></ol><p>通过尽可能的让任务  UP-TO-DATE 减少编译时长。这里所有的优化的都是在增量编译的情况下生效。 </p><p>注：<br> ABI 化: 删除了所有私有的方法和字段。 同时删除了所有方法的方法体。具体可查看 AbiExtractingClasspathResourceHasher<br>ABI 变更：修改，新增，删除了 非私有 方法签名。修改或新增了非私有属性 等都将引起 ABI 变更。</p><p><strong>2 javac  task classpath 的缩减。</strong><br>由于出现的 编译的 classpath 路径减少 ，让 javac 编译时查找对应类减少几次查找从而加快编译速度。 这一块的加速个人感官上是很轻微的。</p><p>总结： implementation 和 api 并不会影响本工程的编译或运行。它只影响本工程对外提供的依赖列表。</p><h1 id="0x03-Android-Gradle-Plugin-实现"><a href="#0x03-Android-Gradle-Plugin-实现" class="headerlink" title="0x03  Android Gradle Plugin 实现"></a>0x03  Android Gradle Plugin 实现</h1><h2 id="3-1-android-工程应用"><a href="#3-1-android-工程应用" class="headerlink" title="3.1 android 工程应用"></a>3.1 android 工程应用</h2><p>Android 在原有的纬度加入了 Flavor 和 BuildType 的纬度。 使复杂层度上了一个台阶。变成了 xxCompile xxApi xxRuntime 。 对于 java 项目而言对外提供两种 Configuration：编译期 apiElements 和 运行期 runtimeElements 各一个。Android 因为存在  Flavor 和 BuildType 。 虽然它对外提供的也是两种 Configuration。 但每种 Configuration 又存在多个变种。默认情况下编译期 debugApiElements 和 releaseApiElements。 运行期 debugRuntimeElements 和 releaseRuntimeElements。加入 flavor 以后复杂度又翻了一倍。 </p><p>在 AGP  2.x 的时候 主工程 BuildType 不管是 Debug 或 Release 默认都使用 Library 的 Release。 3.0 以后开始对这种情况进行优化。Debug  工程引用 Library 的 Debug。Release 工程使用 Library 的 Release 。<br>实现的原理在于为这些提供 apiElements / runtimeElements 的 Configuration 在原有的属性加入了  BuildType 和 Flavor 属性信息。<br>Configuration 在查找的时候，如果只查到一个，检查双方的属性是否相等或相兼容。 检查成功则选择该 Configuration， 如果查询出现多个的时候， 会根据查找的属性的进行选择，找到一个匹配最全的， 如果没有最全的。 则进行择优匹配。对单个属性值根据规则逐一进行比较，丢弃相对较差的 Configuration。 （ 查找的属性+ 候选的属性）。这样如果选择出最合适的一个则选择该Configuration 。否则查找失败。<br>这里涉及到的兼容和择优的规则参考之前 <a href="https://dim.red/2018/01/25/gradle_transform_%20exploration/">Gradle Transform 初探</a> 的文章 rule 相关信息。</p><p>  对于Android  compileClasspath 只参与编译本工程的 java 文件.  最终还需要将 runtimeClasspath 打入 apk 中。<br>Android Configuration 设置详情查看 VariantDependencies<br>Configuration 属性匹配详情查看 ComponentAttributeMatcher</p><h2 id="3-2-隐藏存在的问题。"><a href="#3-2-隐藏存在的问题。" class="headerlink" title="3.2 隐藏存在的问题。"></a>3.2 隐藏存在的问题。</h2><p>Android dependency ‘com.android.support:support-support-v4’ has different version for the compile (25.2.0) and runtime (26.0.0-beta2) classpath. You should manually set the same version via DependencyResolution.<br>一个依赖存在  编译期 和运行期。 不可避免会发生同个依赖在两边的依赖版本不一致的问题。这可能导致 API 的不兼容或 ClassNotFound 等问题。 为此 Android 在 prebuild 会对两个 Configuration 的依赖进行版本比较。</p><p>详情查看 AppPreBuildTask </p><h1 id="0x04-Maven"><a href="#0x04-Maven" class="headerlink" title="0x04 Maven"></a>0x04 Maven</h1><p>Gradle 的依赖分为本地和远程， 本地依赖有本地工程或者本地文件。 远程依赖的有 Maven 和 ivy 依赖。 Gradle 天生支持 Maven 依赖。Gradle 使用 GradlePomModuleDescriptorParser 对 pom 文件进行解析。 pom 文件是 maven 依赖的描述。 主要包括以下几个属性：</p><ol><li>groupId artifactId version: 表示组件的基本信息。</li><li>dependencyManagement: 这个主要是来管理多个 pom 文件的依赖版本问题。dependency 中的依赖没有找到版本或配置。将从这个属性中获取默认的版本和配置。</li><li>dependencies: 表示这个组件的依赖项列表。</li><li>dependency: 包含在dependencies 里。表示其中的一个依赖<br>由 groupId , artifactId , version , scope , classifier , optional , exclusions 等组成。 一个依赖可以存在多个 classifier 。sources ，javadoc 等等。 对于 android 来说，有 debug 和 release 两个 classifier  。</li><li>scope:  表示依赖运作的范围，主要有 compile，runtime，provided，test，  system，import<br>test: 表示仅参与工程测试使用<br>compile: 表示在工程编译中使用。<br>runtime: 表示在仅在工程在运行中使用。<br>provided: 表示仅在工程编译中使用。<br>system: 类似于provided。 不同的是他不需要从远端下载。<br>import: 这里不展开，主要和 dependencyManagement 一起配合使用做版本控制。</li></ol><p>Gradle 为 Maven 依赖提供 10 种 Configuration 来管理。<code>default</code>，<code>master</code>，<code>compile</code>，<code>provided</code>，<code>runtime</code>，<code>test</code>，<code>system</code>，<code>sources</code>，<code>javadoc</code>，<code>optional</code>。  </p><p>详情查看  GradlePomModuleDescriptorBuilder.MAVEN2_CONFIGUR   </p><p> Configuration 对应 Maven 的 scope  ，这里会发现 scope 的种类只有5个 (不包含 import)。 但是Configuration 却有10个这么多。 追其原因这是为了兼容  ivy 格式的依赖。 Maven 依赖列表中不一定都是 Maven 依赖。 也可能是 ivy 依赖。ivy 相关可以查看链接 <a href="http://ant.apache.org/ivy/history/latest-milestone/ivyfile/dependency.html" target="_blank" rel="noopener">ivyfile-dependency</a></p><p>不同的 Configuration 获取的依赖是不同的。 这里不讨论 ivy 的兼容，根据 Maven 的特性介绍几个重要的 Configuration。 </p><ol><li>default: 获取  scope 为的 compile 和 runtime 的依赖。 </li><li>compile: 获取 scope 为的 compile 的依赖。</li><li>runtime: 获取  scope 为的 compile 和 runtime  的依赖</li><li>test: 获取 scope 为的  test  的依赖</li><li>provided: 获取 scope 为的 provided  的依赖。<br>这里仅仅针对声明的一级依赖。 二级依赖（一级依赖的依赖列表）解析就并非如此。</li></ol><p>二级依赖解析规则如下。  compile 获取  scope 为的 compile 的依赖。其他均获取  scope 为的 compile 和 runtime  的依赖。  scope 非  compile /runtime  均会被忽略。或许设计便是如此。<br>详情查看 MavenDependencyDescriptor.selectLegacyConfigurations</p><p>注意 本小节的 Configuration 不等于的 Gradle 的 Configuration。</p><h4 id="Configuration-的使用"><a href="#Configuration-的使用" class="headerlink" title="Configuration 的使用"></a>Configuration 的使用</h4><p>1.默认 Configuration</p><p>默认 Configuration 为 default 。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compile &quot;com.dim:lib:1.0&quot;</span><br></pre></td></tr></table></figure></p><p>等价<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compile (group: &apos;com.dim&apos;, name: &apos;lib&apos;, version: &apos;1.0&apos;,configuration:&quot;defalut&quot;)</span><br></pre></td></tr></table></figure></p><p>2.实现 implementation，api 的效果</p><p>Maven 的 scope 存在 rumtime 和 compile 。 应对到 Gradle 的 apiElements 和 runtimeElements 。</p><p>java 工程<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">api / implementation project(&quot;:dim&quot;)</span><br></pre></td></tr></table></figure></p><p>替换<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">api / implementation (group: &apos;com.dim&apos;, name: &apos;lib&apos;, version: &apos;1.0&apos;,configuration:&quot;compile&quot;)</span><br><span class="line">runtime (group: &apos;com.dim&apos;, name: &apos;lib&apos;, version: &apos;1.0&apos;,configuration:&quot;runtime&quot;)</span><br></pre></td></tr></table></figure></p><p>Android 工程<br>因为 Android 存在 debug 和 release ，所以较为复杂，debug / release在 maven 中以 classifier 的形式存在。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">debugApi / debugImplementation (group: &apos;com.dim&apos;, name: &apos;lib&apos;, version: &apos;1.0&apos;,classifier: &apos;debug&apos;, configuration:&quot;compile&quot;)</span><br><span class="line">debugRuntime (group: &apos;com.dim&apos;, name: &apos;lib&apos;, version: &apos;1.0&apos;,classifier: &apos;debug&apos;,configuration:&quot;runtime&quot;)</span><br><span class="line">releaseApi / releaseImplementation (group: &apos;com.dim&apos;, name: &apos;lib&apos;, version: &apos;1.0&apos;,classifier: &apos;release&apos;, configuration:&quot;compile&quot;)</span><br><span class="line">releaseRuntime (group: &apos;com.dim&apos;, name: &apos;lib&apos;, version: &apos;1.0&apos;,classifier: &apos;release&apos;,configuration:&quot;runtime&quot;)</span><br></pre></td></tr></table></figure></p><p>android 上的实现略显臃肿，有什么办法解决呢？ Gradle Metadata ？</p><h1 id="0x05-Gradle-Metadata"><a href="#0x05-Gradle-Metadata" class="headerlink" title="0x05 Gradle Metadata"></a>0x05 Gradle Metadata</h1><p>为了弥补 Maven 的局限， Gradle 引入 Gradle  Metadata。<br>它在原有的基础上加入  .module 文件来扩展 Maven 的 pom 功能。<br>这里去掉了 Scope 的概念，转为 Variant 。对 pom 依赖进行重新组合。 一组依赖就是一个 Variant 。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;formatVersion&quot;: &quot;0.4&quot;,</span><br><span class="line">  &quot;component&quot;: &#123;</span><br><span class="line">    &quot;group&quot;: &quot;com.dim&quot;,</span><br><span class="line">    &quot;module&quot;: &quot;lib&quot;,</span><br><span class="line">    &quot;version&quot;: &quot;1.0&quot;,</span><br><span class="line">    &quot;attributes&quot;: &#123;</span><br><span class="line">      &quot;org.gradle.status&quot;: &quot;release&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;createdBy&quot;: &#123;</span><br><span class="line">    &quot;gradle&quot;: &#123;</span><br><span class="line">      &quot;version&quot;: &quot;4.10.2&quot;,</span><br><span class="line">      &quot;buildId&quot;: &quot;priv3n7sd5bvbpnahf26lakzju&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;variants&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;name&quot;: &quot;debugApiElements&quot;,</span><br><span class="line">      &quot;attributes&quot;: &#123;</span><br><span class="line">        &quot;com.android.build.api.attributes.BuildTypeAttr&quot;: &quot;debug&quot;,</span><br><span class="line">        &quot;com.android.build.api.attributes.VariantAttr&quot;: &quot;debug&quot;,</span><br><span class="line">        &quot;com.android.build.gradle.internal.dependency.AndroidTypeAttr&quot;: &quot;Aar&quot;,</span><br><span class="line">        &quot;org.gradle.usage&quot;: &quot;java-api&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">        &quot;dependencies&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;group&quot;: &quot;com.google.code.gson&quot;,</span><br><span class="line">          &quot;module&quot;: &quot;gson&quot;,</span><br><span class="line">          &quot;version&quot;: &#123;</span><br><span class="line">            &quot;requires&quot;: &quot;2.8.5&quot;,</span><br><span class="line">            &quot;reject&quot;: &quot;2.7.0&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      &quot;files&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;name&quot;: &quot;lib-debug.aar&quot;,</span><br><span class="line">          &quot;url&quot;: &quot;lib-debug.aar&quot;,</span><br><span class="line">          &quot;size&quot;: 21590,</span><br><span class="line">          &quot;sha1&quot;: &quot;afafefc0dccfcfb0246dc9201868e12e83df04ac&quot;,</span><br><span class="line">          &quot;md5&quot;: &quot;7374a663e6ba72a82ba767f92a2bf810&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">    .</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这是一个 Variant 的描述。<br>.module 文件生成和解析查看<br>ModuleMetadataFileGenerator.generateTo()<br>ModuleMetadataParser.parse()</p><p>Variant 几乎是 Gradle Configuration 的翻译。它甚至可以指定版本约束，如拒绝某个依赖版本。Metadata 可以和 Gradle 的 Configuration 系统做完美的结合。 实现了依赖 Project 是什么样子，依赖 Project 生成的 Gradle Metadata 便是什么样子。</p><p>Gradle Metadata 只是一个 Gradle 的改进。 对于 Maven 发布的时候，不仅 .module 存在， pom 文件也会被保留。 这样的好处是当 Gradle Metadata  不兼容的情况下使用 pom 文件进行降级。同时不影响其他编译工具对 Maven 的支持。</p><h2 id="5-1-使用"><a href="#5-1-使用" class="headerlink" title="5.1 使用"></a>5.1 使用</h2><h3 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">enableFeaturePreview(&quot;GRADLE_METADATA&quot;)</span><br></pre></td></tr></table></figure><p>全局启用了 GRADLE_METADATA 特性，该特性会为所有仓库会先检查是否存在 .module。 查询失败降级查询 pom 文件。java 工程原生支持 Gradle Metadata。Gradle 6.0 以下在该特性下 使用 maven-publish 插件发布的时候自动会带上 .module 信息。6.0 默认自动带上.module  文件。</p><h3 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h3><p>由于并不不是所有仓库都支持 Gradle Metadata 。所有仓库都先查询一遍 module ，这或许过于浪费。可以为单一的仓库设置。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">repositories &#123;</span><br><span class="line">    maven &#123;</span><br><span class="line">        url = &quot;xxx&quot;</span><br><span class="line">        metadataSources(&#123;</span><br><span class="line">            it.gradleMetadata()</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>有了 Gradle Metadata 加持下。 可以很方便的实现 类似 implementation  和 api 的效果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">api / implementation project(&quot;:dim&quot;)</span><br></pre></td></tr></table></figure></p><p>等价<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">api / implementatio &quot;com.dim:lib:1.0&quot;</span><br></pre></td></tr></table></figure></p><p>Gradle Metadata  在当前的环境下并非没有缺点</p><ol><li>当前4.10.2的 Gradle Metadata 以一个 feature 的形式存在。 并不直接提供这些功能，在 6.0 才正式完整支持。</li><li>当前版本 .module 文件格式并不稳定，4.10.2 的版本为 0.4 。 6.0 的版本为1.1。 不同版本并不能兼容使用。</li><li>内部 API  。如果要自定义这个特性。 需要继承 SoftwareComponentInternal 。 它位于 org.gradle.api.internal.component。 还未正式放出来。 即使是 6.0 也存在这个问题。对于 Android 就更为苛刻。</li><li>发布插件。Gradle 默认提供两种发布插件 maven 和 maven-publish 。 这个特性当前只存在 maven-publish。 android 默认情况下只支持 maven 。  </li><li>依赖 classifier  丢失。<br>Maven 支持一个依赖存在多个 classifier。 Gradle Metadata 在写入的时候会丢失这部分信息。 这是当前使用唯一遇到的天坑，该错误在8月份被修复，mr <a href="https://github.com/gradle/gradle/issues/10189" target="_blank" rel="noopener">Publish classifier/artifact selection to GMM</a> 在  6.0 RC1 合入。 同时也被带入到 6.0 正式版本中。现阶段提供一个兼容方案。 不直接依赖存在 classifier 的依赖。依赖一个中间依赖。 中间依赖再依赖这个  classifier 的依赖。 中间依赖使用 pom 文件， 不使用 .module。用这种方案来规避 Metadata 序列化的 bug 。</li><li>成本提高。<br>对依赖更细致的控制。学习成本变高，对于开发人员素质要求变高。<br>更多 Gradle Metadata 细节查看  <a href="https://blog.gradle.org/gradle-metadata-1.0" target="_blank" rel="noopener">Introducing Gradle Module Metadata</a> 。</li></ol><p>Gradle 觉得 Metadata 可以帮我们逃离依赖地狱。 或许可以或许通往另外一个地狱。</p><h1 id="0x06-总结"><a href="#0x06-总结" class="headerlink" title="0x06 总结"></a>0x06 总结</h1><p>国内网络上对于 Gradle Metadata 这块的几乎没有涉及。一个 feature 存在 4.10.2 甚至更早。在 5.3 正式发布了 1.0 版本。但是国内这块的涉及几乎没有，这是非常可惜的。</p><p>Gradle 提供的功能或多或少都存在一些 Bug，尽管有这么多个缺陷。但是这个特性确实让人兴奋。 我们只希望 Gradle 6.0 尽快到来。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;0x00-环境&quot;&gt;&lt;a href=&quot;#0x00-环境&quot; class=&quot;headerlink&quot; title=&quot;0x00  环境&quot;&gt;&lt;/a&gt;0x00  环境&lt;/h1&gt;&lt;p&gt;Gradle: 4.10.2&lt;br&gt;Android Gradle Plugin: 3.2.0&lt;/p&gt;
&lt;h1 id=&quot;0x01-背景&quot;&gt;&lt;a href=&quot;#0x01-背景&quot; class=&quot;headerlink&quot; title=&quot;0x01  背景&quot;&gt;&lt;/a&gt;0x01  背景&lt;/h1&gt;&lt;p&gt;Android Gradle Plugin 3.0 以后依赖声明使用了 &lt;code&gt;implementation&lt;/code&gt; 和 &lt;code&gt;api&lt;/code&gt; 来替代原来的 compile 。提供了对依赖进行更细致的控制。&lt;br&gt;这一特性是由 JavaLibraryPlugin 中衍生过来的。 更准确的来说是 JavaBasePlugin 。Android 并不依赖 JavaLibraryPlugin。&lt;/p&gt;
&lt;p&gt;好处:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;隐藏实现细节,  隐藏内部接口。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;加快编译速度。&lt;/p&gt;
&lt;p&gt;相关链接: &lt;a href=&quot;https://developer.android.com/studio/build/gradle-plugin-3-0-0-migration?hl=zh-cn#new_configurations&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;迁移到 Android Plugin for Gradle 3.0.0 - 使用新依赖项配置&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>记 Scrcpy 框架使用记录</title>
    <link href="http://dim.red/2019/03/03/scrcpy_usage/"/>
    <id>http://dim.red/2019/03/03/scrcpy_usage/</id>
    <published>2019-03-02T16:00:00.000Z</published>
    <updated>2019-05-29T03:10:44.503Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>最近使用 vysor 。发现直接把手机当成模拟器操作确实是方便到不行。 但是魅族 16th plus 在 vysor 失效了。同时vysor 通知太过干扰。基于以上两点切换到开源框架 <a href="https://github.com/Genymobile/scrcpy" target="_blank" rel="noopener">scrcpy: Display and control your Android device</a></p><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>  <img src="/2019/03/03/scrcpy_usage/scrcpy.png" alt="image.png"><br>主要步骤如下：<br><a id="more"></a></p><ol><li>通过 <code>adb push</code> 一个 <code>scrcpy-server.jar</code>  到手机上。<br>注： scrcpy-server.jar 是虽然是一个 zip 文件。 但是其实是一个apk。</li><li>PC 端通过  <code>adb reverse</code> 反向代理手机端口。用来接收手机端发送过来的数据。</li><li><code>adb shell CLASSPATH=/data/local/tmp/scrcpy-server.jar app_process /com.genymobile.scrcpy.Server com.genymobile.scrcpy.Server 0 8000000 false - false</code> 使用 app_process 运行 scrcpy-server.jar  的代码。<br>scrcpy-server.jar 主要做三件事情：<br>1，开启 LocalSocket 和PC连接。 相应 PC 端传递过来的操作。<br>2，源源不断的将屏幕画面输出到PC，使用Mediacodec 编码。 PC 通过ffmpeg 解码播放。<br>3，使用 adb 来提高 scrcpy-server.jar 的运行权限<br>注： 模拟 input 事件使用 android.hardware.input.IInputManager.injectInputEvent 方法。</li></ol><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>mac 环境下使用  <code>brew install scrcpy</code> ，通过漫长的等待完成安装。同时设置adb 环境变量。这里不具体展开。运行 <code>scrcpy</code> 命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scrcpy</span><br></pre></td></tr></table></figure></p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>魅族16 th 出现了错误：<br><img src="/2019/03/03/scrcpy_usage/scrcpy_16_ex.png" alt="image.png"><br>通过scrcpy 的issue 发现这是一个已知的问题 <a href="https://github.com/Genymobile/scrcpy/issues/365" target="_blank" rel="noopener">#365 startsWith() on null object at ScreenEncoder.java:158 </a><br><img src="/2019/03/03/scrcpy_usage/scrcpy_github.png" alt="image.png"><br>同样发生在魅族 16th 的机型上。 可以确定是因为魔改 Android 源码导致。 可以相信这个 BUG 将会存在很长一段时间。 那么我们尝试自己动手一下。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>这是一个空指针异常， 空指针是最常见也是最简单的一个bug。 我们需要拿到系统的代码进行分析。</p><h2 id="获取-android-media-MediaCodec-源码"><a href="#获取-android-media-MediaCodec-源码" class="headerlink" title="获取 android.media.MediaCodec 源码"></a>获取 android.media.MediaCodec 源码</h2><p>获取系统的代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb pull /system/framework/arm/boot-framework.oat</span><br></pre></td></tr></table></figure></p><p>使用 <a href="https://github.com/JesusFreke/smali" target="_blank" rel="noopener">baksmali</a> 反编译oat：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar baksmali-2.2.6.jar deodex  /boot-framework.oat</span><br></pre></td></tr></table></figure></p><p>得到系统代码的 smali 。 找到 MediaCodec  的 smali 的1918行</p><p><strong>注</strong>：<br>反编译方式 在 8.1 上 baksmali 会失败， 可以尝试 <a href="https://github.com/anestisb/vdexExtractor" target="_blank" rel="noopener">vdexExtractor</a> 从 vdex 获取 dex 文件。在对dex 进行反解得到代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">.method private configure(Landroid/media/MediaFormat;Landroid/view/Surface;Landroid/media/MediaCrypto;Landroid/os/IHwBinder;I)V</span><br><span class="line">    .registers 19</span><br><span class="line">    .param p1, &quot;format&quot;    # Landroid/media/MediaFormat;</span><br><span class="line">    .param p2, &quot;surface&quot;    # Landroid/view/Surface;</span><br><span class="line">    .param p3, &quot;crypto&quot;    # Landroid/media/MediaCrypto;</span><br><span class="line">    .param p4, &quot;descramblerBinder&quot;    # Landroid/os/IHwBinder;</span><br><span class="line">    .param p5, &quot;flags&quot;    # I</span><br><span class="line">    ...</span><br><span class="line">    .line 1918</span><br><span class="line">    .local v2, &quot;values&quot;:[Ljava/lang/Object;</span><br><span class="line">    invoke-static &#123;&#125;, Landroid/app/ActivityThread;-&gt;currentPackageName()Ljava/lang/String;</span><br><span class="line"></span><br><span class="line">    move-result-object v0</span><br><span class="line"></span><br><span class="line">    const-string/jumbo v3, &quot;com.tencent.mm&quot;</span><br><span class="line"></span><br><span class="line">    invoke-virtual &#123;v0, v3&#125;, Ljava/lang/String;-&gt;startsWith(Ljava/lang/String;)Z</span><br><span class="line"></span><br><span class="line">    move-result v0</span><br><span class="line"></span><br><span class="line">    if-eqz v0, :cond_23</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里使用 ActivityThread.currentPackageName() 获取包名与 微信的包名做比较。<br>通过分析可以发现  ActivityThread.currentPackageName() 返回为 null 导致的空指针异常。 </p><h3 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h3><p>ActivityThread.currentPackageName() 为空？<br>正确情况 APP 启动的流程如下：AMS 调用<br> <code>Process.start(&quot;android.app.ActivityThread&quot;,                        app.processName, uid, uid...)</code> 通知 zygote 进程 fork 出一个新的进程同时执行 <code>android.app.ActivityThread.main(String[] args)</code> 方法。<br> main方法会初始化 ActivityThread 和初始化主线程Looper。同时调用 ActivityThread.attach()方法，会将 binder 类型 ApplicationThread  对象传递给 ActivityMangerService 。ASM 获取到 ApplicationThread 以后会查询对应的信息(包括 PackageName)， 会通过 ApplicationThread 以 IPC 的方式将信息回调给  ActivityThread,bindApplication 方法. app bindApplication 方法以后才知道自己的包名。在至此 ActivityThread.currentPackageName()  不为空。<br>App 运行在 fork  zygote 的子进程中。<br>而 Scrcpy 是通过 app_process 启动非 zygote 的 Runtime 进程中。</p><h2 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static String currentPackageName() &#123;</span><br><span class="line">       ActivityThread am = currentActivityThread();</span><br><span class="line">       return (am != null &amp;&amp; am.mBoundApplication != null)</span><br><span class="line">           ? am.mBoundApplication.appInfo.packageName : null;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>最初方式是使用 xposed hook 该方法。 对空值进行防护。这样就不用管 ActivityThread 后续可能的魔改。<br>但是Xposed 默认不对非 zygote 进行进行拦截。<br><code>isXposedLoaded = xposed::initialize(zygote, startSystemServer, className, argc, argv)</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/** Initialize Xposed (unless it is disabled). */</span><br><span class="line">bool initialize(bool zygote, bool startSystemServer, const char* className, int argc, char* const argv[]) &#123;</span><br><span class="line">#if !defined(XPOSED_ENABLE_FOR_TOOLS)</span><br><span class="line">    if (!zygote)</span><br><span class="line">        return false;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    if (isMinimalFramework()) &#123;</span><br><span class="line">        ALOGI(&quot;Not loading Xposed for minimal framework (encrypted device)&quot;);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>求其次使用最简单的方案: 反射</p><p>只要 currentActivityThread ，mBoundApplication ，appInfo，packageName 不为空，ActivityThread.currentPackageName()  返回不为空。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"> try &#123;</span><br><span class="line">            Class&lt;?&gt; ActivityThreadClass = Class.forName(&quot;android.app.ActivityThread&quot;);</span><br><span class="line">            Method currentPackageName = ActivityThreadClass.getMethod(&quot;currentPackageName&quot;);</span><br><span class="line">            currentPackageName.setAccessible(true);</span><br><span class="line">            Field sCurrentActivityThread = ActivityThreadClass.getDeclaredField(&quot;sCurrentActivityThread&quot;);</span><br><span class="line">            Field mBoundApplication = ActivityThreadClass.getDeclaredField(&quot;mBoundApplication&quot;);</span><br><span class="line"></span><br><span class="line">            sCurrentActivityThread.setAccessible(true);</span><br><span class="line">            mBoundApplication.setAccessible(true);</span><br><span class="line"></span><br><span class="line">            Constructor&lt;?&gt; constructor = ActivityThreadClass.getDeclaredConstructor();</span><br><span class="line">            constructor.setAccessible(true);</span><br><span class="line">//            sCurrentActivityThread.set(null, UnsafeAllocator.create().newInstance(ActivityThreadClass));</span><br><span class="line">            sCurrentActivityThread.set(null, constructor.newInstance());</span><br><span class="line">            Object sCurrentActivityThreadObject = sCurrentActivityThread.get(null);</span><br><span class="line"></span><br><span class="line">            Class&lt;?&gt; AppBindDataClass = Class.forName(&quot;android.app.ActivityThread$AppBindData&quot;);</span><br><span class="line">            Field appInfo = AppBindDataClass.getDeclaredField(&quot;appInfo&quot;);</span><br><span class="line">            appInfo.setAccessible(true);</span><br><span class="line">            Constructor&lt;?&gt; constructor1 = AppBindDataClass.getDeclaredConstructor();</span><br><span class="line">            constructor1.setAccessible(true);</span><br><span class="line">            Object AppBindDataObject = constructor1.newInstance();</span><br><span class="line">            ApplicationInfo applicationInfo = new ApplicationInfo();</span><br><span class="line">            applicationInfo.packageName = &quot;com.dim&quot;;</span><br><span class="line">            appInfo.set(AppBindDataObject, applicationInfo);</span><br><span class="line">            mBoundApplication.setAccessible(true);</span><br><span class="line">            mBoundApplication.set(sCurrentActivityThreadObject, AppBindDataObject);</span><br><span class="line">        &#125; catch (Throwable throwable) &#123;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p><p>我们需要将代码插入到 <a href="https://github.com/Genymobile/scrcpy/blob/master/server/src/main/java/com/genymobile/scrcpy/Server.java" target="_blank" rel="noopener">com.genymobile.scrcpy.Server</a> 的<br> <code>main</code> 方法中。 将编译好的 apk 重新命令 <code>scrcpy-server.jar</code>  替换目录 <code>/usr/local/Cellar/scrcpy/1.7/share/scrcpy/scrcpy-server.jar:</code> 这是mac 下的地方。其他可能会有不同。<br>同时还需要做的事情是<br>初始化 Looper 因为 ActivityThread 中的 H 是个Handler。 Handler 的初始化需要Looper 环境。<br>至此对于 魅族16 th 在 Scrcpy 的改造完成。<br><img src="/2019/03/03/scrcpy_usage/scrcpy_16_success.png" alt="image.png"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这篇主要介绍了 Scrcpy 框架的主要原理。 以及如何反编译系统的代码。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;最近使用 vysor 。发现直接把手机当成模拟器操作确实是方便到不行。 但是魅族 16th plus 在 vysor 失效了。同时vysor 通知太过干扰。基于以上两点切换到开源框架 &lt;a href=&quot;https://github.com/Genymobile/scrcpy&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;scrcpy: Display and control your Android device&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;原理&quot;&gt;&lt;a href=&quot;#原理&quot; class=&quot;headerlink&quot; title=&quot;原理&quot;&gt;&lt;/a&gt;原理&lt;/h1&gt;&lt;p&gt;  &lt;img src=&quot;/2019/03/03/scrcpy_usage/scrcpy.png&quot; alt=&quot;image.png&quot;&gt;&lt;br&gt;主要步骤如下：&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ProGuard 初探</title>
    <link href="http://dim.red/2019/01/28/proguard_exploration/"/>
    <id>http://dim.red/2019/01/28/proguard_exploration/</id>
    <published>2019-01-27T16:00:00.000Z</published>
    <updated>2019-12-26T12:59:09.461Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-环境"><a href="#0x00-环境" class="headerlink" title="0x00  环境"></a>0x00  环境</h1><p>版本：<a href="https://sourceforge.net/p/proguard/code/ci/proguard6.0.3/tree/" target="_blank" rel="noopener">6.0.3</a><br>使用文档：<a href="https://www.guardsquare.com/en/products/proguard/manual/usage" target="_blank" rel="noopener">usage</a></p><h1 id="0x01-ProGuard-总览"><a href="#0x01-ProGuard-总览" class="headerlink" title="0x01 ProGuard 总览"></a>0x01 ProGuard 总览</h1><p>ProGuard 是 java 字节码优化工具， 广泛运用到 Java 和 Android 项目中。可以有效的减少程序的大小，提高运行效率，提高逆向分析的成本。<br><img src="/2019/01/28/proguard_exploration/proguard_01.png" alt="ProGuard 运行过程"><br>Proguard 优化主要分为四个阶段:<br>Shrink , Optimize, Obfuscate , Preverify 四个阶段</p><ul><li>Shrink: 删除没有被使用的类和方法。</li><li>Optimize: 对代码指令进行优化。</li><li>Obfuscate: 对代码名称进行混淆。</li><li>Preverify: 对 class 进行预校验，校验  StackMap /StackMapTable 属性。</li></ul><p>四个阶段可以独立运行的，默认全部开启，可以通过配置 <code>-dontshrink</code>，<code>-dontoptimize</code>，<code>-dontobfuscate</code>，<code>-dontpreverify</code> 关闭对应的阶段.</p><p>注： ProGuard 处理 class 。class 文件可以由 <a href="http://jikes.sourceforge.net/" target="_blank" rel="noopener">jikes</a>  或  <a href="https://docs.oracle.com/javase/6/docs/technotes/tools/windows/javac.html" target="_blank" rel="noopener">javac</a> 或 Kotlin 生成，  ProGuard 会根据 javac 和 jikes 特性做针对性优化。<br><a id="more"></a></p><h1 id="0x02-ProGuard-处理过程"><a href="#0x02-ProGuard-处理过程" class="headerlink" title="0x02 ProGuard 处理过程"></a>0x02 ProGuard 处理过程</h1><p><img src="/2019/01/28/proguard_exploration/proguard_02.png" alt="ProGuard 处理过程"></p><h2 id="1-Configuration-Parse"><a href="#1-Configuration-Parse" class="headerlink" title="1. Configuration Parse"></a>1. Configuration Parse</h2><h3 id="1-1-过程"><a href="#1-1-过程" class="headerlink" title="1.1 过程"></a>1.1 过程</h3><p>将 ProguardFile 文件编写的规则解析成 Configuration 配置.</p><h3 id="1-2-常用的参数"><a href="#1-2-常用的参数" class="headerlink" title="1.2 常用的参数"></a>1.2 常用的参数</h3><h5 id="keepattributes"><a href="#keepattributes" class="headerlink" title="keepattributes"></a>keepattributes</h5><p><strong>-keepattributes</strong>  [<em><a href="https://www.guardsquare.com/en/products/proguard/manual/attributes" target="_blank" rel="noopener">attribute_filter</a></em>]<br>保留类或方法或字段中 Attributes 属性.  <a href="https://docs.oracle.com/javase/specs/jvms/se10/html/jvms-4.html#jvms-4.7" target="_blank" rel="noopener">Attributes</a> 存在多种类型. 类型如下:<br><img src="/2019/01/28/proguard_exploration/proguard_03.png" alt="Attributes"><br>ProGuard 支持 Java 1-10 定义的所有的 Attributes。<br>为了保证程序能正常运行需要保留了部分属性：<code>ConstantValue</code>，<code>Code</code> , <code>BootstrapMethods</code>。其余属性均可被删除.<br><code>ConstantValue</code>: 用于 final 修饰的 基本类型 或 String 类型字段，指向字段的初始值。<br><code>Code</code>：指向当前方法的代码指令。<br><code>BootstrapMethods</code>：和 <code>invokedynamic</code> 指令相配合实现动态调用方法。 例如 java 8 的 lambda。 </p><p>ProGuard 的 Attributes 是在 <code>Obfuscate</code> 阶段执行。如果想该配置生效需要开启 <code>Obfuscate</code> .</p><h5 id="Keep-Option"><a href="#Keep-Option" class="headerlink" title="Keep Option"></a>Keep Option</h5><p>Keep Option 会应用在所有优化阶段，主要分为三种情况。其余情况均是这三种情况的衍生。</p><p><strong>-keep</strong> [<a href="https://www.guardsquare.com/proguard/manual/usage#keepoptionmodifiers" target="_blank" rel="noopener">,<em>modifier</em></a>,…] <a href="https://www.guardsquare.com/proguard/manual/usage#classspecification" target="_blank" rel="noopener"><em>class_specification</em></a><br>Keep 类限定下的类。 同时 Keep 该类下 成员限定 的方法或字段。<br><strong>-keepclassmembers</strong> [<a href="https://www.guardsquare.com/proguard/manual/usage#keepoptionmodifiers" target="_blank" rel="noopener">,<em>modifier</em></a>,…] <a href="https://www.guardsquare.com/proguard/manual/usage#classspecification" target="_blank" rel="noopener"><em>class_specification</em></a><br> Keep 类限定 下的 成员限定 的方法或字段 。不 Keep 类限定  的类。<br><strong>-keepclasseswithmembers [</strong><a href="https://www.guardsquare.com/proguard/manual/usage#keepoptionmodifiers" target="_blank" rel="noopener">,<em>modifier</em></a>,…] <a href="https://www.guardsquare.com/proguard/manual/usage#classspecification" target="_blank" rel="noopener"><em>class_specification</em></a><br>如果 类限定 和 成员限定 都存在， 那么 Keep 类 和 成员限定。</p><p>Keep 在不同阶段的含义不同: 在<code>Shrink</code>阶段为成员和类不被删除, 在<code>Optimize</code> 阶段为类和成员内部的指令不被优化. <code>Obfuscate</code>阶段为类和成员的名称不被混淆.</p><p>class_specification<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[@annotationtype] [[!]public|final|abstract|@ ...] [!]interface|class|enum classname</span><br><span class="line">    [extends|implements [@annotationtype] classname]</span><br><span class="line">[&#123;</span><br><span class="line">    [@annotationtype] [[!]public|private|protected|static|volatile|transient ...] &lt;fields&gt; |</span><br><span class="line">                                                                      (fieldtype fieldname);</span><br><span class="line">    [@annotationtype] [[!]public|private|protected|static|synchronized|native|abstract|strictfp ...] &lt;methods&gt; |</span><br><span class="line">                                                                                           &lt;init&gt;(argumenttype,...) |</span><br><span class="line">                                                                                           classname(argumenttype,...) |</span><br><span class="line">                                                                                           (returntype methodname(argumenttype,...));</span><br><span class="line">    [@annotationtype] [[!]public|private|protected|static ... ] *;</span><br><span class="line">    ...</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure></p><p>简化<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">类限定&#123;</span><br><span class="line">    成员限定[]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>类限定： 通过 注解，accessFlags，包名，类名， 父类，签名，接口等信息指定规则。 </li><li>成员限定：成员有两种 字段和方法。<br>字段通过 注解，accessFlags ，字段名，描述符，签名等信息。<br>方法通过 注解，accessFlags， 方法名，参数，描述符，签名等信息。</li></ul><p>默认情况下 Keep Option 将应用到 ’ Shrink‘，’ Optimize‘，’ Obfuscate‘ 三个阶段。ProGuard 支持更为细致的控制。通过 <code>modifier</code> 来控制。</p><table><thead><tr><th>keep</th><th>modifier</th><th>作用</th></tr></thead><tbody><tr><td></td><td>allowshrinking</td><td>该 keep 选项不在 <code>Shrink</code> 阶段生效</td></tr><tr><td></td><td>allowoptimization</td><td>该 keep 选项不在 <code>Optimize</code> 阶段生效</td></tr><tr><td></td><td>allowobfuscation</td><td>该 keep 选项不在 <code>Obfuscate</code> 阶段生效</td></tr></tbody></table><h5 id="KeepNames-Option"><a href="#KeepNames-Option" class="headerlink" title="KeepNames Option"></a>KeepNames Option</h5><p>keepnames   等价于 keep,allowshrinking.<br>这里通过比较 keep  和 keepnames 来理解二者的区别.</p><table><thead><tr><th>keep option</th><th>描述</th></tr></thead><tbody><tr><td>-keep class_specification</td><td><code>类限定</code> 和<code>成员限制</code> 不被删除.同时 <code>类限定</code>和<code>成员限制</code> 名称不被混淆</td></tr><tr><td>-keepnames class_specification</td><td><code>类限定</code>和 <code>限定成员</code> 名称不被混淆, 不保证<code>类限定</code>和<code>成员限制</code>是否被删除</td></tr><tr><td>-keepclassmembers class_specification</td><td><code>类限定</code> 和<code>成员限制</code>  不被删除.同时 <code>成员限制</code> 的名称不被混淆</td></tr><tr><td>-keepclassmembernames class_specification</td><td><code>成员限制</code> 的名称不被混淆, 不保证他们是否被删除</td></tr><tr><td>-keepclasseswithmembers  class_specification</td><td>如果 <code>类限定</code> 和<code>成员限制</code> 都存在, 那么<code>类限定</code> 和<code>成员限制</code>  不被删除. 同时他们的名称不被混淆</td></tr><tr><td>-keepclasseswithmembernames  class_specification</td><td>如果<code>类限定</code> 和<code>成员限制</code> 都存在, 那么<code>类限定</code> 和<code>成员限制</code> 名称不被混淆, 不保证他们是否被删除</td></tr></tbody></table><h2 id="2-Read-Inputs"><a href="#2-Read-Inputs" class="headerlink" title="2. Read Inputs"></a>2. Read Inputs</h2><p>通过 <code>-injars</code> 和 <code>-libraryjars</code> 来声明 <code>input</code>. <code>injars</code> 描述程序运行的代码。后续将对程序代码做优化。 <code>libraryjars</code> 描述程序运行中需要用的环境, 主要是为后面优化阶段提供信息分析。<code>libraryjars</code> 一般情况为 <code>JRE</code> 下的 <code>rt.ja</code>r 和一些特定平台类型的 jar 。 </p><p>可以添加参数修改 Library 的默认解析行为。<br><code>-skipnonpubliclibraryclasses</code>：解析 library 过程中跳过所有非 public 的类。<br><code>-dontskipnonpubliclibraryclasses</code> ：解析 library 过程中解析所有类。<br><code>-dontskipnonpubliclibraryclassmembers</code>：解析 library 过程中解析所有字段和方法。</p><p>理论上如果 Library 中的类或成员是非 public  说明开发者并不希望被访问或使用。 我们可以使用参数关闭，关闭以后会加快运行。</p><p>最终得到两个 ClassPool ，ProgramClass 和 LibraryClass.</p><h2 id="3-Initialize"><a href="#3-Initialize" class="headerlink" title="3. Initialize"></a>3. Initialize</h2><p>ProGuard 基于两个 ClassPool 对所有的 Class 进行连接.</p><ol><li>连接包括所有的类的层级关系 ( 父类，子类，interface )。</li><li>连接注解中 enum 常量。</li><li>连接 code 字节码相关字段和相关类。<br>method 的操作:关联对应的 class 和 method。<br>field 的 操作:关联对应的 class 和 field。</li><li>连接反射信息<br>反射是根据类名或方法名或字段名进行操作的。当我们将反射使用的字符串跟对应的类或方法或字段连接上. 当对应的类或方法或字段混淆的时候同步变更,那么反射依旧生效, 之所以出现了 NoSuchMethodException, NoSuchFieldException,ClassNotFoundException 等问题，就是因为不同步更改信息. 同步更改需要在<code>Initialize</code> 阶段将反射信息连接上对应的类字段方法. 这里的连接并不是没有缺陷的.但是会处理以下几种情况<br>Class.forName(“SomeClass”);<br>Class.forName(“SomeClass”).newInstance().<br>AtomicIntegerFieldUpdater.newUpdater(A.class, “someField”)<br>AtomicLongFieldUpdater.newUpdater(A.class, “someField”)<br>AtomicReferenceFieldUpdater.newUpdater(A.class, B.class，”someField”)<br>AtomicIntegerFieldUpdater.newUpdater(…, “someField”)<br>AtomicLongFieldUpdater.newUpdater(…, “someField”)<br>AtomicReferenceFieldUpdater.newUpdater(…, “someField”)<br>SomeClass.class.getMethod（”someMethod”,…）<br>SomeClass.class.getDeclaredMethod（”someMethod”,…）<br>SomeClass.class.getField（”someMethod”,…）<br>SomeClass.class.getDeclaredFields（”someMethod”,…）<br>SomeClass.class.getConstructor（”someMethod”,…）<br>SomeClass.class.getDeclaredConstructor（”someMethod”,…）<br>这里情况,反射信息能被正确连接.</li></ol><ul><li>Q： 既然 Proguard  会为反射连接信息。 那么我们还要编写针对混淆的规则吗？<br>A： 需要。这里的连接是基于模板匹配。并没有做更多的尝试。 当你的代码不满足上面模板的话。不能被正确配置。例子如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class cls = Class.forName(&quot;SomeClass&quot;); // SomeClass 可以被正确设置</span><br><span class="line">Method ss = cls.getMethod(&quot;someMethod&quot;); // someMethod 不能被正确设置， 因为不满足任何模板</span><br></pre></td></tr></table></figure></li></ul><p>上面的情况如果要被正确模式。 需要进行静态分析。 这将会是一个相对耗时的操作。ProGuard 的静态分析只出现在 <code>Optimize</code>.</p><h3 id="Note-And-Warn"><a href="#Note-And-Warn" class="headerlink" title="Note And Warn"></a>Note And Warn</h3><p>在连接的过程中， ProGuard 会提供一些信息，用于我们定位和发现问题。<br>信息主要分为两部分。note 和 warn。</p><h4 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h4><ul><li>configuration 配置问题。</li><li>重复的类。</li><li>反射潜在的问题。</li></ul><h4 id="Warn"><a href="#Warn" class="headerlink" title="Warn"></a>Warn</h4><ul><li>Library 中使用了程序中的类。</li><li>类，方法，字段 连接不到。 （即缺失相对应的类，方法，字段）</li></ul><p>通过参数关闭对应类或对应类下的警告信息<br><strong>-dontnote</strong> [<em><a href="https://www.guardsquare.com/proguard/manual/usage#filters" target="_blank" rel="noopener">class_filter</a></em>]<br><strong>-dontwarn</strong> [<em><a href="https://www.guardsquare.com/proguard/manual/usage#filters" target="_blank" rel="noopener">class_filter</a></em>]</p><p>Initialize 阶段是后面所有优化的基础。</p><p>注：Note 和 Warn 相当有用。通过 Note 信息我们可以知道可能潜在的混淆问题。Warn 可以帮助我们检查 API 兼容。这非常有用。</p><h2 id="4-Shrink"><a href="#4-Shrink" class="headerlink" title="4.Shrink"></a>4.Shrink</h2><h3 id="4-1-Shrink-优化"><a href="#4-1-Shrink-优化" class="headerlink" title="4.1 Shrink 优化"></a>4.1 Shrink 优化</h3><p>ProGuard 会根据 Configuration  Roots  开始标记, 同时根据 Roots 为入口开始发散 . 标记完成以后,  删除未被标记的类或成员. 最终得到的是精简的 ClassPool 。</p><h3 id="4-2-Roots"><a href="#4-2-Roots" class="headerlink" title="4.2 Roots"></a>4.2 Roots</h3><p>Roots 包括 类，方法，字段, 方法指令, 来源主要有 2 种。</p><ol><li>通过 keep 同时 allowshrinking 不为 true 。计算 class_specification 中 <code>类限定</code>和<code>限定成员</code> </li><li>通过 keepclasseswithmembers 关键字 allowshrinking 不为 true 。如果 <code>类限定</code> 和 <code>成员限定</code>都存在。计算 class_specification 中 类限定 和 成员限定 </li></ol><h3 id="4-3-标记流程"><a href="#4-3-标记流程" class="headerlink" title="4.3 标记流程"></a>4.3 标记流程</h3><p>通过开始标记 Roots 发散到所有的代码.</p><ul><li>类：标记类和父类。</li><li>方法：标记方法. 如果是虚方法, 往上标记对应的虚方法.</li><li>字段：标记字段和字段的相关 Class。</li><li>方法指令: 方法调用指令标记相关类和方法, 字段操作指令标记相关类和字段</li></ul><p>注: 标记过程中主要是使用 <code>Initialize</code> 阶段的连接信息.</p><h3 id="4-3-保留规则"><a href="#4-3-保留规则" class="headerlink" title="4.3 保留规则"></a>4.3 保留规则</h3><ol><li>一个类或方法或字段在 Roots 中将会保留。</li><li>一个类或方法或字段被使用将会保留。</li><li>一个类被 keep 保留， 那么它的构造方法（<init>），非空静态初始化(<cinit>)也将被保留。</cinit></init></li><li>一个类被保留，那么它从 library 中继承的方法也将被保留下来。</li><li>一个类被保留，那么它的父类也会被保留。</li><li>一个虚方法被保留，那么它父类对应方法也将被保留。</li><li>一个类被保留，interface 被保留。 interface 方法被保留，该类实现 interface 方法也被保留。</li><li>内部类或注解如果没有使用将不会被保留。注解如果在 ClassPool 中找不到那么会被保留。</li><li>方法被保留。 它的参数，行号也将被保留。</li></ol><ul><li>Q: 如果 A 的复写了 toString() 方法 。没有被调用。 toString() 会被移除吗？<br>A: 不会  toString()  是从 rt.jar java.lang.Object 类中继承过来的。如果 A 被保留,那么从 LIbrary 中的继承的方法将被无条件保留下来. 即使是一个空方法.</li></ul><h4 id="4-4-总结"><a href="#4-4-总结" class="headerlink" title="4.4 总结"></a>4.4 总结</h4><p>Shrink 只会删除没有用的类和成员，并不会裁切方法。对于没有使用的空方法或者没有修改的虚方法. 这些方法我们是可以删除的. 但是这些操作涉及到 code 指令的修改. ProGuard 在这阶段并没有做这么重的操作,  不过部分空方法会在 <code>Optimize</code> 阶段被删除,  </p><h2 id="5-Optimize"><a href="#5-Optimize" class="headerlink" title="5. Optimize"></a>5. Optimize</h2><h3 id="5-1-Optimize-优化"><a href="#5-1-Optimize-优化" class="headerlink" title="5.1 Optimize 优化"></a>5.1 Optimize 优化</h3><p>Optimize 是四个阶段最为复杂的地方。也是耗时最长的阶段。<br>Optimize 会在该阶段通过对 代码指令、 堆栈, 局部变量以及数据流分析.来模拟程序运行中尽可能出现的情况来优化和简化代码. 为了数据流分析的需要 Optimize  会多次遍历所有字节码。ProGuard 会开启多线程来加快速度。</p><h3 id="5-2-优化选项"><a href="#5-2-优化选项" class="headerlink" title="5.2 优化选项"></a>5.2 优化选项</h3><p>ProGuard 定义了 33 优化项, 包含 <code>class</code>，<code>field</code>，<code>method</code>，<code>code</code> 四个纬度。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">private static final String CLASS_MARKING_FINAL                  = &quot;class/marking/final&quot;;</span><br><span class="line">private static final String CLASS_UNBOXING_ENUM                  = &quot;class/unboxing/enum&quot;;</span><br><span class="line">private static final String CLASS_MERGING_VERTICAL               = &quot;class/merging/vertical&quot;;</span><br><span class="line">private static final String CLASS_MERGING_HORIZONTAL             = &quot;class/merging/horizontal&quot;;</span><br><span class="line">private static final String CLASS_MERGING_WRAPPER                = &quot;class/merging/wrapper&quot;;</span><br><span class="line">private static final String FIELD_REMOVAL_WRITEONLY              = &quot;field/removal/writeonly&quot;;</span><br><span class="line">private static final String FIELD_MARKING_PRIVATE                = &quot;field/marking/private&quot;;</span><br><span class="line">private static final String FIELD_PROPAGATION_VALUE              = &quot;field/propagation/value&quot;;</span><br><span class="line">private static final String METHOD_MARKING_PRIVATE               = &quot;method/marking/private&quot;;</span><br><span class="line">private static final String METHOD_MARKING_STATIC                = &quot;method/marking/static&quot;;</span><br><span class="line">private static final String METHOD_MARKING_FINAL                 = &quot;method/marking/final&quot;;</span><br><span class="line">private static final String METHOD_MARKING_SYNCHRONIZED          = &quot;method/marking/synchronized&quot;;</span><br><span class="line">private static final String METHOD_REMOVAL_PARAMETER             = &quot;method/removal/parameter&quot;;</span><br><span class="line">private static final String METHOD_PROPAGATION_PARAMETER         = &quot;method/propagation/parameter&quot;;</span><br><span class="line">private static final String METHOD_PROPAGATION_RETURNVALUE       = &quot;method/propagation/returnvalue&quot;;</span><br><span class="line">private static final String METHOD_INLINING_SHORT                = &quot;method/inlining/short&quot;;</span><br><span class="line">private static final String METHOD_INLINING_UNIQUE               = &quot;method/inlining/unique&quot;;</span><br><span class="line">private static final String METHOD_INLINING_TAILRECURSION        = &quot;method/inlining/tailrecursion&quot;;</span><br><span class="line">private static final String CODE_MERGING                         = &quot;code/merging&quot;;</span><br><span class="line">private static final String CODE_SIMPLIFICATION_VARIABLE         = &quot;code/simplification/variable&quot;;</span><br><span class="line">private static final String CODE_SIMPLIFICATION_ARITHMETIC       = &quot;code/simplification/arithmetic&quot;;</span><br><span class="line">private static final String CODE_SIMPLIFICATION_CAST             = &quot;code/simplification/cast&quot;;</span><br><span class="line">private static final String CODE_SIMPLIFICATION_FIELD            = &quot;code/simplification/field&quot;;</span><br><span class="line">private static final String CODE_SIMPLIFICATION_BRANCH           = &quot;code/simplification/branch&quot;;</span><br><span class="line">private static final String CODE_SIMPLIFICATION_OBJECT           = &quot;code/simplification/object&quot;;</span><br><span class="line">private static final String CODE_SIMPLIFICATION_STRING           = &quot;code/simplification/string&quot;;</span><br><span class="line">private static final String CODE_SIMPLIFICATION_MATH             = &quot;code/simplification/math&quot;;</span><br><span class="line">private static final String CODE_SIMPLIFICATION_ADVANCED         = &quot;code/simplification/advanced&quot;;</span><br><span class="line">private static final String CODE_REMOVAL_ADVANCED                = &quot;code/removal/advanced&quot;;</span><br><span class="line">private static final String CODE_REMOVAL_SIMPLE                  = &quot;code/removal/simple&quot;;</span><br><span class="line">private static final String CODE_REMOVAL_VARIABLE                = &quot;code/removal/variable&quot;;</span><br><span class="line">private static final String CODE_REMOVAL_EXCEPTION               = &quot;code/removal/exception&quot;;</span><br><span class="line">private static final String CODE_ALLOCATION_VARIABLE             = &quot;code/allocation/variable&quot;;</span><br></pre></td></tr></table></figure></p><h3 id="5-2-1-Class-纬度"><a href="#5-2-1-Class-纬度" class="headerlink" title="5.2.1 Class 纬度"></a>5.2.1 Class 纬度</h3><p><code>class/marking/final</code><br>没有派生的类使用 final 修饰。</p><p><code>class/unboxing/enum</code><br>将枚举的使用转换成常量 int 的使用。<br>当枚举出现如下情况不对其优化</p><ol><li>枚举实现了自定义接口。并且被调用。</li><li>代码中使用了不同签名来存储枚举。</li><li>使用 instanceof 指令判断。</li><li>在枚举加锁操作。</li><li>对枚举强转。</li><li>在代码中调用静态方法 valueOf 方法。</li><li>定义可以外部访问的方法。<br>优势：更小的占用内存，更快的执行效率。但条件较为苛刻。</li></ol><p><code>class/merging/wrapper</code><br>将只有一个 targetClass 字段类型的 wrapper class 尝试合并到 targetClass class 。 即时 targetClass 将拥有 wrapper 的所有方法.。同时将 wrapper 指令调用的转成 targetClass 的指令调用。<br>wrapper 和 targetClass 满足如下条件：</p><ol><li>wrapper  构造函数只有一个参数, 参数类型为  targetClass。</li><li>wrapper  只有一个字段且非静态, 类型为 targetClass </li><li>wrapper 和 targetClass 父类是 java/lang/Object  。</li><li>wrapper 没有注解</li><li>两个类拥有互相访问权限。</li><li>wrapper 和 targetClass 没有继承关系</li><li>wrapper 没有 instantof 指令和强转的使用</li><li>两个没有使用反射实例化</li><li>两个没有存在相同的方法。</li><li>wrapper 没有子类。</li></ol><p>注: <code>class/merging/wrapper</code> 该项优化只会 <strong>外部类 merge 非静态内部类</strong>。 ProGuard 会匹配 wrapper 的构造函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">this.x = arg0;</span><br><span class="line">super.&lt;init&gt;;</span><br><span class="line">return;</span><br></pre></td></tr></table></figure></p><p>匹配 javac 为内部类自动生成的一参构造函数。 对于非内部类的构造函数  <code>super.&lt;init&gt;;</code> 是第一个指令。后续才是字段的赋值的指令。</p><p><code>class/merging/vertical</code><br>满足以下情况合并子类的方法和字段</p><ol><li>子类没有注解</li><li>两个类拥有互相访问权限。</li><li>子类没有 instantof 指令和强转的使用</li><li>子类和父类没有使用反射实例化</li><li>子类没有静态字段</li><li>子类没有内部类，不是他人的内部类</li><li>两个没有存在相同的方法。</li></ol><p><code>class/merging/horizontal</code><br>满足以下情况合并兄弟类（同一个父类）的方法和字段</p><ol><li>兄弟类没有注解</li><li>两个类拥有互相访问权限。</li><li>兄弟类没有 instantof 指令和强转的使用</li><li>两个没有使用反射实例化</li><li>兄弟类没有静态字段</li><li>兄弟类没有内部类，不是他人的内部类</li><li>两个没有存在相同的方法。</li><li>双方派生类没有和对方私有的方法相同的签名。（主要保证合并以后不会出现方法冲突）</li><li>双方派生类不能拥有对方可见的字段。（主要保证合并以后不会出现字段冲突）</li></ol><h3 id="5-2-2-Field-纬度"><a href="#5-2-2-Field-纬度" class="headerlink" title="5.2.2 Field 纬度"></a>5.2.2 Field 纬度</h3><p><code>field/removal/writeonly</code><br>删除只有写没有读的字段。同时删除写的指令。反射的字段属于即读又写。 </p><p><code>field/marking/private</code><br>将只在申明类中使用，没有被反射方式使用，使用 private 修饰</p><p><code>field/propagation/value</code><br>优化固定值字段的调用<br>字段满足如下</p><ol><li>字段类型为 int，char，long，double，boolean，float，byte，short </li><li>字段是恒固定值。</li></ol><p>通过下面例子理解一下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public  class Constant &#123;</span><br><span class="line">    public static final int C_1 = 12;</span><br><span class="line">&#125;</span><br><span class="line">//优化前</span><br><span class="line">fun1(Constant.C_1);</span><br><span class="line">//优化后</span><br><span class="line">fun1(12);</span><br></pre></td></tr></table></figure><p>注： 如果字段被 final 修饰，ProGuard 认为它是一个固定的值。 对于非 final 修饰。尽管在后续的操作中没有被修改，但 ProGuard 认为字段存在一个初始值。这或许是对的。通过下面例子理解一下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public final int field1 = 12; // 固定值 12</span><br><span class="line">public int field2 = 12;// 初始值为0 ，在 init 方法中被赋值为12 。</span><br></pre></td></tr></table></figure><h3 id="5-2-3-Method-纬度"><a href="#5-2-3-Method-纬度" class="headerlink" title="5.2.3  Method 纬度"></a>5.2.3  Method 纬度</h3><p><code>method/marking/private</code><br>只在申明类中使用，且没有被反射调用方法使用 private 修饰</p><p><code>method/marking/static</code><br>尝试将方法使用 static 修饰<br>满足以下条件：</p><ol><li>该方法非静态</li><li>方法没有使用 this 参数；虚方法要保证在整个继承树中都没有使用 this 参数。</li></ol><p><code>method/marking/final</code><br>为方法添加 final 修饰。<br>需满足如下任一个条件：</p><ol><li>类使用 final 修饰，方法非空非私有非抽象 </li><li>没有了派生类，</li><li>该方法没有派生类重载。 </li></ol><p><code>method/marking/synchronized</code><br>对 synchronized 修饰方法进行去锁。<br>需要满足如下条件</p><ol><li>非静态方法</li><li>该方法未被使用。 </li></ol><p><code>method/removal/parameter</code><br>方法参数在方法中没被使用到，虚方法要保证在整个继承树中都没有使用参数。将会被裁切。同时会对方法名称进行重命名原先方法加+方法hashcode。<br>注：这里对方法重命名并没有检查是否存在相同签名的方法。但是出现该情况的比例比较小</p><p><code>method/propagation/parameter</code><br>只支持 int，char，long，double，boolean，float，byte，short 类型入参<br>当入参是固定值的时，对入参进行优化。<br>通过如下例子感受一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 优化前</span><br><span class="line">public int main() &#123;</span><br><span class="line">    int value = 99;</span><br><span class="line">    ....</span><br><span class="line">   value ++；</span><br><span class="line">   call( value ); // </span><br><span class="line">&#125;</span><br><span class="line">// 优化后</span><br><span class="line"> public int main() &#123;</span><br><span class="line">    int value = 99;</span><br><span class="line">    ....</span><br><span class="line">   // 通过分析， 这里返回的入参总是100</span><br><span class="line">    call(100); //</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该项优化次数，在 6.0.3 版本统计存在问题，原因是在统计的时候缺少静态方法或非静态方法的判断。具体可看 <a href="https://sourceforge.net/p/proguard/code/merge-requests/6/" target="_blank" rel="noopener">#mr6</a></p><p><code>method/propagation/returnvalue</code><br>优化只支持 int，char，long，double，boolean，float，byte，short 这些类型的作为方法返回值。当返回值是固定值， 那么对其进行优化。</p><p><code>method/inlining/short</code><br><code>method/inlining/unique</code><br>尝试内联方法。<br>该方法满足如下条件</p><ol><li>unique 方法只被调用一次。short 方法字节码数足够小，android 项目默认小于32. 可通过System.setProperty( “maximum.inlined.code.length” ，60）修改</li><li>方法 私有 或 静态 或 final 类型的方法.</li><li>方法不存在递归.</li><li>方法不存在加锁的</li><li>方法不存在 try catch</li><li>方法没有返回值</li><li>方法不能是构造方法</li><li>不同类, 不能有调用 super 的方法或 invokedynamic 指令</li><li>没有回向分支<br>注： 内联会导致方法行号进行偏移. </li></ol><p><code>method/inlining/tailrecursion</code><br>尾递归优化（略）</p><h3 id="5-2-4-code-纬度"><a href="#5-2-4-code-纬度" class="headerlink" title="5.2.4 code 纬度"></a>5.2.4 code 纬度</h3><p><code>code/merging</code><br>合并不同分支下的代码（略）</p><p><code>code/simplification/variable</code><br>详情查看 <a href="https://sourceforge.net/p/proguard/code/ci/default/tree/core/src/proguard/optimize/peephole/InstructionSequenceConstants.java" target="_blank" rel="noopener">InstructionSequenceConstants</a></p><ol><li>优化变量读取：<br>eg : iload/iload = iload/dup</li><li>删除多余变量的操作：<br>eg: iload/pop   = nothing<br>eg: lload/pop2 = nothing</li></ol><p><code>code/simplification/arithmetic</code><br>详情查看 <a href="https://sourceforge.net/p/proguard/code/ci/default/tree/core/src/proguard/optimize/peephole/InstructionSequenceConstants.java" target="_blank" rel="noopener">InstructionSequenceConstants</a><br>优化指令中的运算。</p><ol><li>乘法指令转成左移指令：<br>eg: * 8 = … &lt;&lt; 3</li><li>简化指令的个数：i=i+1 = i++</li><li>…</li></ol><p><code>code/simplification/cast</code><br>详情查看 <a href="https://sourceforge.net/p/proguard/code/ci/default/tree/core/src/proguard/optimize/peephole/InstructionSequenceConstants.java" target="_blank" rel="noopener">InstructionSequenceConstants</a></p><ol><li>优化多个连续的 cast 指令</li></ol><p><code>code/simplification/field</code><br>详情查看 <a href="https://sourceforge.net/p/proguard/code/ci/default/tree/core/src/proguard/optimize/peephole/InstructionSequenceConstants.java" target="_blank" rel="noopener">InstructionSequenceConstants</a><br>删除无用字段操作指令操作，<br>eg: getfield/putfield = nothing<br>优化字段操作指令。<br>eg: getstatic/getstatic = getstatic/dup</p><p><code>code/simplification/branch</code><br>详情查看 <a href="https://sourceforge.net/p/proguard/code/ci/default/tree/core/src/proguard/optimize/peephole/InstructionSequenceConstants.java" target="_blank" rel="noopener">InstructionSequenceConstants</a><br>删除一些无用的分支，<br>简化分支判断指令</p><p><code>code/simplification/object</code><br>详情查看 <a href="https://sourceforge.net/p/proguard/code/ci/default/tree/core/src/proguard/optimize/peephole/InstructionSequenceConstants.java" target="_blank" rel="noopener">InstructionSequenceConstants</a></p><ol><li>简化代码中多余的 equals 判断。<br>eg: object.equals(object) = true</li><li>对包装器类型实例化 转成 包装器类型的工厂方法。<br>eg： new Integer(v) = Integer.valueof(v)</li></ol><p><code>code/simplification/string</code><br>详情查看 <a href="https://sourceforge.net/p/proguard/code/ci/default/tree/core/src/proguard/optimize/peephole/InstructionSequenceConstants.java" target="_blank" rel="noopener">InstructionSequenceConstants</a><br>优化 String 的使用。合并多个静态字符串</p><ol><li>优化 String equals 部分情况：<br>eg：”abc”.equals(“abc”) = true</li><li>优化 String 静态方法 valueOf 和 concat  ：<br>eg：String.valueOf(12) = “12”<br>eg: “a”.concat(“b”) = “ab”</li><li>优化 StringBuilder StringBuffer 的init，append() ，toString() 方法<br>eg：new StringBuffer().append(“abc”) = new StringBuffer(“abc”)<br>eg：new StringBuffer(“a”).append(“bc””) = new StringBuffer(“abc”)<br>eg：StringBuffer#append(“ab”).append(“c”) = StringBuffer#append(“abc”)<br>eg：StringBuffer#append(“”) = StringBuffer#<br>eg：new StringBuffer(“a”).append(12).toString() = “a”.concat(String.valueOf(12))</li></ol><p><code>code/simplification/math</code><br>详情查看 <a href="https://sourceforge.net/p/proguard/code/ci/default/tree/core/src/proguard/optimize/peephole/InstructionSequenceConstants.java" target="_blank" rel="noopener">InstructionSequenceConstants</a></p><ol><li>java.lang.Math 的方法进行优化.<br>eg：(float)Math.abs((double)…) = Math.abs(float)</li><li>对于android 项目还会进行优化<br>将所有的android.util.FloatMath的调用转换成java.lang.Math 因为高版本的FloatMath 已经被废弃了。</li></ol><p><code>code/removal/simple</code><br>去除不会到达的代码块。 </p><p><code>code/removal/variable</code><br>去除方法没有用到局部变量</p><p><code>code/removal/exception</code><br>try catch 里面的代码指令不会发生异常， 移除 try catch 语句。</p><p><code>code/allocation/variable</code><br>优化局部变量的使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> // 优化前 </span><br><span class="line"> String ss = &quot;99&quot;;</span><br><span class="line"> System.out.println(ss);</span><br><span class="line"> String ss1 = &quot;99&quot;;</span><br><span class="line"> System.out.println(ss1);</span><br><span class="line">// 优化后</span><br><span class="line"> String ss1 = &quot;99&quot;;</span><br><span class="line"> System.out.println(ss);</span><br><span class="line"> ss1 = &quot;99&quot;;</span><br><span class="line"> System.out.println(ss1);</span><br></pre></td></tr></table></figure><p><code>code/removal/advanced</code><br>ProGuard 允许删除一些没有副作用的方法指令调用。</p><h5 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h5><p>ProGuard 标记有副作用的指令和方法, 然后向上回溯标记该指令上的对象,参数,方法. 没有被标记的指令则可以被移除。<br>通过下面例子理解一下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void func()&#123;</span><br><span class="line">/...         </span><br><span class="line">Object o = obj.funcA(a);</span><br><span class="line">/...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>方法 funcA 满足以下几点可以被移除</p><ol><li>funcA 的参数a不会逃逸.<br>逃逸:<br>经过 funcA 参数被其他的对象持有了。</li><li>funcA 没有外部副作用.<br>外部副作用:<br>调用了一个 native 方法或修改了一个静态对象等等. 这些操作副作用的范围已经超过 obj  范围. </li><li>参数 a 在 funcA 没有被修改。 或参数 a 是一个可忽略的对象。</li><li>obj 在 funcA 没有被修改, 或 obj 是一个可忽略的对象。<br>修改:<br>对象的字段经过 funcA 发生了变化。<br>可忽略对象：<br>对象赋值是可忽略的。没有成为有副作用方法的参数. </li><li>返回值 o 没有成为有副作用方法的参数.</li><li>返回值 o 没有成为 func 的返回值</li><li>返回值 0 没有被 thow 抛出.</li></ol><p>ProGuard 对于 Library 中的方法做最坏的打算, 参数会发生逃逸。方法有外部副作用。对象和参数会被修改。返回值是一个外部引用。不满足条件 1,2,3,4.  ProGuard 提供<code>声明</code>来修改它们的副作用影响范围。 对于 Library 来说，  ProGuard 不会分析其内部代码指令。直接按照声明确定他们的副作用影响。 对于程序中的方法。会对方法内部指令进行分析计算副作用影响。开发者可以根据需要使用<code>声明</code>修改它的副作用影响。<br>声明方式如下:</p><table><thead><tr><th>声明方式</th><th>内部标识</th><th>描述</th></tr></thead><tbody><tr><td>-assumenosideeffects</td><td>hasNoSideEffects ,hasNoExternalSideEffects hasNoEscapingParameters</td><td>没有外部影响,  没有参数逃逸,没有参数和对象被修改</td></tr><tr><td>-assumenoexternalsideeffects</td><td>hasNoExternalSideEffects hasNoEscapingParameters</td><td>没有外部影响,没有参数逃逸,没有参数被修改</td></tr><tr><td>-assumenoescapingparameters</td><td>hasNoEscapingParameters</td><td>没有参数逃逸</td></tr><tr><td>-assumenoexternalreturnvalues</td><td>hasNoExternalReturnValues</td><td>返回值是参数或新对象</td></tr></tbody></table><p><code>-assumenosideeffects</code>声明:<br>被声明的方法将满足条件1,2,3,4. 当返回值满足条件 5,6,7, 那么该方法调用指令将被删除.<br><code>assumenoexternalsideeffects</code>声明:<br>被声明的方法将满足条件1,2,3。</p><p><code>-assumenoexternalreturnvalues</code>声明<br>方法返回值有三种情况：</p><ol><li>返回值的是入参。</li><li>返回值一个新对象实例。该对象在方法内被实例化。</li><li>返回值是的外部引用。 一般为堆上某个引用的字段实例。<br>这三种情况， 第三种返回值是一个不可被忽略的对象。<br>assumenoexternalreturnvalues 声明表示返回值是一个新对象实例或者参数。 是一个可以被忽略的对象， 后续中如果该返回值满足 567 ， 那么该对象为不可忽略的对象。</li></ol><p>通过 ProGuard 的例子，理解一下声明的作用。</p><h5 id="例子1"><a href="#例子1" class="headerlink" title="例子1"></a>例子1</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">声明</span><br><span class="line">-assumenoexternalsideeffects class java.lang.StringBuilder &#123;</span><br><span class="line">    public java.lang.StringBuilder();</span><br><span class="line">    public java.la·ng.StringBuilder append(java.lang.String);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">方法块1：</span><br><span class="line">new StringBuilder().append(&quot;dd&quot;)</span><br><span class="line">方法块2：</span><br><span class="line">new StringBuilder().append(&quot;dd&quot;).append(&quot;ddd&quot;);</span><br></pre></td></tr></table></figure><h6 id="结果："><a href="#结果：" class="headerlink" title="结果："></a>结果：</h6><p>方法块1 被删除<br>因为使用 assumenoexternalsideeffects 声明了两个方法 StringBuilder() 和 append() 方法。<br>new StringBuilder() 返回的是一个可忽略的对象。append() 满足以上条件，所以调用也是一个没有副作用的操作。<br>方法块2 被保留<br>因为在第二个 append 方法的时候， 调用者是由第一个 append 方法返回的一个外部引用。满足123， 不满足4，所以  append 方法调用存在副作用，第二个 append 方法被保留。  ProGuard 向上回溯标记相关参数对象和方法。最终 方法块2 整体被保留了。</p><h5 id="例子2"><a href="#例子2" class="headerlink" title="例子2"></a>例子2</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">声明</span><br><span class="line">-assumenoexternalsideeffects class java.lang.StringBuilder &#123;</span><br><span class="line">    public java.lang.StringBuilder();</span><br><span class="line">    public java.lang.StringBuilder append(java.lang.String);</span><br><span class="line">&#125;</span><br><span class="line">-assumenoexternalreturnvalues class java.lang.StringBuilder &#123;</span><br><span class="line">    public java.lang.StringBuilder append(java.lang.String);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="结果：-1"><a href="#结果：-1" class="headerlink" title="结果："></a>结果：</h6><p>方法块2 被删除<br><code>assumenoexternalreturnvalues</code> 将 append 返回值声明为非外部引用。将满足条件1234567。调用不存在副作用。</p><h5 id="例子3"><a href="#例子3" class="headerlink" title="例子3"></a>例子3</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">配置</span><br><span class="line">-assumenosideeffects class java.lang.StringBuilder &#123;</span><br><span class="line">    public java.lang.StringBuilder();</span><br><span class="line">    public java.lang.StringBuilder append(java.lang.String);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="结果：-2"><a href="#结果：-2" class="headerlink" title="结果："></a>结果：</h6><p>方法块2 被删除<br><code>assumenosideeffects</code> 声明屏蔽了 StringBuilder 自身的修改。 满足了条件4，同时满足条件 123567。 调用不存在副作用。</p><h3 id="5-3-优化副作用"><a href="#5-3-优化副作用" class="headerlink" title="5.3 优化副作用"></a>5.3 优化副作用</h3><ul><li>反编译问题: 优化中会使用上 pop，pop2 ，swap，等指令， 这个将会导致反编译不能编译出相对应语义的 代码。</li><li>定位问题：部分优化带来行号偏移的问题和 SourceFile 丢失。</li></ul><p>注: 以上总结均基于 ProGuard 6.0.3 的源码。省略了部分条件和情况, 因为太过于复杂.以及描述不清</p><h3 id="5-4-总结"><a href="#5-4-总结" class="headerlink" title="5.4  总结"></a>5.4  总结</h3><p>Optimize 阶段是 ProGuard 几个阶段中着墨最多的， 代码量也是最多最为复杂的。 整体耗时也是最长， 即使其他几个阶段的耗时加起来也比不上 Optimize 的耗时的一半， 但这阶段却也是最容易被忽略的阶段。</p><h2 id="6-Obfuscate"><a href="#6-Obfuscate" class="headerlink" title="6. Obfuscate"></a>6. Obfuscate</h2><h3 id="6-1-Obfuscate-处理过程"><a href="#6-1-Obfuscate-处理过程" class="headerlink" title="6.1 Obfuscate 处理过程"></a>6.1 Obfuscate 处理过程</h3><p>将类,字段,方法的名称简化成短名字, 简化需要依据 java 的规范, 方法名应符合定义没有非法字符. 虚方法在 class 继承中方法名称保持一致. 同个范围内字段或方法描述符,签名相同的时候名称唯一, 相同包下 class 名称唯一. 从 library 中继承的方法名称不变等等。</p><h3 id="6-2-Obfuscate-参数"><a href="#6-2-Obfuscate-参数" class="headerlink" title="6.2 Obfuscate 参数"></a>6.2 Obfuscate 参数</h3><p><code>-applymapping</code><br>应用映射规则。</p><p><code>-useuniqueclassmembernames</code><br>混淆时候为类成员生成全局唯一的名称。<br>相同的 字段描述符 的字段 拥有全局唯一的名称。<br>相同的 方法描述符 的方法 拥有全局唯一的名称。</p><p><code>-overloadaggressively</code><br>该选项是一个更为激进的选项， 他允许在同一个类中，一个不同类型的字段拥有相同的名字。相同入参不同返回类型拥有相同名称。 这个选项可以让 class 的大小更小。但是对于反编译是一个灾难。</p><p><code>-keepparameternames</code><br>在保留本地变量表基础上。 只保留参数的变量表。</p><p><code>-repackageclasses</code> x<br><code>-defaultpackage</code> x<br>将混淆的类的包名替换为x。 加大逆向分析的成本</p><p><code>-flattenpackagehierarchy</code> x<br>将混淆的类的包名以x 为前缀扁平化。 加大逆向分析的成本。</p><p><code>-packageobfuscationdictionary</code><br>混淆包名字典</p><p><code>-classobfuscationdictionary</code><br>混淆类和成员字典<br><code>-renamesourcefileattribute</code> x<br> SourceFile 属性值重置为 x</p><h2 id="7-Preverify"><a href="#7-Preverify" class="headerlink" title="7. Preverify"></a>7. Preverify</h2><p>对 java code 进行预校验。 主要校验 StackMap /StackMapTable 属性。android 虚拟机字节码校验不基于StackMap /StackMapTable。</p><h1 id="0x02-ProGuard-在-Android-上运用："><a href="#0x02-ProGuard-在-Android-上运用：" class="headerlink" title="0x02 ProGuard 在 Android 上运用："></a>0x02 ProGuard 在 Android 上运用：</h1><h2 id="1-ProGuard-Rule"><a href="#1-ProGuard-Rule" class="headerlink" title="1. ProGuard Rule"></a>1. ProGuard Rule</h2><p>Android 开启 ProGuard<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">release &#123;</span><br><span class="line">        minifyEnabled true</span><br><span class="line">        shrinkResources true</span><br><span class="line">        proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><ul><li>minifyEnabled:  开启代码收敛， 默认使用 ProGuard  方式。</li><li>proguardFiles：定义 ProGuard rule。</li></ul><p>ProGuard rules 的来源主要分为 4 类：</p><ul><li>预置 rules：默认有三种 proguard-android.txt, proguard-android-optimize.txt,proguard-defaults.txt， 在 Gradle 在编译的时候通过任务 <code>extractProguardFiles</code> 将预置在依赖 <code>com.android.tools.build:gradle-core</code> java resource  的 rules 解压到根项目 build/intermediates/proguard-files 文件下。<br><img src="https://upload-images.jianshu.io/upload_images/166866-890d243471649497.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"> 默认引入的是 <code>proguard-android.txt</code> 。 该项关闭了 Optimize。如果想开启Optimize 可以引用<code>proguard-android-optimize.txt</code>或者不使用预置的 rules 。</li><li>project rules：定义在主工程的 rules</li><li>aar rules：每个 library 携带关于自身的一份 rules。</li><li>aapt_rules：aapt 在为资源时候生成。</li></ul><h2 id="2-应用"><a href="#2-应用" class="headerlink" title="2. 应用"></a>2. 应用</h2><h3 id="2-1-R-文件内联："><a href="#2-1-R-文件内联：" class="headerlink" title="2.1 R 文件内联："></a>2.1 R 文件内联：</h3><p>Android 中 R 文件是标识资源 ID， Resource 可以根据标识资源 ID查找对应的资源。 R 文件分为两种， </p><ol><li>主工程的 R 文件<br>字段使用 static final 修饰。javac 编译的时候，将源码中的 id 引用替换成对应资源常量。</li><li>Library的 R 文件<br>Library 生成 aar 的时候。资源的 id 并不确7定。 同时避免 javac 做类似主工程的优化。R 文件是 static 非 final 。 R 文件也不会一起打包到aar 中。</li></ol><p>我们可以通过删除 R 文件来减小包大小。 主工程的 R 文件可以直接删除。 对于Library 中的 R 文件需要先内联。然后再删除。<br>方案:</p><ol><li>通过自定义 Android Gradle Transform Api 来实现。内联和删除 R 文件。</li><li>使用 ProGuard 来做内联和删除的优化。通过优化项<code>field/propagation/value</code> 来实现。  ProGuard 这获取是一个更为优雅的选择。代价是 <code>Optimize</code> 的耗时。</li></ol><h3 id="2-2-API-检查"><a href="#2-2-API-检查" class="headerlink" title="2.2 API 检查"></a>2.2 API 检查</h3><p>在上次文章 <a href="https://dim.red/2018/11/03/gradle_configuration_exploration/">Gradle Configuration</a> 分析的中可以发现 Gradle 对依赖版本的判断是不可靠的。我们需要在最后阶段进行 API 检查。  防止出现  NoSuchMethodException, NoSuchFieldException,ClassNotFoundException 等异常。 </p><ol><li><p>方案一<br>结合 -dontwarn 参数，记录 Initialize 阶段连接中出现缺失的类和字段或者方法。但是 Initialize 的时候。程序的 ClassPool 的部分类和方法会在 Shrink 阶段被删除。 对于它们的检查是多余的。他们的错误也是可以被忽略的.</p></li><li><p>方案二<br>Shrink 阶段后。重新连接 ClassPool 。 记录其中的缺失的类和字段或者方法。相对于方案一, 方案二需要基于ProGuard 源码进行扩展。</p></li></ol><h3 id="2-3-瘦身"><a href="#2-3-瘦身" class="headerlink" title="2.3 瘦身"></a>2.3 瘦身</h3><p>ProGuard 应该是 APK 瘦身第一大利器。主要是在四方面。</p><ol><li>类和方法，字段的删除。（Shirk）</li><li>字节码的优化。（Optimize）</li><li>字节码 中 Attributes 属性的删除。（Obfuscate）</li><li>名称的简化。（Obfuscate）</li></ol><p>ProGuard 是在 rule 规则上做优化。 rule 的范围越窄，那么优化的效果就越明显。我们尽可能的优化 rule 来达到最大化的优化的结果。除了在定义的时候特别注意范围。 同时可以优化 aapt_rule 来做更为极致的优化。aapt_rule 是由 aapt 工具在生成 arsc 资源时候生成 rule。 该 rule  是一个较为保守的方案。 它涵盖了所有 资源中可能出现的情况。 因为有些资源是在代码中永远不会被使用到。所以根据没有用到的资源生成的 rule 也是一个冗余的 rule 。通过以下情况了解一下具体情况。<br><img src="/2019/01/28/proguard_exploration/proguard_04.png" alt="image.png"><br>情况1：只有 app 代码。 通过 ProGuard 之后 jar 的大小 3 KB<br>情况2：有 app 代码，引入了<code>appcompat-v7:28.0.0</code> 依赖。 但是没有使用 v7 的代码或者资源， 通过  ProGuard 之后 jar 大小为 612 KB。<br>情况3：有 app 代码和 <code>appcompat-v7:28.0.0</code> 依赖，没有使用 v7 的代码或资源。 收敛了 aapt_rules 。  ProGuard 之后 jar 大小为 29 KB。之所以没有办法达到情况1  中 3 KB原因在于引入了 v7 的同时引入了 v7 的 aar_rules.</p><p>注：  aapt_rules 收敛以后瘦身的效果还受到其他因素的影响。 </p><h1 id="0x03-ProGuard-rule-优化建议"><a href="#0x03-ProGuard-rule-优化建议" class="headerlink" title="0x03 ProGuard rule 优化建议"></a>0x03 ProGuard rule 优化建议</h1><ol><li>尽可能使用 keepnames 替代 keep</li><li>不使用 -ignorewarnings </li><li>rule 范围尽可能小 </li><li>使用 Optimize ， 但避免出现行号偏移。</li><li>反射使用遵循模板。</li><li>aar 携带自身的rules </li><li>使用注解 keep </li><li>使用 -overloadaggressively  提高瘦身效果</li><li>使用 -skipnonpubliclibraryclasses 加快混淆速度</li><li>四大组件和 View 交给 aapt 生成。 </li><li>去除多余的 Attributes（RuntimeInvisibleAnnotations，LocalVariableTypeTable…） </li></ol><h1 id="0x04-尾巴"><a href="#0x04-尾巴" class="headerlink" title="0x04 尾巴"></a>0x04 尾巴</h1><p>我们往往使用 混淆 来代表 ProGuard， 这有失偏颇。 混淆只是 ProGuard 的其中一功能。远远不能来代表 ProGuard 。总体来说 ProGuard 是一个特别优秀的框架。拥有完整的 Java 1－10 字节码解析。完整的字节码操作模拟。但是较为复杂的 Optimize 代码还不稳定。耗时较长。部分优化实现相对保留。通过对 ProGuard 的理解和学习会对于以往使用运气编程情况有所改善。 </p><h1 id="0x05-其他"><a href="#0x05-其他" class="headerlink" title="0x05 其他"></a>0x05 其他</h1><p><code>-whyareyoukeeping</code>: 可以通过该选项在 Debug 的时候。 定位类被保留的原因。 正常情况下不建议开启。会延长 ProGuard 时长。<br><code>-printconfiguration</code>: 聚合 ProGuard 的所有rules 输出到具体文件上。<br><code>-addconfigurationdebugging</code>： 有效的定位反射导致的问题。<br>必要的属性:<br><code>-keepattributes LineNumberTable,Signature,RuntimeVisibleAnnotations,RuntimeVisibleParameterAnnotations,AnnotationDefault</code></p><h1 id="0x06-相关连接"><a href="#0x06-相关连接" class="headerlink" title="0x06 相关连接"></a>0x06 相关连接</h1><ol><li><a href="https://docs.oracle.com/javase/specs/jvms/se10/html/index.html" target="_blank" rel="noopener">The Java® Virtual Machine Specification</a></li><li><a href="https://dim.red/2018/11/03/gradle_configuration_exploration/">Gradle Configuration</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;0x00-环境&quot;&gt;&lt;a href=&quot;#0x00-环境&quot; class=&quot;headerlink&quot; title=&quot;0x00  环境&quot;&gt;&lt;/a&gt;0x00  环境&lt;/h1&gt;&lt;p&gt;版本：&lt;a href=&quot;https://sourceforge.net/p/proguard/code/ci/proguard6.0.3/tree/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;6.0.3&lt;/a&gt;&lt;br&gt;使用文档：&lt;a href=&quot;https://www.guardsquare.com/en/products/proguard/manual/usage&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;usage&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;0x01-ProGuard-总览&quot;&gt;&lt;a href=&quot;#0x01-ProGuard-总览&quot; class=&quot;headerlink&quot; title=&quot;0x01 ProGuard 总览&quot;&gt;&lt;/a&gt;0x01 ProGuard 总览&lt;/h1&gt;&lt;p&gt;ProGuard 是 java 字节码优化工具， 广泛运用到 Java 和 Android 项目中。可以有效的减少程序的大小，提高运行效率，提高逆向分析的成本。&lt;br&gt;&lt;img src=&quot;/2019/01/28/proguard_exploration/proguard_01.png&quot; alt=&quot;ProGuard 运行过程&quot;&gt;&lt;br&gt;Proguard 优化主要分为四个阶段:&lt;br&gt;Shrink , Optimize, Obfuscate , Preverify 四个阶段&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Shrink: 删除没有被使用的类和方法。&lt;/li&gt;
&lt;li&gt;Optimize: 对代码指令进行优化。&lt;/li&gt;
&lt;li&gt;Obfuscate: 对代码名称进行混淆。&lt;/li&gt;
&lt;li&gt;Preverify: 对 class 进行预校验，校验  StackMap /StackMapTable 属性。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;四个阶段可以独立运行的，默认全部开启，可以通过配置 &lt;code&gt;-dontshrink&lt;/code&gt;，&lt;code&gt;-dontoptimize&lt;/code&gt;，&lt;code&gt;-dontobfuscate&lt;/code&gt;，&lt;code&gt;-dontpreverify&lt;/code&gt; 关闭对应的阶段.&lt;/p&gt;
&lt;p&gt;注： ProGuard 处理 class 。class 文件可以由 &lt;a href=&quot;http://jikes.sourceforge.net/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;jikes&lt;/a&gt;  或  &lt;a href=&quot;https://docs.oracle.com/javase/6/docs/technotes/tools/windows/javac.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;javac&lt;/a&gt; 或 Kotlin 生成，  ProGuard 会根据 javac 和 jikes 特性做针对性优化。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Flutter 模块动态化初探</title>
    <link href="http://dim.red/2018/11/20/flutter_dy_exploration/"/>
    <id>http://dim.red/2018/11/20/flutter_dy_exploration/</id>
    <published>2018-11-19T16:00:00.000Z</published>
    <updated>2019-05-29T03:20:24.200Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://dim.red">dim.red</a></p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><a href="https://flutter.io/" target="_blank" rel="noopener">Flutter</a> : Flutter allows you to build beautiful native apps on iOS and Android from a single codebase.  具有跨平台, 高性能的优势.<br><a id="more"></a></p><h1 id="Flutter-产物"><a href="#Flutter-产物" class="headerlink" title="Flutter 产物"></a>Flutter 产物</h1><p><img src="/2018/11/20/flutter_dy_exploration/flutter_01.png" alt=" Flutter 产物"></p><p>产物流向:</p><p><img src="/2018/11/20/flutter_dy_exploration/flutter_02.png" alt="产物流向"><br>通过分析我们可以发现<br>不变的产物有 flutter.jar ,libfluter.so,icudtl.dat, vm_snapshot_data , vm_snapshot_instr, 不跟业务代码相关, 只跟 flutter engine 的版本有关. </p><p>变化的产物: flutter_assets , isolate_snapshot_data , isolate_snapshot_instr 主要是业务的代码和资源.<br>LICENSE 没用, 可以删除.<br>总结:<br>我们通过将不变的产物集成到APK 中.将变化组成一个资源包,通过配置下发下来.</p><h1 id="动态化改造"><a href="#动态化改造" class="headerlink" title="动态化改造"></a>动态化改造</h1><h2 id="Flutter-SDK-改造"><a href="#Flutter-SDK-改造" class="headerlink" title="Flutter SDK 改造"></a>Flutter SDK 改造</h2><p>修改 <code>Flutter.createView()</code> 方法.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">@NonNull</span><br><span class="line">  public static FlutterView createView(@NonNull final Context activity, @NonNull final Lifecycle lifecycle,</span><br><span class="line">                                       final String initialRoute, String bundlePath) &#123;</span><br><span class="line">      Context context = activity;</span><br><span class="line">      if (!TextUtils.isEmpty(bundlePath)) &#123;</span><br><span class="line">          final AssetManager bundleAsset = AssetManagerUtils.newAssetManager(bundlePath); //  Flutter  组件资源包位置</span><br><span class="line">          context = new ContextWrapper(activity) &#123;</span><br><span class="line">              @Override</span><br><span class="line">              public Resources getResources() &#123;</span><br><span class="line">                  return new Resources(bundleAsset,</span><br><span class="line">                          super.getResources().getDisplayMetrics(), super.getResources().getConfiguration()) &#123;</span><br><span class="line">                  &#125;;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      FlutterMain.startInitialization(context); // 使用自定义的 context </span><br><span class="line">      FlutterMain.ensureInitializationComplete(activity.getApplicationContext(), null);</span><br><span class="line">      final FlutterNativeView nativeView = new FlutterNativeView(context);// 使用自定义的 context </span><br><span class="line">    ...</span><br><span class="line">      return flutterView;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>这里:  通过反射 AssetManger . 同时将 bundlePath 添加进去.<br>bundlePath 的作用:</p><ul><li>用于查找 flutter_assets,  bundleAsset  会在 <code>FlutterNativeView.nativeRunBundleAndSnapshotFromLibrary()</code>传递给 Flutter 用于查找 flutter_assets  资源.</li><li>用于 copy isolate_snapshot_data , isolate_snapshot_instr 资源.</li></ul><p>Copy 资源是由 ResourceExtractor 完成的.<br>我们需要修改 ResourceExtractor.ExtractTask<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">private void extractResources() &#123;</span><br><span class="line">         final File dataDir = new File(PathUtils.getDataDirectory(mContext));</span><br><span class="line">         final AssetManager bundleManger = mContext.getResources().getAssets();</span><br><span class="line">         //获取 Apk 自身的 AssetsManger</span><br><span class="line">         final AssetManager shareManager = mContext.getApplicationContext().getResources().getAssets();</span><br><span class="line">         final String fluterBundleVersion = getFluterBundleVersion(bundleManger);</span><br><span class="line">         if (fluterBundleVersion != null) &#123;</span><br><span class="line">             Log.i(TAG, &quot;delete cache fluterBundleVersion &quot; + fluterBundleVersion);</span><br><span class="line">             deleteFiles();</span><br><span class="line">         &#125;</span><br><span class="line">         AssetManager manager;</span><br><span class="line">         byte[] buffer = null;</span><br><span class="line">         for (String asset : mResources) &#123;</span><br><span class="line">             try &#123;</span><br><span class="line">                 final File output = new File(dataDir, asset);</span><br><span class="line"></span><br><span class="line">                 if (output.exists()) &#123;</span><br><span class="line">                     continue;</span><br><span class="line">                 &#125;</span><br><span class="line">                 if (output.getParentFile() != null) &#123;</span><br><span class="line">                     output.getParentFile().mkdirs();</span><br><span class="line">                 &#125;</span><br><span class="line"></span><br><span class="line">                 manager = bundleManger;</span><br><span class="line">                 if (asset.startsWith(&quot;flutter_shared&quot;)</span><br><span class="line">                         || asset.equals(&quot;vm_snapshot_data&quot;)</span><br><span class="line">                         || asset.equals(&quot;vm_snapshot_instr&quot;)) &#123;</span><br><span class="line">                     manager = shareManager;</span><br><span class="line">                 &#125;</span><br><span class="line">                 ...</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125; catch (FileNotFoundException fnfe) &#123;</span><br><span class="line"></span><br><span class="line">                 continue;</span><br><span class="line">             &#125; catch (IOException ioe) &#123;</span><br><span class="line">                 Log.w(TAG, &quot;Exception unpacking resources: &quot; + ioe.getMessage());</span><br><span class="line">                 deleteFiles();</span><br><span class="line">                 return;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         if (fluterBundleVersion != null) &#123;</span><br><span class="line">             try &#123;</span><br><span class="line">                 new File(dataDir, fluterBundleVersion).createNewFile();</span><br><span class="line">             &#125; catch (IOException e) &#123;</span><br><span class="line">                 Log.w(TAG, &quot;Failed to write resource timestamp&quot;);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     private String getFluterBundleVersion(AssetManager bundleAssets) &#123;</span><br><span class="line">         final File dataDir = new File(PathUtils.getDataDirectory(mContext));</span><br><span class="line">         String expectedTimestamp = null;</span><br><span class="line">         try &#123;</span><br><span class="line">             InputStream in = bundleAssets.open(&quot;flutter_bundle_version&quot;);</span><br><span class="line">             expectedTimestamp = VERSION_PREFIX + IoUtils.toString(in);</span><br><span class="line">         &#125; catch (IOException e) &#123;</span><br><span class="line">             e.printStackTrace();</span><br><span class="line">         &#125;</span><br><span class="line">         if (expectedTimestamp == null) &#123;</span><br><span class="line">             return null;</span><br><span class="line">         &#125;</span><br><span class="line">         final String[] existingTimestamps = getVersionStamps(dataDir);</span><br><span class="line"></span><br><span class="line">         if (existingTimestamps == null) &#123;</span><br><span class="line">             return null;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         if (existingTimestamps.length != 1</span><br><span class="line">                 || !expectedTimestamp.equals(existingTimestamps[0])) &#123;</span><br><span class="line">             return expectedTimestamp;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         return null;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure></p><p>主要的修改:</p><ul><li>共享的资源由 APK 的 AssetsManger 中获取. 其他由 bundleManger 中获取 </li><li>修改 ResourceExtractor 更新资源逻辑, 由本来的 res_timestamp- {versionCode} -{packageInfo.lastUpdateTime} 不同就更新改为 flutter_bundle_version 不同就更新.</li></ul><h2 id="打包插件修改"><a href="#打包插件修改" class="headerlink" title="打包插件修改:"></a>打包插件修改:</h2><h3 id="组件资源插件"><a href="#组件资源插件" class="headerlink" title="组件资源插件"></a>组件资源插件</h3><p><img src="/2018/11/20/flutter_dy_exploration/flutter_03.png" alt="image.png"><br>需要做的事情:</p><ul><li>需要组合成一个APK, 因为需要被 AssetManger 识别.</li><li>不需要包含代码,</li><li>android 资源尽可能少, 但是需要 AndroidManifest.xml</li><li>flutter_bundle_version. 每次编译都应不同, 用于 ResourceExtractor 更新版本逻辑.</li><li>flutter_engine_version 获取 flutter sdk 版本, 相同版本才能升级, 防止因为版本实现不同导致的 bug.</li><li>flutter_bridge_version 是一个 md5. 是对所有自定义的  <code>MethodChannel.MethodCallHandler</code> 进行 ABI 格式化. 即 APK 具有一样的扩展能力.相同版本才能升级.</li><li>保留 isolate_snapshot_data, isolate_snapshot_instr 文件.<h3 id="lib-插件"><a href="#lib-插件" class="headerlink" title="lib 插件"></a>lib 插件</h3>Flutter 模块 一般情况我们是以 aar 的形式依赖. 需要修改上传到 maven 的AAR 如下.<br><img src="/2018/11/20/flutter_dy_exploration/flutter_04.png" alt="image.png"></li><li>保留 vm_snapshot_data, vm_snapshot_instr 文件.</li><li>保留 flutter_bundle_version ,flutter_engine_version,flutter_bridge_version 作用如上.</li></ul><h2 id="flutter-gradle-修改"><a href="#flutter-gradle-修改" class="headerlink" title="flutter.gradle 修改"></a>flutter.gradle 修改</h2><ul><li>copy  {flutter sdk}\flutter\packages\flutter_tools\gradle\flutter.gradle</li><li>修改 release  依赖为自定义的 flutter jar.</li></ul><h1 id="尾巴"><a href="#尾巴" class="headerlink" title="尾巴"></a>尾巴</h1><p>  更详情的分析留在后面。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://dim.red&quot;&gt;dim.red&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://flutter.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Flutter&lt;/a&gt; : Flutter allows you to build beautiful native apps on iOS and Android from a single codebase.  具有跨平台, 高性能的优势.&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Android 中的引用类型初探</title>
    <link href="http://dim.red/2018/11/18/android_reference_exploration/"/>
    <id>http://dim.red/2018/11/18/android_reference_exploration/</id>
    <published>2018-11-17T16:00:00.000Z</published>
    <updated>2019-05-29T03:21:53.193Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://dim.red">dim.red</a></p><h1 id="引用种类"><a href="#引用种类" class="headerlink" title="引用种类"></a>引用种类</h1><ul><li><p>强引用:在 GC 中如果发现一个对象是可达的，那么 GC 在任何情况都不会回收这个对象</p></li><li><p><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/ref/SoftReference.html" target="_blank" rel="noopener">软引用(SoftReference)</a>：在 GC 中如果发现一个对象是软可达的 。那么 GC 可以根据内存情况清除这些对象。并且保证在抛出 OutOfMemoryError 异常之前。所有的软引用的对象是已经回收过。 </p></li><li><p><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/ref/WeakReference.html" target="_blank" rel="noopener">弱引用(WeakReference)</a>：在 GC 中如果发现一个对象是软可达的，GC 会回收这些对象。</p></li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/ref/PhantomReference.html" target="_blank" rel="noopener">虚引用(PhantomReference)</a>：在 GC 中如果发现是一个幽灵引用的时候，GC 会回收这些对象。</li></ul><p>总结： 强引用在任何情况都不会被回收。软引用在 GC 可以被回收。弱引用和虚引用在 GC 中会尽可能回收。</p><h1 id="GC-流程简介"><a href="#GC-流程简介" class="headerlink" title="GC 流程简介"></a>GC 流程简介</h1><p>Android GC 主要分为 标记 和 清除 阶段、 通过定义两个 Bitmap， Live Bitmap 和 Mark Bitmap ， 前者表示上次 GC 存活的对象。后者表示这次 GC 存活的对象。 Mark Bitmap 存在 而 Live Bitmap 不存在的为当前 GC 回收的对象。 GC 结束的时候将  Mark Bitmap  设置为 Live Bitmap。 不管并行还是串行GC， 或者 ART 的 GC 基本流程类似。<br><a id="more"></a></p><h2 id="Reference-状态。"><a href="#Reference-状态。" class="headerlink" title="Reference 状态。"></a>Reference 状态。</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Reference&lt;T&gt; &#123;</span><br><span class="line">    ...</span><br><span class="line">    volatile T referent; </span><br><span class="line"></span><br><span class="line">    final ReferenceQueue&lt;? super T&gt; queue; </span><br><span class="line"></span><br><span class="line">    Reference queueNext;</span><br><span class="line"></span><br><span class="line">    Reference&lt;?&gt; pendingNext;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参数介绍：</p><ul><li>referent：引用对象， referent 回收的时候设置为 null。</li><li>queue ：声明的队列。 不为空的时候，在 referent 被回收以后，最终 Reference 会被添加到队列中去。</li><li>queueNext ：默认为 null， 在 <code>Enqueued</code> 状态表示同一个 queue 下，下一个 Reference 节点。</li><li>pendingNext：默认为 null ，在 <code>Pending</code> 的时候，表示下一个待处理 Reference 节点</li></ul><h3 id="状态装换"><a href="#状态装换" class="headerlink" title="状态装换"></a>状态装换</h3><p>Reference  有 4 种状态 <code>Active</code>,<code>Pending</code>,<code>Enqueued</code>,<code>Inactive</code>。<br><img src="/2018/11/18/android_reference_exploration/reference_01.png" alt="image.png"></p><ul><li>queue 不为空：</li></ul><p>声明的时候默认为  <code>Active</code> 状态（ queueNext  为空 ，pendingNext 为空 ）。在 GC 发现 referent 对象可以被回收，回收 referent ，设置 referent 为 null ， 将 Reference 放在 clear 队列当中。 状态为 <code>Pending</code> 状态（ queueNext  为空 ，pendingNext 不为空 ），GC 会唤醒 ReferenceQueueDaemon 线程处理引用 clear 队列。 ReferenceQueueDaemon 处理  clear 队列。将  Reference 对象放到 queue 队列里面去。 状态为 <code>Enqueued</code> 状态（ queueNext  不为空 ，pendingNext 为 Reference ）。 当 queue  调用 poll() 将 Reference 获取出来。 状态为 <code>Inactive</code>（ queueNext 为 ReferenceQueue.sQueueNextUnenqueued，pendingNext 为 Reference）。</p><ul><li>queue 为空</li></ul><p>声明的时候默认为  <code>Active</code> 状态（queueNext  为空 ，pendingNext 为空 ）。在 GC 发现 referent 对象可以被回收，回收 referent ，设置 referent 为 null 。状态为 <code>Inactive</code> （queueNext  为空 ，pendingNext 为空 ）。</p><h1 id="Reference-处理流程。"><a href="#Reference-处理流程。" class="headerlink" title="Reference 处理流程。"></a>Reference 处理流程。</h1><h3 id="虚拟机启动"><a href="#虚拟机启动" class="headerlink" title="虚拟机启动"></a>虚拟机启动</h3><p>虚拟机启动的时候会启动守护线程。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public final class Daemons&#123;</span><br><span class="line">   public static void start() &#123;</span><br><span class="line">        ReferenceQueueDaemon.INSTANCE.start(); // 引用队列处理。 </span><br><span class="line">        FinalizerDaemon.INSTANCE.start(); // 处理 finalize 线程</span><br><span class="line">        FinalizerWatchdogDaemon.INSTANCE.start(); // 监听 finalize 方法超时。</span><br><span class="line">        HeapTaskDaemon.INSTANCE.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="加载链接类"><a href="#加载链接类" class="headerlink" title="加载链接类"></a>加载链接类</h3><p>在 虚拟机加载和链接类的时候，会对 Class 进行引用类型判断。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> */</span><br><span class="line">enum ClassFlags &#123;</span><br><span class="line"> ...</span><br><span class="line">    CLASS_ISREFERENCE          = (1&lt;&lt;27), // class is a soft/weak/phantom ref</span><br><span class="line">                                          // only ISREFERENCE is set --&gt; soft</span><br><span class="line">    CLASS_ISWEAKREFERENCE      = (1&lt;&lt;26), // class is a weak reference</span><br><span class="line">    CLASS_ISFINALIZERREFERENCE = (1&lt;&lt;25), // class is a finalizer reference</span><br><span class="line">    CLASS_ISPHANTOMREFERENCE   = (1&lt;&lt;24), // class is a phantom reference</span><br><span class="line"></span><br><span class="line"> ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">static void loadMethodFromDex(ClassObject* clazz, const DexMethod* pDexMethod,</span><br><span class="line">    Method* meth)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    if (dvmCompareNameDescriptorAndMethod(&quot;finalize&quot;, &quot;()V&quot;, meth) == 0) &#123;</span><br><span class="line"></span><br><span class="line">        if (clazz-&gt;classLoader != NULL ||</span><br><span class="line">            strcmp(clazz-&gt;descriptor, &quot;Ljava/lang/Enum;&quot;) != 0)</span><br><span class="line">        &#123;</span><br><span class="line">            SET_CLASS_FLAG(clazz, CLASS_ISFINALIZABLE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加载类的时候如果发现自定义了 finalize 方法， 那么会在 class 的 <code>accessFlags</code> 对象打上 <code>CLASS_ISFINALIZABLE</code> 标志。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">bool dvmLinkClass(ClassObject* clazz)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line"> </span><br><span class="line">    if (strcmp(clazz-&gt;descriptor, &quot;Ljava/lang/Object;&quot;) == 0) &#123;</span><br><span class="line">        /* Don&apos;t finalize objects whose classes use the</span><br><span class="line">         * default (empty) Object.finalize().</span><br><span class="line">         */</span><br><span class="line">        CLEAR_CLASS_FLAG(clazz, CLASS_ISFINALIZABLE);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">       </span><br><span class="line">        if (IS_CLASS_FLAG_SET(clazz-&gt;super, CLASS_ISFINALIZABLE)) &#123;</span><br><span class="line">            SET_CLASS_FLAG(clazz, CLASS_ISFINALIZABLE);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /* See if this class descends from java.lang.Reference</span><br><span class="line">         * and set the class flags appropriately.</span><br><span class="line">         */</span><br><span class="line">        if (IS_CLASS_FLAG_SET(clazz-&gt;super, CLASS_ISREFERENCE)) &#123;</span><br><span class="line">            u4 superRefFlags;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">            superRefFlags = GET_CLASS_FLAG_GROUP(clazz-&gt;super,</span><br><span class="line">                    CLASS_ISREFERENCE |</span><br><span class="line">                    CLASS_ISWEAKREFERENCE |</span><br><span class="line">                    CLASS_ISFINALIZERREFERENCE |</span><br><span class="line">                    CLASS_ISPHANTOMREFERENCE);</span><br><span class="line">            SET_CLASS_FLAG(clazz, superRefFlags);</span><br><span class="line">        &#125; else if (clazz-&gt;classLoader == NULL &amp;&amp;</span><br><span class="line">                clazz-&gt;super-&gt;classLoader == NULL &amp;&amp;</span><br><span class="line">                strcmp(clazz-&gt;super-&gt;descriptor,</span><br><span class="line">                       &quot;Ljava/lang/ref/Reference;&quot;) == 0)</span><br><span class="line">        &#123;</span><br><span class="line">            u4 refFlags;</span><br><span class="line"></span><br><span class="line">            refFlags = CLASS_ISREFERENCE;</span><br><span class="line">            if (strcmp(clazz-&gt;descriptor,</span><br><span class="line">                       &quot;Ljava/lang/ref/SoftReference;&quot;) == 0)</span><br><span class="line">            &#123;</span><br><span class="line">            &#125; else if (strcmp(clazz-&gt;descriptor,</span><br><span class="line">                       &quot;Ljava/lang/ref/WeakReference;&quot;) == 0)</span><br><span class="line">            &#123;</span><br><span class="line">                refFlags |= CLASS_ISWEAKREFERENCE;</span><br><span class="line">            &#125; else if (strcmp(clazz-&gt;descriptor,</span><br><span class="line">                       &quot;Ljava/lang/ref/FinalizerReference;&quot;) == 0)</span><br><span class="line">            &#123;</span><br><span class="line">                refFlags |= CLASS_ISFINALIZERREFERENCE;</span><br><span class="line">            &#125;  else if (strcmp(clazz-&gt;descriptor,</span><br><span class="line">                       &quot;Ljava/lang/ref/PhantomReference;&quot;) == 0)</span><br><span class="line">            &#123;</span><br><span class="line">                refFlags |= CLASS_ISPHANTOMREFERENCE;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                /* No-one else is allowed to inherit directly</span><br><span class="line">                 * from Reference.</span><br><span class="line">                 */</span><br><span class="line">//xxx is this the right exception?  better than an assertion.</span><br><span class="line">                dvmThrowLinkageError(&quot;illegal inheritance from Reference&quot;);</span><br><span class="line">                goto bail;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            SET_CLASS_FLAG(clazz, refFlags);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   ...</span><br><span class="line">    return okay;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>链接类的时候:<br>当一个 Class 是 <code>SoftReference</code> 或者它的派生类则它的 <code>accessFlags</code> 会被设置为 <code>CLASS_ISREFERENCE</code> 。<br>当一个 Class 是 WeakReference 或者 它的派生类则它的 <code>accessFlags</code> 被设置为<code>CLASS_ISREFERENCE</code> | <code>CLASS_ISPHANTOMREFERENCE</code>。<br>当一个 Class 是 <code>PhantomReference</code> 或者 它的派生类则它的 <code>accessFlags</code> 被设置为 <code>CLASS_ISREFERENCE</code> | <code>CLASS_ISPHANTOMREFERENCE</code>。<br>当一个 Class 是 <code>FinalizerReference</code> 则它的 <code>accessFlags</code> 被设置为 <code>CLASS_ISREFERENCE</code> | <code>CLASS_ISFINALIZERREFERENCE</code>。 它没有派生类， 因为 <code>FinalizerReference</code> 是 Final 。<br>当一个 Class 拥有自定义的 <code>finalize()</code>方法， 或者父类拥有<code>finalize()</code>方法， 那么就会被打上 <code>CLASS_ISFINALIZABLE</code> 标识。 这里有一个是例外 。<code>Object</code>的 <code>finalize()</code>是一个空实现。 它又是所有类的父类。 它会被清除 <code>CLASS_ISFINALIZABLE</code> 标识。因为如果不这样， 所有的类都将被打上 <code>CLASS_ISFINALIZABLE</code>。</p><h3 id="对象初始化。"><a href="#对象初始化。" class="headerlink" title="对象初始化。"></a>对象初始化。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/* File: c/OP_INVOKE_OBJECT_INIT_RANGE.cpp */</span><br><span class="line">HANDLE_OPCODE(OP_INVOKE_OBJECT_INIT_RANGE /*&#123;vCCCC..v(CCCC+AA-1)&#125;, meth@BBBB*/)</span><br><span class="line">    &#123;</span><br><span class="line">     ...</span><br><span class="line">         */</span><br><span class="line">        if (IS_CLASS_FLAG_SET(obj-&gt;clazz, CLASS_ISFINALIZABLE)) &#123;</span><br><span class="line">            EXPORT_PC();</span><br><span class="line">            dvmSetFinalizable(obj);</span><br><span class="line">            if (dvmGetException(self))</span><br><span class="line">                GOTO_exceptionThrown();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">     ...</span><br><span class="line">        FINISH(3);</span><br><span class="line">    &#125;</span><br><span class="line">OP_END</span><br></pre></td></tr></table></figure><p>在类初始化的时候， 会根据 class 是否有 <code>CLASS_ISFINALIZABLE</code>， 即 拥有 自定义 finalize 方法。 那么会调用 <code>dvmSetFinalizable</code>， <code>dvmSetFinalizable</code> 内部调用了 Java 的 <code>FinalizerReference.add</code> 方法。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public final class FinalizerReference&lt;T&gt; extends Reference&lt;T&gt;&#123;</span><br><span class="line">    // This queue contains those objects eligible for finalization.</span><br><span class="line">    public static final ReferenceQueue&lt;Object&gt; queue = new ReferenceQueue&lt;Object&gt;();</span><br><span class="line"></span><br><span class="line">    public static void add(Object referent) &#123;</span><br><span class="line">        FinalizerReference&lt;?&gt; reference = new FinalizerReference&lt;Object&gt;(referent, queue);</span><br><span class="line">        synchronized (LIST_LOCK) &#123;</span><br><span class="line">            reference.prev = null;</span><br><span class="line">            reference.next = head;</span><br><span class="line">            if (head != null) &#123;</span><br><span class="line">                head.prev = reference;</span><br><span class="line">            &#125;</span><br><span class="line">            head = reference;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里生成了一个新的引用 <code>FinalizerReference</code> 来持有对象，所有的<code>FinalizerReference</code> 设置同一个 <code>queue</code> 。同时将所有的 <code>FinalizerReference</code> 串联起来。</p><h1 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h1><p>标记动作就是从 根集 对象开始标记，在标记对象的时候，会根据对象的引用类型，添加到对应的引用队列中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">*</span><br><span class="line"> * Process the &quot;referent&quot; field in a java.lang.ref.Reference.  If the</span><br><span class="line"> * referent has not yet been marked, put it on the appropriate list in</span><br><span class="line"> * the gcHeap for later processing.</span><br><span class="line"> */</span><br><span class="line">static void delayReferenceReferent(Object *obj, GcMarkContext *ctx)</span><br><span class="line">&#123;</span><br><span class="line">   ...</span><br><span class="line">       if (pending == NULL &amp;&amp; referent != NULL &amp;&amp; !isMarked(referent, ctx)) &#123;</span><br><span class="line">        Object **list = NULL;</span><br><span class="line">        if (isSoftReference(obj)) &#123;</span><br><span class="line">            list = &amp;gcHeap-&gt;softReferences;</span><br><span class="line">        &#125; else if (isWeakReference(obj)) &#123;</span><br><span class="line">            list = &amp;gcHeap-&gt;weakReferences;</span><br><span class="line">        &#125; else if (isFinalizerReference(obj)) &#123;</span><br><span class="line">            list = &amp;gcHeap-&gt;finalizerReferences;</span><br><span class="line">        &#125; else if (isPhantomReference(obj)) &#123;</span><br><span class="line">            list = &amp;gcHeap-&gt;phantomReferences;</span><br><span class="line">        &#125;</span><br><span class="line">        assert(list != NULL);</span><br><span class="line">        enqueuePendingReference(obj, list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>接下来处理 4 种引用队列。 软引用， 弱引用， 虚引用， finalizer 引用队列<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">void dvmHeapProcessReferences(Object **softReferences, bool clearSoftRefs,</span><br><span class="line">                              Object **weakReferences,</span><br><span class="line">                              Object **finalizerReferences,</span><br><span class="line">                              Object **phantomReferences)</span><br><span class="line">&#123;</span><br><span class="line"> ...</span><br><span class="line">    /*</span><br><span class="line">     * Unless we are in the zygote or required to clear soft</span><br><span class="line">     * references with white references, preserve some white</span><br><span class="line">     * referents.</span><br><span class="line">     */</span><br><span class="line">    if (!gDvm.zygote &amp;&amp; !clearSoftRefs) &#123;</span><br><span class="line">        preserveSomeSoftReferences(softReferences);</span><br><span class="line">    &#125;</span><br><span class="line">    /*</span><br><span class="line">     * Clear all remaining soft and weak references with white</span><br><span class="line">     * referents.</span><br><span class="line">     */</span><br><span class="line">    clearWhiteReferences(softReferences);</span><br><span class="line">    clearWhiteReferences(weakReferences);</span><br><span class="line">    /*</span><br><span class="line">     * Preserve all white objects with finalize methods and schedule</span><br><span class="line">     * them for finalization.</span><br><span class="line">     */</span><br><span class="line">    enqueueFinalizerReferences(finalizerReferences);</span><br><span class="line">    /*</span><br><span class="line">     * Clear all f-reachable soft and weak references with white</span><br><span class="line">     * referents.</span><br><span class="line">     */</span><br><span class="line">    clearWhiteReferences(softReferences);</span><br><span class="line">    clearWhiteReferences(weakReferences);</span><br><span class="line">    /*</span><br><span class="line">     * Clear all phantom references with white referents.</span><br><span class="line">     */</span><br><span class="line">    clearWhiteReferences(phantomReferences);</span><br><span class="line">    /*</span><br><span class="line">     * At this point all reference lists should be empty.</span><br><span class="line">     */</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">static void clearWhiteReferences(Object **list)</span><br><span class="line">&#123;</span><br><span class="line">    GcMarkContext *ctx = &amp;gDvm.gcHeap-&gt;markContext;</span><br><span class="line">    size_t referentOffset = gDvm.offJavaLangRefReference_referent;</span><br><span class="line">    while (*list != NULL) &#123;</span><br><span class="line">        Object *ref = dequeuePendingReference(list);</span><br><span class="line">        Object *referent = dvmGetFieldObject(ref, referentOffset);</span><br><span class="line">        if (referent != NULL &amp;&amp; !isMarked(referent, ctx)) &#123;</span><br><span class="line">            /* Referent is white, clear it. */</span><br><span class="line">            clearReference(ref);</span><br><span class="line">            if (isEnqueuable(ref)) &#123;</span><br><span class="line">                enqueueReference(ref);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">static void enqueueReference(Object *ref)</span><br><span class="line">&#123;</span><br><span class="line">    assert(ref != NULL);</span><br><span class="line">    assert(dvmGetFieldObject(ref, gDvm.offJavaLangRefReference_queue) != NULL);</span><br><span class="line">    assert(dvmGetFieldObject(ref, gDvm.offJavaLangRefReference_queueNext) == NULL);</span><br><span class="line">    enqueuePendingReference(ref, &amp;gDvm.gcHeap-&gt;clearedReferences);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>对于弱引用，虚引用， 如果他们没有被标记，那么他们所持有的对象将会回收，referent 设置为 null 。 而他们本身根据 queue 是否为空进入不同状态， 为空将进入<code>Inactive</code> 状态。 不为空 进入<code>Pending</code> 状态。 所有的引用类型会被添加到 Clear 队列中。 此时加入的队列并不是他们自己的 queue 。<br>对软引用来说. 并不会全部回收， 默认情况会回收一半。除非是即将发生 OOM 才会全部回收。这也是软引用和 弱引用，虚引用的主要区别。<br>对于 <code>FinalizerReferences</code> 队列来说的话， 需要调用 <code>enqueueFinalizerReferences</code> 方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">static void enqueueFinalizerReferences(Object **list)</span><br><span class="line">&#123;</span><br><span class="line">    GcMarkContext *ctx = &amp;gDvm.gcHeap-&gt;markContext;</span><br><span class="line">    size_t referentOffset = gDvm.offJavaLangRefReference_referent;</span><br><span class="line">    size_t zombieOffset = gDvm.offJavaLangRefFinalizerReference_zombie;</span><br><span class="line">    bool hasEnqueued = false;</span><br><span class="line">    while (*list != NULL) &#123;</span><br><span class="line">        Object *ref = dequeuePendingReference(list);</span><br><span class="line">        Object *referent = dvmGetFieldObject(ref, referentOffset);</span><br><span class="line">        if (referent != NULL &amp;&amp; !isMarked(referent, ctx)) &#123;</span><br><span class="line">            markObject(referent, ctx);</span><br><span class="line">            dvmSetFieldObject(ref, zombieOffset, referent);</span><br><span class="line">            clearReference(ref);</span><br><span class="line">            enqueueReference(ref);</span><br><span class="line">            hasEnqueued = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (hasEnqueued) &#123;</span><br><span class="line">        processMarkStack(ctx);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于还需要执行 finalizer 方法。 所以需要将还没执行过 finalizer 方法并且未标记的对象标记，防止执行 finalizer 方法前对象被销毁了。然后将 Reference 添加到 Clear 队列。</p><p>注: 将 Reference 加入自身的 queue  方法 和  finalizer 方法均不在 GC 过程中调用。因为 GC 时间是宝贵的。 </p><p>处理后续  Clear 队列 交给了守护线程 ReferenceQueueDaemon 。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">private static class ReferenceQueueDaemon extends Daemon &#123;</span><br><span class="line">    private static final ReferenceQueueDaemon INSTANCE = new ReferenceQueueDaemon();</span><br><span class="line"></span><br><span class="line">    ReferenceQueueDaemon() &#123;</span><br><span class="line">        super(&quot;ReferenceQueueDaemon&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override public void runInternal() &#123;</span><br><span class="line">        while (isRunning()) &#123;</span><br><span class="line">            Reference&lt;?&gt; list;</span><br><span class="line">            try &#123;</span><br><span class="line">                synchronized (ReferenceQueue.class) &#123;</span><br><span class="line">                    while (ReferenceQueue.unenqueued == null) &#123;</span><br><span class="line">                        ReferenceQueue.class.wait();</span><br><span class="line">                    &#125;</span><br><span class="line">                    list = ReferenceQueue.unenqueued; // </span><br><span class="line">                    ReferenceQueue.unenqueued = null;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125; catch (OutOfMemoryError e) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            // 添加到自己的 queue</span><br><span class="line">            ReferenceQueue.enqueuePending(list);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>ReferenceQueue.unenqueued 就是 Clear 队列。将引用添加到自己的 queue 里面。 状态由 <code>Pending</code> 变更为 <code>Enqueued</code> 。</p><p>对于 <code>FinalizerReference</code> 对象的 finalize 方法。 它的处理交给 <code>FinalizerDaemon</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">private static class FinalizerDaemon extends Daemon &#123;</span><br><span class="line"></span><br><span class="line">       private final ReferenceQueue&lt;Object&gt; queue = FinalizerReference.queue;</span><br><span class="line">       @Override public void runInternal() &#123;</span><br><span class="line"></span><br><span class="line">           while (isRunning()) &#123;</span><br><span class="line">               try &#123;</span><br><span class="line">                   ...</span><br><span class="line">                   FinalizerReference&lt;?&gt; finalizingReference = (FinalizerReference&lt;?&gt;)queue.poll();</span><br><span class="line">                   ...</span><br><span class="line">                   doFinalize(finalizingReference);</span><br><span class="line">               &#125; catch (InterruptedException ignored) &#123;</span><br><span class="line">               &#125; catch (OutOfMemoryError ignored) &#123;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       private void doFinalize(FinalizerReference&lt;?&gt; reference) &#123;</span><br><span class="line">           FinalizerReference.remove(reference);</span><br><span class="line">           Object object = reference.get();</span><br><span class="line">           reference.clear();</span><br><span class="line">           try &#123;</span><br><span class="line">               object.finalize();</span><br><span class="line">           &#125; catch (Throwable ex) &#123;    </span><br><span class="line">           &#125; finally &#123;</span><br><span class="line">               finalizingObject = null;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>它是处理是从 <code>FinalizerReference</code> 的 queue 获取 <code>FinalizerReference</code>。 这里 queue 里面存的 <code>FinalizerReference</code> 已经是<code>Enqueued</code> 说明它持有的对象，已经应该需要销毁了。 所有获取的对象然后调用他们的  finalize 方法， 同时拦截所有的异常。并且不做处理。直接结束。 下次的 GC 就可以直接带走这些对象。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://dim.red&quot;&gt;dim.red&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;引用种类&quot;&gt;&lt;a href=&quot;#引用种类&quot; class=&quot;headerlink&quot; title=&quot;引用种类&quot;&gt;&lt;/a&gt;引用种类&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;强引用:在 GC 中如果发现一个对象是可达的，那么 GC 在任何情况都不会回收这个对象&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/lang/ref/SoftReference.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;软引用(SoftReference)&lt;/a&gt;：在 GC 中如果发现一个对象是软可达的 。那么 GC 可以根据内存情况清除这些对象。并且保证在抛出 OutOfMemoryError 异常之前。所有的软引用的对象是已经回收过。 &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/lang/ref/WeakReference.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;弱引用(WeakReference)&lt;/a&gt;：在 GC 中如果发现一个对象是软可达的，GC 会回收这些对象。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/lang/ref/PhantomReference.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;虚引用(PhantomReference)&lt;/a&gt;：在 GC 中如果发现是一个幽灵引用的时候，GC 会回收这些对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;总结： 强引用在任何情况都不会被回收。软引用在 GC 可以被回收。弱引用和虚引用在 GC 中会尽可能回收。&lt;/p&gt;
&lt;h1 id=&quot;GC-流程简介&quot;&gt;&lt;a href=&quot;#GC-流程简介&quot; class=&quot;headerlink&quot; title=&quot;GC 流程简介&quot;&gt;&lt;/a&gt;GC 流程简介&lt;/h1&gt;&lt;p&gt;Android GC 主要分为 标记 和 清除 阶段、 通过定义两个 Bitmap， Live Bitmap 和 Mark Bitmap ， 前者表示上次 GC 存活的对象。后者表示这次 GC 存活的对象。 Mark Bitmap 存在 而 Live Bitmap 不存在的为当前 GC 回收的对象。 GC 结束的时候将  Mark Bitmap  设置为 Live Bitmap。 不管并行还是串行GC， 或者 ART 的 GC 基本流程类似。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="android" scheme="http://dim.red/categories/android/"/>
    
    
  </entry>
  
  <entry>
    <title>Gradle Configuration</title>
    <link href="http://dim.red/2018/11/03/gradle_configuration_exploration/"/>
    <id>http://dim.red/2018/11/03/gradle_configuration_exploration/</id>
    <published>2018-11-02T16:00:00.000Z</published>
    <updated>2019-05-29T03:44:30.676Z</updated>
    
    <content type="html"><![CDATA[<h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><p>Gradle：4.4.1</p><h1 id="Configuration-介绍"><a href="#Configuration-介绍" class="headerlink" title="Configuration 介绍"></a>Configuration 介绍</h1><p>通过声明的方式定义了一组依赖。Gradle 通过声明的方式查找对应依赖产物和他们的自身的依赖产物。它代表一组文件。只是这些文件是根据声明信息从本地或远程仓库中获取的。<br> <a id="more"></a></p><h1 id="Configuration-状态"><a href="#Configuration-状态" class="headerlink" title="Configuration 状态"></a>Configuration 状态</h1><p>状态分为三个 UNRESOLVED（未解析），RESOLVED（解析成功）/ RESOLVED_WITH_FAILURES（解析失败）<br>从未解析到解析成功或解析失败主要涉及两个过程，一 解析依赖图，二 获取产物。</p><h2 id="一-解析依赖图"><a href="#一-解析依赖图" class="headerlink" title="一 解析依赖图"></a>一 解析依赖图</h2><p>主要的功能是使用广度优先算法遍历解析依赖图。同时解决依赖图中相同依赖的版本冲突。</p><h3 id="解析冲突策略"><a href="#解析冲突策略" class="headerlink" title="解析冲突策略"></a>解析冲突策略</h3><p>解决版本冲突方式主要使用 3 种策略：</p><h4 id="1-版本优先："><a href="#1-版本优先：" class="headerlink" title="1 版本优先："></a>1 版本优先：</h4><p><code>LatestModuleConflictResolver</code><br>一个版本号版本被分为2两部分。<code>数字版本号</code>+<code>限定版本号</code>。<code>数字版本号</code>开始的数字的部分。剩下的为<code>限定版本号</code>在通常版本号分为<br><img src="/2018/11/03/gradle_configuration_exploration/configuration_01.png" alt="image.png"></p><p>eg：1.2.3-bate3，[1,2,3] 为<code>数字版本号</code>，[bate,3] 为 <code>限定版本号</code><br>比较原则</p><ol><li><code>数字版本号</code>比较大小，逐个比较数字部分，数字大的版本号大<br>eg： 1.2.3 &gt; 1.1.19 ，1.2.3.1 &gt; 1.2.3 </li><li><code>限定版本号</code>比较大小，数字 &gt; final &gt; release &gt; rc &gt; (任意非数字字符)  &gt; dev 。任意非数字字符比较方式是逐个比较 Char 的 ASCII码值。</li><li><code>数字版本号</code>大的版本号大。</li><li><code>数字版本号</code> 相同，没有<code>限定版本号</code> 大于有<code>限定版本号</code>。<br>eg：1.2.3 &gt;1.2.3-beta</li><li><code>数字版本号</code> 相同，<code>限定版本号</code>大的版本号大。<br>eg: 1.2.3-final &gt; 1.2.3-release &gt; 1.2.3-rc3 &gt; 1.2.3-rc  &gt; 1.2.3-beta &gt; 1.2.3-dev </li><li><code>数字版本号</code>相同，非 SNAPSHOT 大于 SNAPSHOT版本。<br>eg:1.2.3-beta &gt; 1.2.3-SNAPSHOT(注意全部大小)</li><li>版本声明顺序不影响版本号的比较。</li><li>一个依赖版本被选中，那么它的父节点也要被选中。</li></ol><h5 id="版本比较中的魔幻"><a href="#版本比较中的魔幻" class="headerlink" title="版本比较中的魔幻"></a>版本比较中的魔幻</h5><p>Q：版本 0.1.1-20181030.154719-1 跟 0.1.1-beta 哪个版本比较新？<br>A：0.1.1-beta。 虽然<code>数字版本号</code> 相同，限定版本 [20181030,154719,1] 大于 [beta]，但是 0.1.1-20181030.154719-1 满足正则<code>(.+)-\\d{8}\\.\\d{6}-\\d+·</code>会被解析成 0.1.1-SNAPSHOT 中的 20181030.154719-1版本 , 所以 0.1.1-20181030.154719-1 是个 SNAPSHOT 版本。对应比较原则中的第6原则，非 SNAPSHOT 大于 SNAPSHOT版本。</p><p>Q：版本 0.1.1-20181030.154719-1 跟 0.1.1-SNAPSHOT 哪个版本比较新？<br>A： 0.1.1-20181030.154719-1 </p><p>Q：1.2.1-SNAPSHOT VS 1.2.0<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">情况A：</span><br><span class="line">&apos;com.dim.red:one:1.2.0&apos;</span><br><span class="line">&apos;com.dim.red:one:1.2.1-SNAPSHOT&apos;</span><br><span class="line">情况B：</span><br><span class="line">&apos;com.dim.red:one:1.2.1-SNAPSHOT&apos;</span><br><span class="line">&apos;com.dim.red:one:1.2.0&apos;</span><br></pre></td></tr></table></figure></p><p>1.2.0 跟 1.2.1-SNAPSHOT 哪个版本比较,谁比较新？情况 A 和情况 B 会有不同吗？<br>A: 通过比较原则中 1 和 6 。那么 1.2.1-SNAPSHOT 不管在情况 A 和情况 B 中都应该始终大于 1.2.0 。但是在 Gradle 在 4.4 - 4.6 版本中存在一个BUG。<br>将导致的问题是情况 A 1.2.0 版本大于 1.2.1-SNAPSHOT。 情况 B 1.2.1-SNAPSHOT 大于 1.2.0。具体的原因可以比对版本 4.4.1 和 4.10.2 的实现。<br><a href="https://github.com/gradle/gradle/blob/v4.4.1/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/resolveengine/LatestModuleConflictResolver.java" target="_blank" rel="noopener">LatestModuleConflictResolver.select(details) （4.4.1）</a><br><a href="https://github.com/gradle/gradle/blob/v4.10.2/subprojects/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/resolveengine/LatestModuleConflictResolver.java" target="_blank" rel="noopener">LatestModuleConflictResolver.select(details)（4.10.2 ） </a></p><p>Q：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">情况A</span><br><span class="line">com.dim.red:a:2.0.0</span><br><span class="line">\--- com.dim.red:b:1.2.0</span><br><span class="line">com.dim.red:c:1.0</span><br><span class="line">\--- com.dim.red:a:2.2.0</span><br><span class="line">     \--- com.dim.red:b:1.0.0</span><br><span class="line">情况B</span><br><span class="line">com.dim.red:c:1.0.0</span><br><span class="line">\--- com.dim.red:a:2.2.0</span><br><span class="line">     \--- com.dim.red:b:1.0.0</span><br><span class="line">com.dim.red:a:2.0.0</span><br><span class="line">\--- com.dim.red:b:1.2.0</span><br></pre></td></tr></table></figure></p><p>依赖 com.dim.red:b 会选中什么版本？情况 A 和情况 B 会有不同吗？<br>A：通过比较原则中 7 和 8。所以应该是 c:1.0，a:2.2.0，b:1.0.0。<br>但是在 Gradle 的不同版本实现中表现却不一样。在 Gradle 4.9 以下情况 A 会选中版本 c:1.0.0，a:2.2.0，b:1.2.0。而情况 B 选中版本 c:1.0.0，a:2.2.0，b:1.0.0  这里明显是一个BUG。 4.9 修正这个BUG。原因在于 4.9 以下在版本比较中没有过滤掉父节点为空的版本。但是 4.9 的版本中存在一个新的BUG #7050 。该 BUG 在5.0-rc中修复。但是 Gradle 5.0 - rc 的版本还不兼容现有的 Android Gradle Plugin 3.2.1 版本。 </p><h4 id="2-严格模式"><a href="#2-严格模式" class="headerlink" title="2 严格模式"></a>2 严格模式</h4><p><code>StrictConflictResolver</code><br> 不允许出现版本冲突。当出现版本冲突的时候，需要手动强制声明锁定版本。 </p><h4 id="3-项目优先"><a href="#3-项目优先" class="headerlink" title="3 项目优先"></a>3 项目优先</h4><p><code>ProjectDependencyForcingResolver</code><br>本地项目版本大于远程依赖版本。当没有远程或多个本地项目，使用版本优先算法进行比较。</p><h4 id="强制声明锁定版本"><a href="#强制声明锁定版本" class="headerlink" title="强制声明锁定版本"></a>强制声明锁定版本</h4><p>声明以后，在发生版本冲突的时候会直接选择锁定版本。而不需要经过策略。<br>锁定版本方式有两种：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">implementation (&apos;com.google.code.gson:gson:2.8.5&apos;)&#123;</span><br><span class="line">    force = true </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>或<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">configurations.all &#123;</span><br><span class="line">    resolutionStrategy &#123; </span><br><span class="line">        force &apos;com.google.code.gson:gson:2.8.5‘</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="策略设置"><a href="#策略设置" class="headerlink" title="策略设置"></a>策略设置</h3><p>默认策略为版本优先。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">configurations.all &#123;</span><br><span class="line">    resolutionStrategy &#123; </span><br><span class="line">    // 默认为版本优先模式</span><br><span class="line">//       failOnVersionConflict() // 切换策略为严格模式</span><br><span class="line">//       preferProjectModules() // 切换策略为项目优先模式。</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>解析依赖图是一件复杂的事情。Gradle 在上面做的并不好。 或许在 5.0 上会有更稳定，更健壮的表现。所以我们需要特别关心最终打到 APK 的依赖版本。可以使用命令 gradlew :{moduleName}:dependencies  或参考 <a href="https://dim.red/2018/02/05/android_dependency_analyse_code/">输出 Apk 所有的依赖</a> 文章分析 APK 的依赖。</p><h2 id="二-获取产物"><a href="#二-获取产物" class="headerlink" title="二 获取产物"></a>二 获取产物</h2><h3 id="缓存策略"><a href="#缓存策略" class="headerlink" title="缓存策略"></a>缓存策略</h3><p>在获取产物过程中，会先从缓存中获取。如果缓存有效。则直接从缓存中获取。缓存无效则请求远程仓库。<br>设置缓存策略：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">configurations.all &#123;</span><br><span class="line">  resolutionStrategy &#123;</span><br><span class="line">    // cache dynamic versions for 10 minutes</span><br><span class="line">    cacheDynamicVersionsFor 10*60, &apos;seconds&apos;</span><br><span class="line">    // don&apos;t cache changing modules at all</span><br><span class="line">    cacheChangingModulesFor 0, &apos;seconds&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里可以配置两种缓存规则，</p><ul><li><p>第一种是生效在动态版本上，动态版本包括最新版本和区间版本。最新版本是版本号使用<code>latest.</code>开头。 区间版本包括使用 <code>+</code> 和使用开闭区间<code>[()]</code>限制。</p></li><li><p>第二种是生效在可变版本上。可变版本指的用 <code>-SNAPSHOT</code> 结尾的版本。注意全部为大写</p></li></ul><p>默认缓存时间是一天。<br>所有非动态且非可变版本的依赖的缓存不受缓存策略的影响，默认是一直有效的。</p><h3 id="属性匹配"><a href="#属性匹配" class="headerlink" title="属性匹配"></a>属性匹配</h3><p>在获取产物的时候可能会遇到一个异常。</p><pre><code>Could not resolve all files for configuration &apos;:app:dim&apos;.   &gt; Could not resolve project :lib.     Required by:         project :app      &gt; Cannot choose between the following configurations of project :test1:          - debugApiElements          - debugRuntimeElements          - releaseApiElements          - releaseRuntimeElements</code></pre><p>这是在Gradle 3.0 以上会出现的问题。 原因在于依赖是可以存在多个变种。在没有属性值匹配的时候会找到多个的产物。Gradle 会抛出异常。因为 Gradle 也不知道应该返回哪一个变种。这个时候需要对 <code>Configuration</code> 加上属性，来筛选出唯一的变种。<br>Gradle 支持属性值的转换。通过定义一些 <code>Transform</code>  提供一些属性转换规则。在属性匹配不上的时候，尝试组合一条最短的 <code>Transform</code> 路径， 进行转换匹配。 筛选出唯一的产物。关于属性匹配和 <code>Transform</code> 相关知识。这里就不展开聊，可以查看相关链接 Gradle Transform 初探 了解更多细节。</p><h1 id="相关"><a href="#相关" class="headerlink" title="相关"></a>相关</h1><p><a href="https://docs.oracle.com/middleware/1212/core/MAVEN/maven_version.htm#MAVEN8855" target="_blank" rel="noopener">Understanding Maven Version Numbers</a><br><a href="https://dim.red/2018/01/25/gradle_transform_%20exploration/">Gradle Transform 初探</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;环境&quot;&gt;&lt;a href=&quot;#环境&quot; class=&quot;headerlink&quot; title=&quot;环境&quot;&gt;&lt;/a&gt;环境&lt;/h1&gt;&lt;p&gt;Gradle：4.4.1&lt;/p&gt;
&lt;h1 id=&quot;Configuration-介绍&quot;&gt;&lt;a href=&quot;#Configuration-介绍&quot; class=&quot;headerlink&quot; title=&quot;Configuration 介绍&quot;&gt;&lt;/a&gt;Configuration 介绍&lt;/h1&gt;&lt;p&gt;通过声明的方式定义了一组依赖。Gradle 通过声明的方式查找对应依赖产物和他们的自身的依赖产物。它代表一组文件。只是这些文件是根据声明信息从本地或远程仓库中获取的。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Gradle Task  UP-TO-DATE</title>
    <link href="http://dim.red/2018/08/24/gradle_task_UP-TO-DATE/"/>
    <id>http://dim.red/2018/08/24/gradle_task_UP-TO-DATE/</id>
    <published>2018-08-23T16:00:00.000Z</published>
    <updated>2019-05-29T03:18:28.062Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://dim.red">dim.red</a><br>环境：Gradle 4.4.1</p><h2 id="相关"><a href="#相关" class="headerlink" title="相关"></a>相关</h2><p>Task 输入输出注解<br>@Input，@InputFile，@InputFiles，@InputDirectory， @OutputFile，@OutputFiles，@OutputDirectory，@OutputDirectories，@Destroys，@LocalState，@Nested，@Inject，@OptionValues<br>@PathSensitive<br>@Classpath<br>@CompileClasspath<br><a id="more"></a></p><h1 id="0x00"><a href="#0x00" class="headerlink" title="0x00"></a>0x00</h1><p>Gradle 为了加快构建速度, 加入了快照缓存的概念。<br>当你的 Task 输出不需要变更。Gradle 会跳转执行过程，同时 Task 在输出打上 UP-TO-DATE 标识。</p><h1 id="0x01"><a href="#0x01" class="headerlink" title="0x01"></a>0x01</h1><p>怎样的判断一个 Task 输出不需要变更 ？<br>其中一个条件是比对当前执行状态和上次执行状态的不同。<br>HistoricalTaskExecution： 表示上次执行状态, 是从快照中反序列化出来的。<code>TaskExecutionSnapshotSerializer.read()</code><br>CurrentTaskExecution：表示当前执行状态，是根据当前 Task 的输入输出生成的。 <code>CacheBackedTaskHistoryRepository.createExecution</code>   </p><p>比对具体逻辑 <code>TaskUpToDateState</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">this.allTaskChanges = new ErrorHandlingTaskStateChanges(task, new SummaryTaskStateChanges(MAX_OUT_OF_DATE_MESSAGES, </span><br><span class="line">previousSuccessState,</span><br><span class="line">noHistoryState, </span><br><span class="line">taskTypeState, </span><br><span class="line">inputPropertiesState, </span><br><span class="line">outputFileChanges, </span><br><span class="line">inputFileChanges, </span><br><span class="line">discoveredInputFilesChanges</span><br><span class="line">));</span><br></pre></td></tr></table></figure></p><p>这里经过 7 个校验，全部验证通过说明这次执行相对上次没有变更，可以直接使用上次执行的输出。</p><ul><li>previousSuccessState：判断之前执行是否成功。</li><li>noHistoryState：判断是否有执行记录。</li><li>taskTypeState：比对 Task 和 Action 的实现。具体是比较 ClassLoader 的 Hash 。</li><li>inputPropertiesState：比对 InputPropert  变更。</li><li>outputFileChanges：比对 OutputFie 变更。</li><li>inputFileChanges：比对 InputFie 变更。</li><li>discoveredInputFilesChanges：比对 Task 中新增的 Input 变更 。</li></ul><h1 id="InputPropert"><a href="#InputPropert" class="headerlink" title="InputPropert"></a>InputPropert</h1><p>Map\&lt;String, Object&gt; 类型<br>来自注解 @Input 或API <code>Task.getInput.property</code>  和 <code>Task.getInput.propertys</code> 。</p><p>@Input 可以被序列化和反序列化的类型。支持的类型有 基本类型，枚举，Serializable 和 Name 扩展类型。<br><img src="/2018/08/24/gradle_task_UP-TO-DATE/task_01.png" alt="image.png"> </p><h1 id="InputFile"><a href="#InputFile" class="headerlink" title="InputFile"></a>InputFile</h1><p>文件类型<br>来自注解  @InputFile @@InputFiles @InputDirectory 或 API<br><code>Task.getInput.file</code>， <code>Task.getInput.files</code>，<code>Task.getInput.dir</code> </p><h1 id="OutputFile"><a href="#OutputFile" class="headerlink" title="OutputFile"></a>OutputFile</h1><p>文件类型<br>来自注解 @OutputDirectory @OutputDirectories @OutputFile @OutputFiles 或 API <code>Task.getInput.dir</code>，<code>Task.getInput.dirs</code>，<code>Task.getInput.file</code>，<code>Task.getInput.files</code> </p><p>文件的比较主要分为3种， </p><ul><li>一般的文件：比较文件的的 Hash，Hash 是由文件 Normalized Name 和 文件的内容计算出来的 MD5。</li><li>Classpath文件： @Classpath 注释。这种类型在计算 jar 的Hash, 会先对 jar 文件里面的 ZipEntry 进行排序再和 Normalized Name 一起算出 MD5. 这样就不会因ZipEntry 排序导致的 MD5 不同。</li><li>CompileClassPath：@CompileClasspath 注释。 在 Classpath 的基础上, 对 Jar 中的 class 进行 ABI 格式化, 即当  jar 提供的接口不变，则 Jar 的 MD5 不变。 这种类型的加入也是使依赖从 compile 升级到  implementation 的关键。</li></ul><p>Normalized Name 的策略是注解 @PathSensitive 来确定的。 </p><ul><li>ABSOLUTE：文件的绝对位置。</li><li>RELATIVE：文件的相对位置</li><li>NAME_ONLY：文件名</li><li>NONE：忽略<br>默认值为 ABSOLUTE<br>具体实现查看代码<code>InputPathNormalizationStrategy</code></li></ul><p>@Nested 是自定义的类型。 是一组或者多组相关输入输出的集合。内部使用上面的注解来定义输入和输出。</p><p>注：注解可以声明字段或者 get 方法。但是注解要生效一定要有对应的 get 方法。</p><h1 id="0x01-1"><a href="#0x01-1" class="headerlink" title="0x01"></a>0x01</h1><p>Task 通过注解的方式定义输入和输出。<br>Gradle 中定义 Task 。<br><img src="/2018/08/24/gradle_task_UP-TO-DATE/task_02.png" alt="image.png"><br>通过接受一个 Class 类型来声明一个 Task 。<br>Class\<task>  -&gt;  Class\&lt;Task_Decorated&gt;  -&gt; Task_Decorated </task></p><p><img src="/2018/08/24/gradle_task_UP-TO-DATE/task_03.png" alt="image.png"><br> Class\<task> 会经过 ClassGenerator , TaskFactory,AnnotationProcessingTaskFactory 生成  Task_Decorated 对象。Task_Decorated 是对 Task 的扩展。</task></p><ul><li>ClassGenerator：使用 ASM 对原始的类进行分析，生成 Task 的子类 Task_Decorated，并且实现新的接口，增加新的方法和字段。使之具有扩展的能力。</li><li>TaskFactory：主要设置 Task_Decorated 合适的实例化方法。(为Task 构造方法注入 Service 对象)</li><li>AnnotationProcessingTaskFactory：反射获取 Task 的注解信息，通过一系列的 PropertyAnnotationHandler 处理 Task 类解析出对应 Input 和 Output 。</li></ul><h1 id="0x02"><a href="#0x02" class="headerlink" title="0x02"></a>0x02</h1><p>Task 的执行由 TaskExecuter 执行的。<br><code>TaskExecutionServices.createTaskExecuter()</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">TaskExecuter createTaskExecuter(TaskArtifactStateRepository repository,</span><br><span class="line">                                    TaskOutputCacheCommandFactory taskOutputCacheCommandFactory,</span><br><span class="line">                                    BuildCacheController buildCacheController,</span><br><span class="line">                                    StartParameter startParameter,</span><br><span class="line">                                    ListenerManager listenerManager,</span><br><span class="line">                                    TaskInputsListener inputsListener,</span><br><span class="line">                                    BuildOperationExecutor buildOperationExecutor,</span><br><span class="line">                                    AsyncWorkTracker asyncWorkTracker,</span><br><span class="line">                                    BuildOutputCleanupRegistry cleanupRegistry,</span><br><span class="line">                                    TaskOutputFilesRepository taskOutputFilesRepository,</span><br><span class="line">                                    BuildScanPluginApplied buildScanPlugin) &#123;</span><br><span class="line"></span><br><span class="line">        boolean taskOutputCacheEnabled = startParameter.isBuildCacheEnabled();</span><br><span class="line">        boolean scanPluginApplied = buildScanPlugin.isBuildScanPluginApplied();</span><br><span class="line">        TaskOutputsGenerationListener taskOutputsGenerationListener = listenerManager.getBroadcaster(TaskOutputsGenerationListener.class);</span><br><span class="line"></span><br><span class="line">        TaskExecuter executer = new ExecuteActionsTaskExecuter(</span><br><span class="line">            taskOutputsGenerationListener,</span><br><span class="line">            listenerManager.getBroadcaster(TaskActionListener.class),</span><br><span class="line">            buildOperationExecutor,</span><br><span class="line">            asyncWorkTracker</span><br><span class="line">        );</span><br><span class="line">        boolean verifyInputsEnabled = Boolean.getBoolean(&quot;org.gradle.tasks.verifyinputs&quot;);</span><br><span class="line">        if (verifyInputsEnabled) &#123;</span><br><span class="line">            executer = new VerifyNoInputChangesTaskExecuter(repository, executer);</span><br><span class="line">        &#125;</span><br><span class="line">        executer = new OutputDirectoryCreatingTaskExecuter(executer);</span><br><span class="line">        if (taskOutputCacheEnabled) &#123;</span><br><span class="line">            executer = new SkipCachedTaskExecuter(</span><br><span class="line">                buildCacheController,</span><br><span class="line">                taskOutputsGenerationListener,</span><br><span class="line">                taskOutputCacheCommandFactory,</span><br><span class="line">                executer</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">        executer = new SkipUpToDateTaskExecuter(executer);</span><br><span class="line">        executer = new ResolveTaskOutputCachingStateExecuter(taskOutputCacheEnabled, executer);</span><br><span class="line">        if (verifyInputsEnabled || taskOutputCacheEnabled || scanPluginApplied) &#123;</span><br><span class="line">            executer = new ResolveBuildCacheKeyExecuter(executer, buildOperationExecutor);</span><br><span class="line">        &#125;</span><br><span class="line">        executer = new ValidatingTaskExecuter(executer);</span><br><span class="line">        executer = new SkipEmptySourceFilesTaskExecuter(inputsListener, cleanupRegistry, taskOutputsGenerationListener, executer);</span><br><span class="line">        executer = new CleanupStaleOutputsExecuter(cleanupRegistry, taskOutputFilesRepository, buildOperationExecutor, executer);</span><br><span class="line">        executer = new ResolveTaskArtifactStateTaskExecuter(repository, executer);</span><br><span class="line">        executer = new SkipTaskWithNoActionsExecuter(executer);</span><br><span class="line">        executer = new SkipOnlyIfTaskExecuter(executer);</span><br><span class="line">        executer = new ExecuteAtMostOnceTaskExecuter(executer);</span><br><span class="line">        executer = new CatchExceptionTaskExecuter(executer);</span><br><span class="line">        return executer;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>这是一个装饰者模式。</p><ul><li>CatchExceptionTaskExecuter：拦截执行中出现的异常。</li><li>ExecuteAtMostOnceTaskExecuter：确保 Task 只执行一次。</li><li>SkipOnlyIfTaskExecuter：支持 Task.OnlyIf . Task.onlyIf 为 false 将跳过该任务的执行。 </li><li>SkipTaskWithNoActionsExecuter：过滤没有 Action 的 Task。(默认第一个 Action 是 Task 中的被 @TaskAction 的方法)</li><li>ResolveTaskArtifactStateTaskExecuter：从快照中反序列化出上次执行的状态(HistoricalTaskExecution)。</li><li>CleanupStaleOutputsExecuter：负责清除非 Task 执行中生成的文件</li><li>SkipEmptySourceFilesTaskExecuter：判断存在 Output 存在时 Source 文件不为空。Source 文件是输入文件中被 @SkipWhenEmpty 注释的属性。</li><li>ValidatingTaskExecuter：验证 input 和 output 。比如 input 的文件要存在等等。 </li><li>ResolveBuildCacheKeyExecuter：计算当前执行 Task 的 CacheKey，基于 TaskPath，input , output , Action 等信息， 作为后面从缓存中获取数据的 key。</li><li>ResolveTaskOutputCachingStateExecuter: 设置 Task Output 的缓存状态。</li><li>SkipUpToDateTaskExecuter：是否能直接跳过执行过程，逻辑主要是有几个， 一，task 的输入输出没有变更， 二 Task 输出 upToDate 为true，三，Gradle 执行命令没有使用 rerun-tasks 参数, 同时执行成功会保存当前 Task 状态(CurrentTaskExecution)的快照, 其中包括 InputPropert ，InputFile，OutputFile。 InputPropert 是将它序列化，而 InputFile，OutputFile 是保存的的文件的 Normalized Name 和 Hash，并不保存文件本身。默认保存在项目中(.gradle/4.4.1/taskHistory/taskHistory.bin)文件下。而这些将成为下一个执行时候从 <code>ResolveTaskArtifactStateTaskExecuter</code> 反序列化出来。</li><li>SkipCachedTaskExecuter：缓存有效的时候。尝试从根据 CacheKey 把 OutputFile 文件加载进来， 这里的缓存的来源可以是本地的文件也可是是远程的 Http 服务。同时在 Task 执行完成以后，将Task 输出缓存起来，同样可是缓存在本地或者远程。<br>默认情况本地存储是开启的，位置在全局的 .gradle/caches/build-cache-1/,<br>远程 Http 服务是关闭的。</li><li>OutputDirectoryCreatingTaskExecuter：Output 文件不存在自动创建</li><li>VerifyNoInputChangesTaskExecuter：验证输入在执行过程中是否有变更。</li><li>ExecuteActionsTaskExecuter: 执行被注解 @TaskAction 的方法和添加进来的 Action 。  </li></ul><p>需要注意的是这里有两种东西，一种是快照由 SkipUpToDateTaskExecuter 存储的是执行的状态，不包括 Output 的实体。另一种缓存是由 SkipCachedTaskExecuter 存储，是 Output 的实体而不是状态。</p><h1 id="0x03"><a href="#0x03" class="headerlink" title="0x03"></a>0x03</h1><p>当 Task 满足以下 4 个条件其中一个，则 Gradle 跳转执行过程。</p><ol><li>当一个 Task 定义了输出，Task 的 Output.upToDate 为 true，Task Source 为空。Gradle 将跳过该任务的执行。 Output 被标识 NO-SOURCE， Output 为空。</li><li>当一个 Task 定义了输出，Task 的 Output.upToDate 为 true，Task Source 不为空， Task 的输入和输出没有变更。Output 被标识 UP-TO-DATE，Gradle 将跳过该任务的执行。 使用上次的 Output 。</li><li>Task 的 OnlyIf 为 false, Gradle 将跳过该任务的执行。Output 被标识 SKIPPED  Output 为空。</li><li>支持缓存。缓存存在且有效，Gradle 将跳过该任务的执行。Output 被标识 FROM-CACHE，使用从缓存解压的 Output 。</li></ol><h1 id="0x04-尾巴"><a href="#0x04-尾巴" class="headerlink" title="0x04 尾巴"></a>0x04 尾巴</h1><p>Gradle 的代码相对比较松散, 而 Task 这块的代码相对比较集中。通过本章当中的一些关键节点可以很方便的进行学习和深入了解。 </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://dim.red&quot;&gt;dim.red&lt;/a&gt;&lt;br&gt;环境：Gradle 4.4.1&lt;/p&gt;
&lt;h2 id=&quot;相关&quot;&gt;&lt;a href=&quot;#相关&quot; class=&quot;headerlink&quot; title=&quot;相关&quot;&gt;&lt;/a&gt;相关&lt;/h2&gt;&lt;p&gt;Task 输入输出注解&lt;br&gt;@Input，@InputFile，@InputFiles，@InputDirectory， @OutputFile，@OutputFiles，@OutputDirectory，@OutputDirectories，@Destroys，@LocalState，@Nested，@Inject，@OptionValues&lt;br&gt;@PathSensitive&lt;br&gt;@Classpath&lt;br&gt;@CompileClasspath&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>一种新的修改字节码的思路</title>
    <link href="http://dim.red/2018/05/13/idea_by_modify/"/>
    <id>http://dim.red/2018/05/13/idea_by_modify/</id>
    <published>2018-05-12T16:00:00.000Z</published>
    <updated>2018-08-25T08:43:16.979Z</updated>
    
    <content type="html"><![CDATA[<p>博客地址: <a href="http://dim.red">dim.red</a></p><h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>分析最近的 Crash , 排在前列基本是第三方SDK导致. 遇到这样的问题, 我们需要寻求官方的支持, 但是官方的支持总是来得比较晚. 在Android上, 第三方SDK一般是两种, 一种是jar, 一种是so. so的修改成本过大, 我们放弃它, 我们现在探讨对 jar 的修改.<br><a id="more"></a></p><h1 id="0x02-问题"><a href="#0x02-问题" class="headerlink" title="0x02 问题"></a>0x02 问题</h1><p>在之前 <a href="http://dim.red/2017/12/04/aop/">使用AOP来为第三方SDK打CALL</a> 文章 我们使用 AOP 对第三方 SDK 的问题进行修复. 貌似能这样解决这个问题.<br>但是 AOP 存在局限性:<br>1、它不够直观. 定义的规则需要通过编译后才能确定.<br>2、学习成本较高.<br>3、可操作的范围不够大. 只能切方法.<br>例子:<br>在一些因素下,我们升级某个推送SDK版本. 但是发现有大量的NPE异常出现. 通过反编译 jar 定位问题.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">private Handler p = null;</span><br><span class="line">private void b() &#123;</span><br><span class="line">      if (this.p != null) &#123;</span><br><span class="line">          this.p.removeMessages(2);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">          this.p = new Handler(Looper.getMainLooper(), new com.xxx.b(this));</span><br><span class="line">      &#125;</span><br><span class="line">      this.p.sendEmptyMessageDelayed(2, 3000L);</span><br><span class="line"> &#125;</span><br><span class="line">private void c() &#123;</span><br><span class="line">      if (this.p != null) &#123;</span><br><span class="line">          this.p.removeMessages(2);</span><br><span class="line">          this.p = null;</span><br><span class="line">      &#125;</span><br><span class="line"> &#125;</span><br><span class="line">public void d()&#123;</span><br><span class="line">...</span><br><span class="line">  // 代码块A  开始</span><br><span class="line">  if(p != null)&#123;</span><br><span class="line">    this.p.sendEmptyMessageDelayed(3, 3000L);</span><br><span class="line">  &#125;</span><br><span class="line">  // 代码块A  结束</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>异常发生在方法<code>this.p.sendEmptyMessageDelayed(2, 3000L);</code>.在一个判断空还会出现NPE, 说明这是一个多线程并发下的bug.  通过分析我们需要</p><ol><li>对b c 方法使用synchronized 修饰</li><li>对代码块A 进行 synchronized(this) 包裹</li></ol><p>在这种场景下使用AOP将费力不讨好.</p><h1 id="0x03-解决方案"><a href="#0x03-解决方案" class="headerlink" title="0x03 解决方案"></a>0x03 解决方案</h1><p>我们可以尝试使用一种更简单的方式来处理这件事情. 输入一个原始的 jar , 经过转换生成新的 jar. </p><ul><li>步骤1: 对 jar 中需要修改的 class 反编译成 java 文件.</li><li>步骤2: 对 java 文件进行代码逻辑上的 bug fix.</li><li>步骤3: 使用 javac 编译 java 文件成 class 文件.</li><li>步骤4: 替换 jar 中对应的修改的 class 文件生成新的 jar 文件.</li></ul><h1 id="0x04-问题"><a href="#0x04-问题" class="headerlink" title="0x04 问题"></a>0x04 问题</h1><p>Q : javac 编译失败.<br>A: 当你 java 调用的方法不在原有的 jar 中, 导致 javac 编译的时候找不到对应的方法,抛出异常.<br>解决方式:使用 asm 对 jar 中进行指令分析, 对指令 invokestatic, invokevirtual , invokeinterface , invokedynamic ( android 上可以忽略这个指令)  和 getfield , getstatic 指令的分析. 我们可以生成一个空的实现的jar , 来为 javac 编译提供环境支持.</p><p>Q : 内部类的问题.<br>A: 匿名内部的生成的规则是 <code>外部类类名$Number</code>. Number 是在源码中出现的位置. 当你新增和调整位置的时候会导致生成的类和之前的类不匹配. 解决方式. 在对外部类操作的时候, 直接对匿名内部类进行删除. 等 javac 命令的生成新的内部类直接替换进去.</p><h1 id="0x05-改进"><a href="#0x05-改进" class="headerlink" title="0x05 改进"></a>0x05 改进</h1><p>通过和 idea  结合提供一整套的解决方案. </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;博客地址: &lt;a href=&quot;http://dim.red&quot;&gt;dim.red&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h1&gt;&lt;p&gt;分析最近的 Crash , 排在前列基本是第三方SDK导致. 遇到这样的问题, 我们需要寻求官方的支持, 但是官方的支持总是来得比较晚. 在Android上, 第三方SDK一般是两种, 一种是jar, 一种是so. so的修改成本过大, 我们放弃它, 我们现在探讨对 jar 的修改.&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>动态日志实践</title>
    <link href="http://dim.red/2018/05/03/dylog_exploration/"/>
    <id>http://dim.red/2018/05/03/dylog_exploration/</id>
    <published>2018-05-02T16:00:00.000Z</published>
    <updated>2019-05-29T03:23:12.736Z</updated>
    
    <content type="html"><![CDATA[<p>博客地址: <a href="http://dim.red">dim.red</a><br>项目开源: <a href="https://github.com/zzz40500/DynamicLog" target="_blank" rel="noopener">DynamicLog</a></p><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>当线上问题出现的时候. 往往需要之前的埋点进行问题定位. 但是埋点个数是有限的. 现有的埋点往往不够排查出具体的问题. 所以我们需要一个更灵活的埋点方案. 要求是可以动态的输出任何方法的入参和出参.<br><a id="more"></a></p><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>拦截原有的业务方法的入口和出口. </p><p>原本:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class O &#123;</span><br><span class="line">    private static final String TAG = &quot;O&quot;;</span><br><span class="line">    public int method1(int i) &#123;</span><br><span class="line">        Log.d(TAG, &quot;method1() called with: i = [&quot; + i + &quot;]&quot;);</span><br><span class="line">        return i * i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>处理后:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public class O &#123;</span><br><span class="line">    private static final String TAG = &quot;O&quot;;</span><br><span class="line">    public static volatile MethodMonitor s_Monitor_1;</span><br><span class="line"></span><br><span class="line">    public int method1(int i) &#123;</span><br><span class="line">        //方法开始</span><br><span class="line">        int methodId = 11;</span><br><span class="line">        Point point = null;</span><br><span class="line">        if (s_Monitor_1 != null &amp;&amp; s_Monitor_1.hotMethodEnter(methodId)) &#123;</span><br><span class="line">            point = new Point();</span><br><span class="line">            point.setThisObject(this);</span><br><span class="line">            Object[] var2 = new Object[0];</span><br><span class="line">            point.setArg(var2);</span><br><span class="line">            s_Monitor_1.methodEnter(point);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //原有方法执行</span><br><span class="line">        Log.d(TAG, &quot;method1() called with: i = [&quot; + i + &quot;]&quot;);</span><br><span class="line">        int result = i * i;</span><br><span class="line"></span><br><span class="line">        //方法结束</span><br><span class="line">        if (s_Monitor_1 != null &amp;&amp; s_Monitor_1.hotMethodReturn(0)) &#123;</span><br><span class="line">            if (point == null) &#123;</span><br><span class="line">                point = new Point();</span><br><span class="line">                point.setThisObject(this);</span><br><span class="line">                Object[] var3 = new Object[0];</span><br><span class="line">                point.setArg(var3);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            point.setReturnObject((Integer)result);</span><br><span class="line">            s_Monitor_1.methodReturn(point, methodId);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>做法:<br>为所有的 class 分配一个静态的 s_Monitor_1 对象. 同时为 class 下所有的方法分配一个独有的 methodId . 当 s_Monitor_1 对象不为空, methodId 匹配即命中规则.</p><h2 id="编译过程过程"><a href="#编译过程过程" class="headerlink" title="编译过程过程:"></a>编译过程过程:</h2><p><img src="/2018/05/03/dylog_exploration/dynamiclog_01.png" alt="编译过程"></p><h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h3><p>Monitor Plugin<br>在编译期间进行字节码注入. 同时生成 monitorMapping.txt 用来描述方法和 <code>methodId</code> 的映射关系.</p><p>注: 在字节码过程中我们发现有些方法是不需要注入的. 比如 abstract , 桥接方法 和 access$方法.</p><p>服务端可以通过 mapping.txt 找到混淆以后的类名,再通过 monitorMapping.txt 获取到 methodId 两则组合成命令往客户端发送.</p><h1 id="尾巴"><a href="#尾巴" class="headerlink" title="尾巴"></a>尾巴</h1><p>是用热修复的思想来做做动态日志.</p><h1 id="相关"><a href="#相关" class="headerlink" title="相关"></a>相关</h1><p><a href="https://tech.meituan.com/android_holmes.html" target="_blank" rel="noopener">美团点评 - Android动态日志系统Holmes</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;博客地址: &lt;a href=&quot;http://dim.red&quot;&gt;dim.red&lt;/a&gt;&lt;br&gt;项目开源: &lt;a href=&quot;https://github.com/zzz40500/DynamicLog&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;DynamicLog&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;当线上问题出现的时候. 往往需要之前的埋点进行问题定位. 但是埋点个数是有限的. 现有的埋点往往不够排查出具体的问题. 所以我们需要一个更灵活的埋点方案. 要求是可以动态的输出任何方法的入参和出参.&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>插件化方案对比</title>
    <link href="http://dim.red/2018/03/31/plugin_framework_%20exploration/"/>
    <id>http://dim.red/2018/03/31/plugin_framework_ exploration/</id>
    <published>2018-03-30T16:00:00.000Z</published>
    <updated>2019-03-04T16:45:29.124Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://dim.red">dim.red</a></p><h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>市面上的插件化，已经百花齐放，趋于完善。<br>主流的开源框架主要的代表有 Alibaba 的 Atlas , 360 的 Replugin 和 DIDI 的 VirtualAPK 。<br>实现插件化的技术难点</p><ul><li>代码的加载:</li><li>资源的加载</li><li>四大组件动态加载</li><li>配套的打包插件<a id="more"></a></li></ul><h1 id="0x01-实现原理"><a href="#0x01-实现原理" class="headerlink" title="0x01 实现原理"></a>0x01 实现原理</h1><h2 id="1-代码加载"><a href="#1-代码加载" class="headerlink" title="1. 代码加载"></a>1. 代码加载</h2><p>主要分为两种：第一种是将所有的代码加载在同一个ClassLoader，第二种是插件使用自定义的 ClassLoder 分别加载插件代码。 Atlas 和 Replugin,VirtualAPK 使用的都是后者，使用后者的优势就是控制的粒度更细。</p><h2 id="2-资源的加载"><a href="#2-资源的加载" class="headerlink" title="2. 资源的加载"></a>2. 资源的加载</h2><p>资源的加载要先解决一个问题，就是资源ID 的重复。方案有两种：第一种是使用不同的 Resource 加载插件资源来避免资源ID重复，第二种方式是共用一个 Resource ，通过修改插件的 Resource 的 PP 段来避免资源ID重复。第一种方式编译就不需要过多的参与，修改 PP 段的方式有两种，一种是修改 aapt 的 C 代码 ， 生成自定义的aapt。还有一种是直接的对 arsc 进行解析，修改pp段，回写成新的arsc 。看起来更极客，但是难度也更大，需要对arsc 有很深的理解，以及在不同版本下的异同。在这几个框架中，Replugin 使用的是多个 Resource 的方案。 Atlas 使用的是自定义的 aapt ,。VirtualAPK 使用的 Small 方式操作arsc。Replugin对比其他两个方案有个缺点, 他没有公共资源的概念，比如你3个插件都使用了support 包，那它需要把 support 包的资源全部打进 3个插件中。</p><h2 id="3-四大组件"><a href="#3-四大组件" class="headerlink" title="3.  四大组件:"></a>3.  四大组件:</h2><h4 id="3-1-VirtualAPK"><a href="#3-1-VirtualAPK" class="headerlink" title="3.1 VirtualAPK"></a>3.1 VirtualAPK</h4><p>VirtualAPK  使用的是是预埋的方式。<br>Activity 当启动 插件 Activity 的会在启动的时候被替换成占坑的 Activity，然后Hook ActivityThread 的 H 和 Instrumentation 类，在对应的回调中替换回插件的 Activity .。达到欺骗系统的效果。<br>BroadcastReceiver 是将所有的静态注册转成动态注册。<br>Service 是将所有的插件 service 转成代理的Service ，在Service 的onStartCommand 方法中，重新模拟了插件 service 的声明周期。<br>ContentProvider 是将所有的插件 ContentProvider 调用转成调用代理的ContentProvider , 然后将真实的 ContentProvider 信息放在Uri 中, 通过解析Uri 获取插件的真实的 ContentProvider 信息。</p><h4 id="3-2-Atlas"><a href="#3-2-Atlas" class="headerlink" title="3.2 Atlas"></a>3.2 Atlas</h4><p>Atlas 插件的四大组件是直接埋在宿主的 App 的 Manifest 中，通过监听 ClassLoader  的 findClass方法，当是插件的相关 Activity 或者 ContentProvider ，初始化好对应的插件，然后使用对应的插件 ClassLoader 加载，同时 Atlas 也支持动态添加的四大组件，该方式跟VirtualAPK 实现原理一致。</p><h4 id="3-2-RePlugin"><a href="#3-2-RePlugin" class="headerlink" title="3.2 RePlugin"></a>3.2 RePlugin</h4><p>RePlugin 使用的方式比较新颖，在启动的 Activity 时候替换成了合适的占坑的Activity ，同时记录占坑 Activity 和 真实 Activity 的映射关系，然后ClassLoader的 loadClass方法中，load 占坑 Activity 类的的时候，根据占坑组件跟真实组件的映射关系, 加载真实的组件. 这样的好处是，避免了过多的 Hook 系统组件。<br>BroadcastReceiver：同VirtualAPK<br>ContentProvider：同VirtualAPK<br>Service：是直接在UI线程调用了service 的相关生命周期的方法，同时启动一个Service 来提高service所在进程优先级。</p><h2 id="4-配套的打包插件"><a href="#4-配套的打包插件" class="headerlink" title="4.  配套的打包插件"></a>4.  配套的打包插件</h2><p>待续</p><h1 id="0x03-框架对比"><a href="#0x03-框架对比" class="headerlink" title="0x03 框架对比"></a>0x03 框架对比</h1><h2 id="1-VirtualAPK"><a href="#1-VirtualAPK" class="headerlink" title="1. VirtualAPK:"></a>1. VirtualAPK:</h2><p>优点</p><ul><li>整体代码偏少, 可以符合官方的 “轻量”. </li><li>扩增了android.jar 的api, 使 反射改为直接调用hide api</li></ul><p>缺陷</p><ul><li>ContentProvider 支持有问题, 不支持在主进程的ContentProvider</li><li>Activity 支持多进程, 只支持Launch Model</li><li>Service 的多进程只支持两个进程</li><li>BroadcastReceiver 不支持多进程</li><li>开发有感知, 使用CP 没有在代码实现的时候修改</li><li>代码实现不优雅, 开发感知明显</li><li>插件管理逻辑丢失, 需要手动管理. 每次使用插件都要自行加载</li><li>Hook 太多系统的API</li><li>不支持内嵌插件</li><li>不支持插件依赖</li></ul><h2 id="2-Atlas"><a href="#2-Atlas" class="headerlink" title="2. Atlas"></a>2. Atlas</h2><p>优点</p><ul><li>插件的四大组件是直接声明在宿主中. 所以四大组件多进程支持都是完整的.</li><li>代码实现比较优雅., </li><li>完整的插件管理逻辑</li><li>支持插件依赖</li></ul><p>缺陷</p><ul><li>宿主打包插件实现比较复杂，hook 了大量 Android Gradle Plugin 2.x 的代码。</li><li>Hook 太多系统的API</li></ul><h2 id="3-RePlugin"><a href="#3-RePlugin" class="headerlink" title="3. RePlugin"></a>3. RePlugin</h2><p>优点</p><ul><li>开发的感知少, 得益于编译时期的字节码修改</li><li>多进程支持完美, 和Activity 的 Launch Model</li><li>Hook 系统api 较少</li></ul><p>缺陷</p><ul><li>资源没法复用, 插件包过大</li><li>不支持插件依赖</li><li>需要一个 GuardService 进程，用于管理插件信息。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://dim.red&quot;&gt;dim.red&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h1&gt;&lt;p&gt;市面上的插件化，已经百花齐放，趋于完善。&lt;br&gt;主流的开源框架主要的代表有 Alibaba 的 Atlas , 360 的 Replugin 和 DIDI 的 VirtualAPK 。&lt;br&gt;实现插件化的技术难点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;代码的加载:&lt;/li&gt;
&lt;li&gt;资源的加载&lt;/li&gt;
&lt;li&gt;四大组件动态加载&lt;/li&gt;
&lt;li&gt;配套的打包插件&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>输出 Apk 所有的依赖</title>
    <link href="http://dim.red/2018/02/05/android_dependency_analyse_code/"/>
    <id>http://dim.red/2018/02/05/android_dependency_analyse_code/</id>
    <published>2018-02-04T16:00:00.000Z</published>
    <updated>2018-08-25T15:07:34.378Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://dim.red">dim.red</a>  </p><h1 id="一-作用"><a href="#一-作用" class="headerlink" title="一 作用"></a>一 作用</h1><p>因为 Gradle 的依赖发生冲突的时候, 会解决冲突, 默认是使用最高的版本, 但是也会因为 force 字段的关系选择较低的版本, 我们往往需要知道打到APK里面依赖的具体版本.</p><p>代码片段<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">project.getGradle().addBuildListener(new BuildListener() &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    void buildStarted(Gradle gradle) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    void settingsEvaluated(Settings settings) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    void projectsLoaded(Gradle gradle) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    void projectsEvaluated(Gradle gradle) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    void buildFinished(BuildResult result) &#123;</span><br><span class="line"></span><br><span class="line">        project.android.applicationVariants.each &#123; variant -&gt;</span><br><span class="line">            if (variant.getAssemble().state.executed) &#123;</span><br><span class="line">                if (this.gradle.gradleVersion &gt;= &quot;4.1&quot;) &#123;</span><br><span class="line">                    // android plugin 3.0 以上</span><br><span class="line">                    def runtime = project.configurations.create(&quot;d_analyse&quot; + variant.runtimeConfiguration.name);</span><br><span class="line">                    runtime.setCanBeConsumed(false);</span><br><span class="line">                    runtime.extendsFrom(variant.runtimeConfiguration);</span><br><span class="line">                    runtime.getAttributes().attribute(Attribute.of(&quot;artifactType&quot;, String.class), &quot;jar&quot;)</span><br><span class="line">                    variant.runtimeConfiguration.getAttributes().keySet().forEach(&#123;</span><br><span class="line">                        runtime.getAttributes().attribute(it, variant.runtimeConfiguration.getAttributes().getAttribute(it));</span><br><span class="line">                    &#125;)</span><br><span class="line">                    println(&quot;$&#123;variant.name&#125;  analyse&quot;)</span><br><span class="line">                    println(&quot;runtime dependency &quot;)</span><br><span class="line">                    println(&quot;------------------&quot;)</span><br><span class="line">                    runtime.resolvedConfiguration.resolvedArtifacts.forEach(&#123;</span><br><span class="line">                        def id = it.moduleVersion.id;</span><br><span class="line">                        println(id.group + &quot; &quot; + id.name + &quot; &quot; + id.version)</span><br><span class="line">                    &#125;)</span><br><span class="line">                    println(&quot;------------------\n &quot;)</span><br><span class="line">                    def packageC = project.configurations.create(&quot;d_analyse_&quot; + variant.compileConfiguration.name);</span><br><span class="line">                    packageC.setCanBeConsumed(false);</span><br><span class="line">                    packageC.extendsFrom(variant.compileConfiguration);</span><br><span class="line">                    packageC.getAttributes().attribute(Attribute.of(&quot;artifactType&quot;, String.class), &quot;jar&quot;)</span><br><span class="line">                    variant.compileConfiguration.getAttributes().keySet().forEach(&#123;</span><br><span class="line">                        packageC.getAttributes().attribute(it, variant.compileConfiguration.getAttributes().getAttribute(it));</span><br><span class="line">                    &#125;)</span><br><span class="line">                    println(&quot;package dependency &quot;)</span><br><span class="line">                    println(&quot;------------------&quot;)</span><br><span class="line">                    packageC.resolvedConfiguration.resolvedArtifacts.forEach(&#123;</span><br><span class="line">                        def id = it.moduleVersion.id;</span><br><span class="line">                        println(id.group + &quot; &quot; + id.name + &quot; &quot; + id.version)</span><br><span class="line">                    &#125;)</span><br><span class="line">                    println(&quot;------------------\n &quot;)</span><br><span class="line">                    println(&quot;\n &quot;)</span><br><span class="line"></span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    // android plugin 3.0  以下</span><br><span class="line">                    def appPlugin = project.plugins.findPlugin(&quot;com.android.application&quot;);</span><br><span class="line">                    appPlugin.variantManager.variantDataList.forEach(&#123;</span><br><span class="line">                        def variantDependencies = it.variantDependency;</span><br><span class="line"></span><br><span class="line">                        if (variant.name == variantDependencies.name) &#123;</span><br><span class="line">                            println(&quot;$&#123;variant.name&#125;  analyse&quot;)</span><br><span class="line">                            def runtime = project.configurations.create(&quot;d_analyse&quot; + variantDependencies.compileConfiguration.name);</span><br><span class="line">                            runtime.setCanBeConsumed(false)</span><br><span class="line">                            runtime.extendsFrom(variantDependencies.compileConfiguration);</span><br><span class="line">                            println(&quot;runtime dependency &quot;)</span><br><span class="line">                            println(&quot;------------------&quot;)</span><br><span class="line">                            runtime.resolvedConfiguration.resolvedArtifacts.forEach(&#123;</span><br><span class="line">                                def id = it.moduleVersion.id;</span><br><span class="line">                                println(id.group + &quot; &quot; + id.name + &quot; &quot; + id.version)</span><br><span class="line">                            &#125;)</span><br><span class="line">                            println(&quot;------------------\n &quot;)</span><br><span class="line"></span><br><span class="line">                            def packageC = project.configurations.create(&quot;d_analyse&quot; + variantDependencies.packageConfiguration.name);</span><br><span class="line">                            packageC.setCanBeConsumed(false)</span><br><span class="line">                            packageC.extendsFrom(variantDependencies.packageConfiguration);</span><br><span class="line">                            println(&quot;package dependency &quot;)</span><br><span class="line">                            println(&quot;------------------&quot;)</span><br><span class="line">                            packageC.resolvedConfiguration.resolvedArtifacts.forEach(&#123;</span><br><span class="line">                                def id = it.moduleVersion.id;</span><br><span class="line">                                println(id.group + &quot; &quot; + id.name + &quot; &quot; + id.version)</span><br><span class="line">                            &#125;)</span><br><span class="line">                            println(&quot;------------------\n &quot;)</span><br><span class="line">                            println(&quot;\n &quot;)</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                    &#125;)</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://dim.red&quot;&gt;dim.red&lt;/a&gt;  &lt;/p&gt;
&lt;h1 id=&quot;一-作用&quot;&gt;&lt;a href=&quot;#一-作用&quot; class=&quot;headerlink&quot; title=&quot;一 作用&quot;&gt;&lt;/a&gt;一 作用&lt;/h1&gt;&lt;p&gt;因为 Gradle 的依赖发生冲突的时候, 会解决冲突, 默认是使用最高的版本, 但是也会因为 force 字段的关系选择较低的版本, 我们往往需要知道打到APK里面依赖的具体版本.&lt;/p&gt;
&lt;p&gt;代码片段&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Gradle Transform 初探</title>
    <link href="http://dim.red/2018/01/25/gradle_transform_%20exploration/"/>
    <id>http://dim.red/2018/01/25/gradle_transform_ exploration/</id>
    <published>2018-01-24T16:00:00.000Z</published>
    <updated>2019-05-29T03:50:06.811Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://dim.red">dim.red</a><br>环境: gradle 4.1 ,  Android Plugin 2.3.0 ,  Android Plugin 3.0.0</p><p>#0x00 背景<br>去年的时候写个 <a href="http://dim.red/2017/04/05/android_plugin_transform_%20exploration/">Android Plugin Transform 初探</a> . 现在我们接着之前的脚步来学习 Gradle 下的 Transform . 同时熟悉一下 Android Plugin 在该规则下的应用.<br><a id="more"></a></p><p>#0x01 历史<br>Android Plugin 是在1.5.0-beta1 版本加入的.  1.5.0 的 Release 是在2015 年的 11 月.<br>Gradle 的 Transform api 是在 3.5 版本引入的. 3.5.0 的 Release 是在 2017 年的 4 月.<br>相似的命名, 相似的功能,<br>[^_^]: <img src="/2018/01/25/gradle_transform_ exploration/tra_01.png" alt="Android plugin 1.5.0 "><br><img src="/2018/01/25/gradle_transform_ exploration/tra_02.png" alt="Gradle 3.5 "></p><p>#0x02 使用<br>Gradle 中 Configuration 代表一组依赖关系.而 Transform 是作用在依赖的产物上, 将产物 A 根据一定规则转换成产物 B.<br>依赖的产物默认有一个属性<code>ArtifactAttributes.ARTIFACT_FORMAT</code>, 远程依赖默认为文件的后缀名. 本地依赖的情况比较复杂,具体看应用的插件. </p><p>先看一个比较全的应用 </p><p>Lib 工程提供 Configuration. 供主工程消费.  </p><h2 id="1-Lib-工程"><a href="#1-Lib-工程" class="headerlink" title="1 Lib 工程"></a>1 Lib 工程</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Configuration apLib = project.configurations.create(&quot;apLib&quot;);</span><br><span class="line">        apLib.setDescription(&quot;ap  elements &quot; );</span><br><span class="line">        // 能被其他 project 的消费</span><br><span class="line">        apLib.setCanBeConsumed(true);</span><br><span class="line">        // 设置当前的 Configuration 的属性. 供请求 Configuration 的属性匹配</span><br><span class="line">        apLib.getAttributes().attribute(Attribute.of(&quot;Type&quot;, String.class), &quot;ap&quot;)</span><br><span class="line">        // 声明一个variants apVar , 设置 apVar 属性为 ap, 同时为apVar 设置最终产物 /lib/demo.ap</span><br><span class="line">        apLib.getOutgoing().variants(new Action&lt;NamedDomainObjectContainer&lt;ConfigurationVariant&gt;&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            void execute(NamedDomainObjectContainer&lt;ConfigurationVariant&gt; configurationVariants) &#123;</span><br><span class="line"></span><br><span class="line">                configurationVariants.create(&quot;apVar&quot;, &#123; variant -&gt;</span><br><span class="line">                    variant.artifact(new File(&quot;/lib/demo.ap&quot;), &#123; artifact -&gt;</span><br><span class="line">                        artifact.setType(&quot;ap&quot;);</span><br><span class="line">                    &#125;)</span><br><span class="line">                    variant.getAttributes().attribute(Attribute.of(&quot;artifactType&quot;, String.class), &quot;ap&quot;)</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><p>这里声明了一个 apLib 的 Configuration  . 并且为这个apLib 设置了一些属性,这些属性将在后面查找提供作用, 同时为 apLib 设置它的产物 . 也可以为这个 artifact 设置依赖任务 (<code>artifact.builtBy(Task)</code>) , 解析的时候依赖任务是不会被强制执行的。什么时候被执行呢？ Configuration  可以被当一组 Task 被另外一个 Task 依赖 。 TaskA dependOn ConfigurationA. 当 TaskA 被执行之前所有的 ConfigurationA 的 Artifact 设置的依赖Task 会被执行。或者将 ConfigurationA 设置成 TaskA 的 @InputFlies，Gradle 在自动将 TaskA 依赖 ConfigurationA 。  </p><h2 id="2-主工程"><a href="#2-主工程" class="headerlink" title="2 主工程"></a>2 主工程</h2><p>定义一个 apC . 获取 apC 依赖上所有 ap 类型的文件.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Configuration apC = project.configurations.create(&quot;apC&quot;);</span><br><span class="line">//主动依赖 Lib 工程</span><br><span class="line">project.getDependencies().add(&quot;apC&quot;, project.project(&apos;:lib&apos;));</span><br><span class="line"></span><br><span class="line">//定义 apC 属性,  主要用来匹配 lib 生成的 apLib 的属性</span><br><span class="line">apC.getAttributes().attribute(Attribute.of(&quot;Type&quot;, String.class), &quot;ap&quot;)</span><br><span class="line">apC.getIncoming().artifactView(&#123;</span><br><span class="line">   config -&gt;</span><br><span class="line">         config.attributes &#123;</span><br><span class="line">            // 定义属性, 用于匹配 apLib apVar 的属性</span><br><span class="line">             container -&gt; container.attribute(Attribute.of(&quot;artifactType&quot;, String.class), &quot;ap&quot;)</span><br><span class="line">         &#125;</span><br><span class="line">&#125;).getArtifacts().getArtifactFiles().getFiles(); //  /lib/demo.ap</span><br></pre></td></tr></table></figure></p><p>数据流向:   根据 apC 的属性匹配到 lib 工程的 apLib 的属性. 根据 container 的属性匹配到了 apVar  的属性. 获取到产物.<br>属性的匹配默认是调用两个值的 equals 方法. 当然你可以自己定义一个匹配策略和一个解决匹配冲突的的策略.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AttributeMatchingStrategy attributeMatchingStrategy = project.getDependencies().getAttributesSchema().attribute(Attribute.of(&quot;artifactType&quot;, String.class)); // 获取规则</span><br><span class="line">attributeMatchingStrategy.compatibilityRules.add(TypeCompatibilityRules.class); // 定义新的匹配策</span><br><span class="line">attributeMatchingStrategy.disambiguationRules.add(TypeDisambiguationRules.class); // 定义解决冲突的策</span><br></pre></td></tr></table></figure></p><p>到这里. 我们还没有讲到 Transform 的应用. 属性匹配是 Transform 的基础. 当匹配不成功的时候, 会根据 Transform 定义的 <code>From</code> 和 <code>To</code> 尝试组成转化规则. 下面是一个简单的转换<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">DependencyHandler dependencies = project.getDependencies();</span><br><span class="line">        dependencies.registerTransform(&#123;</span><br><span class="line">            it.getFrom().attribute(ArtifactAttributes.ARTIFACT_FORMAT, &quot;ap&quot;);</span><br><span class="line">            it.getTo().attribute(Attribute.of(&quot;artifactType&quot;, String.class), &quot;ap-info&quot;);</span><br><span class="line">            it.artifactTransform(ApInfoTransform.class);</span><br><span class="line">        &#125;);</span><br><span class="line"> apC.getIncoming().artifactView(&#123;</span><br><span class="line">            config -&gt;</span><br><span class="line">                config.attributes &#123;</span><br><span class="line">                    container -&gt; container.attribute(Attribute.of(&quot;artifactType&quot;, String.class), &quot;ap-info&quot;)</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;).getArtifacts().getArtifactFiles().getFiles();</span><br></pre></td></tr></table></figure></p><p>定义了一个转换规则: 由 ap 转化成 ap-info .具体转换在 ApInfoTransform</p><p>数据的流向是: 根据 apC 的属性匹配到 lib 工程的 apLib 的属性.  container 的属性没有找到能够匹配的属性. 但是匹配到了 ApInfoTransform 的<code>To</code>, ApInfoTransform 的 From 匹配到了 apVar  的属性. 至此组成了一个转化规则, 由 apVar 获取到的产物,需经过 ApInfoTransform 转化后返回. </p><p>#0x03 Android Plugin 的应用</p><p>Android Plugin 正式使用 Gradle Transform 是在 3.0 上.  </p><h3 id="1-Android-Plugin-2-3-0-实现"><a href="#1-Android-Plugin-2-3-0-实现" class="headerlink" title="1. Android Plugin 2.3.0 实现"></a>1. Android Plugin 2.3.0 实现</h3><p><img src="/2018/01/25/gradle_transform_ exploration/transform_01.png" alt="2.3.0"></p><p>处理的是 AAR  </p><ol><li>AAR 的来源有两个: 一种是 AAR 依赖 通过网络下载或本地获取, 一种是 Android Library Module 通过 bundleXX 任务打包出来的 AAR.</li><li>Application Plugin 通过依赖关系收集所有的AAR, 再通过 PrepareLibraryTask 将所有 AAR 文件的解压, 用 AndroidDependency 来管理这些 AAR . 通过自己管理这些目录. 组织出不同的资源目录, 如 jar ,Jni,Aidl,Proguard …<h3 id="2-Android-Plugin-3-0-0-实现"><a href="#2-Android-Plugin-3-0-0-实现" class="headerlink" title="2. Android Plugin 3.0.0 实现"></a>2. Android Plugin 3.0.0 实现</h3><img src="/2018/01/25/gradle_transform_ exploration/transform_02.png" alt="3.0"><br>处理的是 attribute 产物<br>这里的 attribute 产物来源主要是两种,<br>一种是 AAR 依赖, 通过网络下载AAR, 通过 ExtractAarTransform 将  ARTIFACT_FORMAT 为 aar 转化成 android-exploded-aar 的产物. 再通过不不同的 AarTransform 将 ARTIFACT_FORMAT 为 android-exploded-aar 转化成不同的属性的产物.<br>一种是通过使用 Android Library Module . 通过往 Configuration 输出不同属性的产物.  </li></ol><h3 id="3-对比"><a href="#3-对比" class="headerlink" title="3. 对比:"></a>3. 对比:</h3><p>对比 2.3.0 来说 通过将 Transform 的功能将 AAR 文件的处理的时机和缓存全部移交给了 Gradle,<br>好处  </p><ol><li>Transform 的处理是只有一次, 可以节省多余重复的解压. </li><li>缓存是全局的. 所有的工程都能复用同一个缓存.  </li></ol><p>同时由于 Gradle 并没有对 AAR 依赖做特别的适配, 导致在2.3.0 上处理依赖的时候,需要对依赖进行二次管理,   Android Plugin 3.0.0 不需要这些额外的处理,只需要通过定义不同的 Transform 获取到对应的产物就好了. </p><h1 id="0x03-Android-Plugin-Transform-和-Gradle-Transform"><a href="#0x03-Android-Plugin-Transform-和-Gradle-Transform" class="headerlink" title="0x03 Android Plugin Transform 和 Gradle Transform"></a>0x03 Android Plugin Transform 和 Gradle Transform</h1><ul><li>维度不同<br>Android Plugin Transform 有两个维度一个是 ContentType ,一个是 Scope,  一个产物只有一个ContentType 和 Scope , Gradle 维度是 Attribute ,一个产物有多个 Attribute. </li><li>扩展能力不同<br>Android Plugin Transform 不支持自定义 ContentType , Gradle 支持自定义 Attribute . </li><li>缓存不同<br>Android Plugin Transform 将结果记录是在一个大的文件目录下, 通过不同的文件名称来表示不同 Scope 下的 ContentType.<br>Gradle Transform 是将 Transform 输出的结果记录在 Gradle 的文件缓存中,<br>由于记录的方式不同, 导致的结果是 Android plugin Transform 的一个输入对应一个输出,即使你并不对输入做任何操作, 也需要将输入的文件 copy 到输出的文件夹下.才能被下一个 Transform 正确识别. 而 Gradle Transform 不同, 记录是结果, 你完全可以不对输出目录做任何的事情, 直接将原有的输出地址返回回去. </li><li>缓存范围不同<br>Android Plugin Transform 缓存是 Application 级别的. 在 build/intermediates/transforms/目录下以transforms名称命名的.<br>Gradle Transform 是全局的, 在.gradle/caches/transforms-1/files-1.1/下, 文件名称是由所有关键信息进行 hash 算出来的. </li><li>应用不同<br>Gradle Transform 应用的是依赖的产物。 将产物A 转化成 产物B, 不支持同属性的转化.<br>Android  Plugin Transform 应用的是打包过程中的产物如 so, classs, res,dex。 这些信息大部分是由依赖产物加工而来的。支持相同ContentType 的转化. </li></ul><h1 id="0x04-总结"><a href="#0x04-总结" class="headerlink" title="0x04 总结"></a>0x04 总结</h1><p>通过上述的对比, 我们可以知道 两个 Transform 应用在不同场景, Gradle Transform  是对依赖进行处理. 这种处理是全局性的.而 Android  Plugin Transform 是对打包过程中中间产物的再处理, 是针对 Application 的. </p><h2 id="0x05-尾巴"><a href="#0x05-尾巴" class="headerlink" title="0x05 尾巴"></a>0x05 尾巴</h2><p>这一块的代码看蛮久的, 因为涉及的代码比较多, 面比较广, 需要有一个比较好的耐心和比较久的时间. 通过这一块的梳理, 对 Android plugin 3.0 和 Gradle 4.1 的依赖的管理有更好的理解.  </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://dim.red&quot;&gt;dim.red&lt;/a&gt;&lt;br&gt;环境: gradle 4.1 ,  Android Plugin 2.3.0 ,  Android Plugin 3.0.0&lt;/p&gt;
&lt;p&gt;#0x00 背景&lt;br&gt;去年的时候写个 &lt;a href=&quot;http://dim.red/2017/04/05/android_plugin_transform_%20exploration/&quot;&gt;Android Plugin Transform 初探&lt;/a&gt; . 现在我们接着之前的脚步来学习 Gradle 下的 Transform . 同时熟悉一下 Android Plugin 在该规则下的应用.&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Android 脚本自动化 SDK 原理 • View Hierarchy 的获取</title>
    <link href="http://dim.red/2017/12/24/sasuke_sdk_view_hierarchy/"/>
    <id>http://dim.red/2017/12/24/sasuke_sdk_view_hierarchy/</id>
    <published>2017-12-23T16:00:00.000Z</published>
    <updated>2019-05-29T03:50:48.064Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://dim.red">dim.red</a></p><h1 id="View-Hierarchy"><a href="#View-Hierarchy" class="headerlink" title="View Hierarchy"></a>View Hierarchy</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在脚本录制回放过程中, 我们需要获取 View Hierarchy 的意图有三个.</p><ul><li>将  View Hierarchy  结合 App 截图 发送给前端. 前端用这两个做可视化显示.</li><li>在录制中.需要获取  View Hierarchy   遍历控件, 对控件进行监听.</li><li>在回放中. 需要根据  View Hierarchy  找到 回放操作 对应的控件.<a id="more"></a></li></ul><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><p><img src="/2017/12/24/sasuke_sdk_view_hierarchy/sdk_01.png" alt="实例1"></p><h3 id="方式一-activity-onResume"><a href="#方式一-activity-onResume" class="headerlink" title="方式一: activity onResume"></a>方式一: activity onResume</h3><p>原理: ContentView 在 Activity 的onResume 里添加到屏幕上.<br>优点: 实现简单<br>缺点: 获取的视图不全面. 类似Dialog , PopWindow<br>在 实例1 中只能获取 Activity 层级, 领圣诞礼卷的对话框就获取不到了.</p><h3 id="方式二-hook-LayoutInflater"><a href="#方式二-hook-LayoutInflater" class="headerlink" title="方式二: hook LayoutInflater"></a>方式二: hook LayoutInflater</h3><p>原理: res 的 layout  资源通过 LayoutInflater 解析成 View.<br>优点: 覆盖了所有从layout资源里面加载的控件<br>缺点: 系统兼容性问题, 能兼容 90% 以上的情况. </p><h3 id="方式三-hook-WindowManager"><a href="#方式三-hook-WindowManager" class="headerlink" title="方式三: hook WindowManager"></a>方式三: hook WindowManager</h3><p>原理: 一个View 要显示在屏幕上, 都需要调用 WindowManager.add(XX) 方法.<br>优点: 覆盖了所有情况<br>缺点: 系统兼容性问题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">        Class&lt;?&gt; windowManagerGlobal = Class.forName(&quot;android.view.WindowManagerGlobal&quot;);</span><br><span class="line">        Object windowManagerGlobalInstance = on(windowManagerGlobal).call(&quot;getInstance&quot;).get();</span><br><span class="line">        Object mViewsObject = on(windowManagerGlobalInstance).field(&quot;mViews&quot;).get();</span><br><span class="line">        Object mParamsObject = on(windowManagerGlobalInstance).field(&quot;mParams&quot;).get();</span><br><span class="line">        ArrayList&lt;View&gt; mViews = (ArrayList&lt;View&gt;) mViewsObject;</span><br><span class="line">        ArrayList&lt;WindowManager.LayoutParams&gt; mParams = (ArrayList&lt;WindowManager.LayoutParams&gt;) mParamsObject;</span><br><span class="line">        ObserverArrayList&lt;View&gt; observerArrayList = createViews();</span><br><span class="line">        ObserverArrayList&lt;WindowManager.LayoutParams&gt; paramsObserverArrayList = createParams();</span><br><span class="line">        observerArrayList.addAll(mViews);</span><br><span class="line">        paramsObserverArrayList.addAll(mParams);</span><br><span class="line">        on(windowManagerGlobalInstance).set(&quot;mViews&quot;, observerArrayList);</span><br><span class="line">        on(windowManagerGlobalInstance).set(&quot;mParams&quot;, paramsObserverArrayList);</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://dim.red&quot;&gt;dim.red&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;View-Hierarchy&quot;&gt;&lt;a href=&quot;#View-Hierarchy&quot; class=&quot;headerlink&quot; title=&quot;View Hierarchy&quot;&gt;&lt;/a&gt;View Hierarchy&lt;/h1&gt;&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;在脚本录制回放过程中, 我们需要获取 View Hierarchy 的意图有三个.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将  View Hierarchy  结合 App 截图 发送给前端. 前端用这两个做可视化显示.&lt;/li&gt;
&lt;li&gt;在录制中.需要获取  View Hierarchy   遍历控件, 对控件进行监听.&lt;/li&gt;
&lt;li&gt;在回放中. 需要根据  View Hierarchy  找到 回放操作 对应的控件.&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Android 脚本自动化 SDK 原理</title>
    <link href="http://dim.red/2017/12/23/sasuke_sdk/"/>
    <id>http://dim.red/2017/12/23/sasuke_sdk/</id>
    <published>2017-12-22T16:00:00.000Z</published>
    <updated>2018-08-25T15:11:43.267Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://dim.red">dim.red</a><br><a id="more"></a></p><h1 id="一-录制"><a href="#一-录制" class="headerlink" title="一. 录制"></a>一. 录制</h1><ul><li><a href="https://www.jianshu.com/p/3a7c189d13f9" target="_blank" rel="noopener">View Hierarchy 的获取</a></li><li>事件录制</li><li>Xpath 优化 </li></ul><h1 id="二-回放"><a href="#二-回放" class="headerlink" title="二. 回放"></a>二. 回放</h1><ul><li>控件的寻找</li><li>事件回放</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://dim.red&quot;&gt;dim.red&lt;/a&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>小技巧︰ 动态代理 巧用</title>
    <link href="http://dim.red/2017/12/16/inovel_dynamic_proxy/"/>
    <id>http://dim.red/2017/12/16/inovel_dynamic_proxy/</id>
    <published>2017-12-15T16:00:00.000Z</published>
    <updated>2018-08-25T08:43:17.067Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://dim.red">dim.red</a></p><p>#背景<br>android 的中设置监听有两种. </p><ul><li>一种 setOnXXListener (eg View.setOncClickListener()) .</li><li>一种 addOnXXXListener (TextView.addTextWatchListener());<br>两种的区别是第一种内部只会保存一个listener, 每次调用就是覆盖.<br>第二种内部会保存一个List, 每次调用的时候就是添加一个监听器.<a id="more"></a></li></ul><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public interface OnStatusListener &#123;</span><br><span class="line">    void onChange();</span><br><span class="line">    void onChange1();</span><br><span class="line">    void onChange2();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="优化前"><a href="#优化前" class="headerlink" title="优化前"></a>优化前</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class StastusManager &#123;</span><br><span class="line"></span><br><span class="line">    private List&lt;OnStatusListener&gt; onStatusListeners = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public void addOnStastusListener(OnStatusListener onStatusListener) &#123;</span><br><span class="line">        onStatusListeners.add(onStatusListener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void removeOnStatusListener(OnStatusListener onStatusListener) &#123;</span><br><span class="line">        onStatusListeners.remove(onStatusListener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void onChange() &#123;</span><br><span class="line">        for (OnStatusListener onStatusListener : onStatusListeners) &#123;</span><br><span class="line">            onStatusListener.onChange();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public void onChange1() &#123;</span><br><span class="line">        for (OnStatusListener onStatusListener : onStatusListeners) &#123;</span><br><span class="line">            onStatusListener.onChange1();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public void onChange2() &#123;</span><br><span class="line">        for (OnStatusListener onStatusListener : onStatusListeners) &#123;</span><br><span class="line">            onStatusListener.onChange2();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当接口方法多了以后, 相似代码就变更多了.<br>我们使用动态代理 优化一下相似代码  </p><h2 id="优化后"><a href="#优化后" class="headerlink" title="优化后"></a>优化后</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class StastusManager &#123;</span><br><span class="line"></span><br><span class="line">    private DynamicInterface&lt;OnStatusListener&gt; onStatusListeners = DynamicFactory.newObject(OnStatusListener.class);</span><br><span class="line"></span><br><span class="line">    public void addOnStastusListener(OnStatusListener onStatusListener) &#123;</span><br><span class="line">        onStatusListeners.addT(onStatusListener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void removeOnStatusListener(OnStatusListener onStatusListener) &#123;</span><br><span class="line">        onStatusListeners.removeT(onStatusListener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void onChange() &#123;</span><br><span class="line">        onStatusListeners.castT().onChange();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void onChange1() &#123;</span><br><span class="line">        onStatusListeners.castT().onChange1();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void onChange2() &#123;</span><br><span class="line">        onStatusListeners.castT().onChange2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优化以后没有了 List 类和每次的 for 循环. 现在还不能感觉到这个方式的好处. 当你有大量的 addXXlistener 你会发现, 比起之前的方式. 这种更加的优雅.<br>下面是实现的关键代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Created by dim on 2017/12/16.</span><br><span class="line"> */</span><br><span class="line">@Keep</span><br><span class="line">public interface DynamicInterface&lt;T extends Object&gt; &#123;</span><br><span class="line"></span><br><span class="line">    void addT(T t);</span><br><span class="line"></span><br><span class="line">    void removeT(T t);</span><br><span class="line"></span><br><span class="line">    T castT();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Created by dim on 2017/12/16.</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">public class DynamicFactory &#123;</span><br><span class="line"></span><br><span class="line">    public static &lt;T&gt; DynamicInterface&lt;T&gt; newObject(final Class&lt;T&gt; cls) &#123;</span><br><span class="line"></span><br><span class="line">        if (!cls.isInterface()) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;API declarations must be interfaces.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (cls.getInterfaces().length &gt; 0) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;API interfaces must not extend other interfaces.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return (DynamicInterface&lt;T&gt;) Proxy.newProxyInstance(cls.getClassLoader(),</span><br><span class="line">                new Class&lt;?&gt;[]&#123;cls, DynamicInterface.class&#125;, new InvocationHandler() &#123;</span><br><span class="line">                    private List&lt;T&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">                    @Override</span><br><span class="line">                    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line"></span><br><span class="line">                        if (method.getName().equals(&quot;addT&quot;) || method.getName().equals(&quot;removeT&quot;)) &#123;</span><br><span class="line">                            if (args != null &amp;&amp; args.length == 1 &amp;&amp; cls.isInstance(args[0])) &#123;</span><br><span class="line">                                if (method.getName().equals(&quot;addT&quot;)) &#123;</span><br><span class="line">                                    list.add((T) args[0]);</span><br><span class="line">                                &#125; else if (method.getName().equals(&quot;removeT&quot;)) &#123;</span><br><span class="line">                                    list.remove((T) args[0]);</span><br><span class="line">                                &#125;</span><br><span class="line">                                return null;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        if (method.getName().equals(&quot;castT&quot;) &amp;&amp; args == null) &#123;</span><br><span class="line">                            return proxy;</span><br><span class="line">                        &#125;</span><br><span class="line">                        Class&lt;?&gt; returnType = method.getReturnType();</span><br><span class="line">                        if (returnType.isAssignableFrom(boolean.class)) &#123;</span><br><span class="line"></span><br><span class="line">                            boolean object = true;</span><br><span class="line">                            for (T t : list) &#123;</span><br><span class="line">                                if (!(boolean) method.invoke(t, args)) &#123;</span><br><span class="line">                                    object = false;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                            return object;</span><br><span class="line">                        &#125; else if (returnType.isAssignableFrom(Boolean.class)) &#123;</span><br><span class="line">                            Boolean object = Boolean.TRUE;</span><br><span class="line">                            Boolean temp;</span><br><span class="line">                            for (T t : list) &#123;</span><br><span class="line">                                if ((temp = (Boolean) method.invoke(t, args)) != null &amp;&amp; !temp) &#123;</span><br><span class="line">                                    object = Boolean.FALSE;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                            return object;</span><br><span class="line">                        &#125; else if (returnType.isAssignableFrom(Void.class) || returnType.isAssignableFrom(void.class)) &#123;</span><br><span class="line">                            for (T t : list) &#123;</span><br><span class="line">                                method.invoke(t, args);</span><br><span class="line">                            &#125;</span><br><span class="line">                            return null;</span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">                            throw new IllegalArgumentException(&quot;returnType must boolean Boolean Void void&quot;);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://dim.red&quot;&gt;dim.red&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;#背景&lt;br&gt;android 的中设置监听有两种. &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一种 setOnXXListener (eg View.setOncClickListener()) .&lt;/li&gt;
&lt;li&gt;一种 addOnXXXListener (TextView.addTextWatchListener());&lt;br&gt;两种的区别是第一种内部只会保存一个listener, 每次调用就是覆盖.&lt;br&gt;第二种内部会保存一个List, 每次调用的时候就是添加一个监听器.&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>借助微信 构建 Android Project 编译通知</title>
    <link href="http://dim.red/2017/12/14/wechat_notify_system/"/>
    <id>http://dim.red/2017/12/14/wechat_notify_system/</id>
    <published>2017-12-13T16:00:00.000Z</published>
    <updated>2019-05-29T03:53:17.544Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://dim.red">dim.red</a>  </p><h1 id="一-背景"><a href="#一-背景" class="headerlink" title="一 背景"></a>一 背景</h1><p> 最近萌生一个想法, 在项目编译成功的时候给自己发送一条微信.</p><p><img src="/2017/12/14/wechat_notify_system/wechat_notify_system_01.png" alt="效果图.png"><br><a id="more"></a></p><h1 id="二-原理"><a href="#二-原理" class="headerlink" title="二 原理"></a>二 原理</h1><p>我们需要跟微信进行交互 , 为了达到这个效果 . 我们在 微信 App 内开启一个 Http 服务. 当项目编译完成以后发起一个 Http 请求.  Http 服务响应这个请求. 将获取的数据转发发送给自己 . </p><h1 id="三-实现"><a href="#三-实现" class="headerlink" title="三 实现"></a>三 实现</h1><h2 id="1-Http-服务"><a href="#1-Http-服务" class="headerlink" title="1 Http 服务."></a>1 Http 服务.</h2><p> 我们在 <strong><a href="https://github.com/TKkk-iOSer/WeChatPlugin-MacOS" target="_blank" rel="noopener">WeChatPlugin-MacOS</a></strong> 的基础上做扩展 . 同时使用第三方库 GCDWebServer 进行快速的搭建 Http服务 .</p><h3 id="1-1-添加-GCDWebServer-依赖"><a href="#1-1-添加-GCDWebServer-依赖" class="headerlink" title="1.1 添加 GCDWebServer 依赖"></a>1.1 添加 GCDWebServer 依赖</h3><p>将原有的 [WeChatPlugin-MacOS] 项目 转换成 cocoapods 管理 .<br>将 GCDWebServer 添加到 Podfile<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">platform :osx, &apos;10.10&apos;</span><br><span class="line">inhibit_all_warnings!</span><br><span class="line"></span><br><span class="line">target &apos;WeChatPlugin&apos; do</span><br><span class="line">  pod &apos;GCDWebServer&apos;</span><br><span class="line">end</span><br></pre></td></tr></table></figure></p><h3 id="1-2-开启-Http-服务"><a href="#1-2-开启-Http-服务" class="headerlink" title="1.2 开启 Http 服务"></a>1.2 开启 Http 服务</h3><p>WeChatPlugin/sources/Category/WeChat+hook.h<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;GCDWebServer/GCDWebServer.h&gt;</span><br><span class="line">#import &lt;GCDWebServer/GCDWebServerDataResponse.h&gt;</span><br></pre></td></tr></table></figure></p><p>WeChatPlugin/sources/Category/WeChat+hook.m<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">static GCDWebServer *server;</span><br><span class="line">+ (void)setup &#123;</span><br><span class="line">   </span><br><span class="line">    server = [[GCDWebServer alloc] init];       </span><br><span class="line">    [server addHandlerForMethod:@&quot;GET&quot; path:@&quot;/wechat/notify&quot; requestClass:[GCDWebServerRequest class] processBlock:^GCDWebServerResponse * _Nullable(__kindof GCDWebServerRequest * _Nonnull request) &#123;</span><br><span class="line">        NSString *msg = [request.query[@&quot;msg&quot;] lowercaseString] ? : @&quot;&quot;;</span><br><span class="line">        NSString *currentUserName = [objc_getClass(&quot;CUtility&quot;) GetCurrentUserName];</span><br><span class="line">        MessageService *service = [[objc_getClass(&quot;MMServiceCenter&quot;) defaultCenter] getService:objc_getClass(&quot;MessageService&quot;)];</span><br><span class="line">        [service SendTextMessage:currentUserName toUsrName:currentUserName msgText:msg atUserList:nil];</span><br><span class="line">        return [GCDWebServerDataResponse responseWithJSONObject:@&#123;@&quot;success&quot;:@&quot;true&quot;&#125;];</span><br><span class="line">    &#125;];</span><br><span class="line"> </span><br><span class="line">    [server startWithOptions:@&#123;GCDWebServerOption_Port: @(9090),</span><br><span class="line">                                    GCDWebServerOption_BindToLocalhost: @(YES)&#125; error:nil];</span><br><span class="line">    ...</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><h2 id="2-发送-Http-请求"><a href="#2-发送-Http-请求" class="headerlink" title="2 发送 Http 请求"></a>2 发送 Http 请求</h2><h3 id="2-1-设置监听器"><a href="#2-1-设置监听器" class="headerlink" title="2.1 设置监听器"></a>2.1 设置监听器</h3><p>在 <code>/Users/{username}/.gradle</code> 下建立一个文件 <code>init.gradle</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">allprojects &#123;</span><br><span class="line"></span><br><span class="line">    if (project.getProperties().get(&quot;notiy&quot;, false)) &#123;</span><br><span class="line">        project.pluginManager.withPlugin(&quot;com.android.application&quot;, &#123;</span><br><span class="line">            def pj = project;</span><br><span class="line">            def projectName = project.rootProject.name + &quot;:&quot; + pj.name;</span><br><span class="line">            def clock = new org.gradle.internal.time.Clock()</span><br><span class="line">            pj.getGradle().addBuildListener(new BuildListener() &#123;</span><br><span class="line"></span><br><span class="line">                @Override</span><br><span class="line">                void buildStarted(Gradle gradle) &#123;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                @Override</span><br><span class="line">                void settingsEvaluated(Settings settings) &#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                @Override</span><br><span class="line">                void projectsLoaded(Gradle gradle) &#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                @Override</span><br><span class="line">                void projectsEvaluated(Gradle gradle) &#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                @Override</span><br><span class="line">                void buildFinished(BuildResult result) &#123;</span><br><span class="line"></span><br><span class="line">                    boolean isAssembleTask = false</span><br><span class="line">                    pj.android.applicationVariants.each &#123; variant -&gt;</span><br><span class="line">                        if (variant.getAssemble().state.executed) &#123;</span><br><span class="line">                            isAssembleTask = true</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    def sp = pj.gradle.startParameter</span><br><span class="line">                    def t = sp.taskNames[0] as String</span><br><span class="line"></span><br><span class="line">                    NameMatcher nameMatcher = new NameMatcher()</span><br><span class="line">                    def taskName = nameMatcher.find(t, pj.tasks.asMap.keySet());</span><br><span class="line">                    taskName = taskName == null ? t : taskName;</span><br><span class="line"></span><br><span class="line">                    if (isAssembleTask || (result.failure != null &amp;&amp; (taskName.startsWith(&quot;assemble&quot;) || taskName.startsWith(&quot;install&quot;)))) &#123;</span><br><span class="line">                        String msg;</span><br><span class="line">                        if (result.failure == null) &#123;</span><br><span class="line">                            msg = &quot;项目 : $&#123;projectName&#125; \n任务 : $&#123;taskName&#125; \n编译 : 成功\n&quot; +</span><br><span class="line">                                    &quot;耗时 : $&#123;clock.elapsed&#125;&quot;</span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">                            msg = &quot;项目 : $&#123;projectName&#125; \n任务 : $&#123;taskName&#125; \n编译 : 失败\n&quot; +</span><br><span class="line">                                    &quot;错误 : $&#123;result.failure.getMessage()&#125;\n&quot; +</span><br><span class="line">                                    &quot;耗时 : $&#123;clock.elapsed&#125;&quot;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        (&quot;curl -X GET   http://localhost:9090/wechat/notify?msg=&quot; +</span><br><span class="line">                                URLEncoder.encode(msg, &quot;UTF-8&quot;)).execute()</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line"></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里在 gradle init 的时候加入监听 , 监听所有 android 项目的编译 ,  判断编译命令中是否包含参数 notiy , 并且 notity 为 true , 如果判断成功当编译完成 , 使用 curl 将编译结果发送 Http 服务 .  </p><h3 id="2-2-命令行使用"><a href="#2-2-命令行使用" class="headerlink" title="2.2 命令行使用"></a>2.2 命令行使用</h3><p>在原有的编译命令添加额外参数 <code>-P notiy=true</code><br>eg:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./gradlew assembleDebug -P notiy=true</span><br></pre></td></tr></table></figure></p><h3 id="2-3-优化"><a href="#2-3-优化" class="headerlink" title="2.3 优化"></a>2.3 优化</h3><p>为了优化体验.我们可以将参数设置成默认.<br>因为 Android 项目的编译触发有两种方式: 命令行 和 idea . 这里的优化也分为两种情况,<br>情况一 : 命令行<br>修改 gradlew 文件末端 , 添加 <code>&quot;-P&quot; &quot;notiy=true&quot;</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exec &quot;$JAVACMD&quot; &quot;$&#123;JVM_OPTS[@]&#125;&quot; -classpath &quot;$CLASSPATH&quot; org.gradle.wrapper.GradleWrapperMain &quot;$@&quot; &quot;-P&quot; &quot;notiy=true&quot;</span><br></pre></td></tr></table></figure></p><p>情况二 : Idea<br>配置添加 <code>-P notiy=true</code><br><img src="/2017/12/14/wechat_notify_system/wechat_notify_system_02.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://dim.red&quot;&gt;dim.red&lt;/a&gt;  &lt;/p&gt;
&lt;h1 id=&quot;一-背景&quot;&gt;&lt;a href=&quot;#一-背景&quot; class=&quot;headerlink&quot; title=&quot;一 背景&quot;&gt;&lt;/a&gt;一 背景&lt;/h1&gt;&lt;p&gt; 最近萌生一个想法, 在项目编译成功的时候给自己发送一条微信.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2017/12/14/wechat_notify_system/wechat_notify_system_01.png&quot; alt=&quot;效果图.png&quot;&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>使用 AOP 来为第三方 SDK 打 CALL</title>
    <link href="http://dim.red/2017/12/04/aop/"/>
    <id>http://dim.red/2017/12/04/aop/</id>
    <published>2017-12-03T16:00:00.000Z</published>
    <updated>2018-08-25T08:43:16.992Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://dim.red">dim.red</a></p><h1 id="一-背景"><a href="#一-背景" class="headerlink" title="一 背景"></a>一 背景</h1><p>android 的版本的更替往往需要开发者进行跟进.</p><p>Notification 在Android 8.0 上需要做一些兼容的工作.<a href="https://developer.android.com/guide/topics/ui/notifiers/notifications.html" target="_blank" rel="noopener">官方指导文档</a><br><a id="more"></a></p><h2 id="二-适配"><a href="#二-适配" class="headerlink" title="二 适配"></a>二 适配</h2><p>适配工作分为两步</p><h3 id="1-根据一个channelId-生成NotificationChannel-作为推送通道"><a href="#1-根据一个channelId-生成NotificationChannel-作为推送通道" class="headerlink" title="1 根据一个channelId 生成NotificationChannel 作为推送通道"></a>1 根据一个channelId 生成NotificationChannel 作为推送通道</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public static void init(Context ctx) &#123;</span><br><span class="line">       if (SDK_INT &gt;= 26) &#123;</span><br><span class="line">           String channelId = &quot;dim&quot;;</span><br><span class="line">           NotificationManager manager = (NotificationManager) Application.getApplicationContext().getSystemService(Context.NOTIFICATION_SERVICE);</span><br><span class="line">           if (manager != null) &#123;</span><br><span class="line">               NotificationChannel taco = manager.getNotificationChannel(channelId);</span><br><span class="line">               if (taco == null) &#123;</span><br><span class="line">                   int importance = NotificationManager.IMPORTANCE_HIGH;</span><br><span class="line">                   NotificationChannel channel = new NotificationChannel(channelId, channelId, importance);</span><br><span class="line">                   channel.setDescription(TACO_CHANNEL);</span><br><span class="line">                   manager.createNotificationChannel(channel);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="2-所有的通知需要设置-channelId"><a href="#2-所有的通知需要设置-channelId" class="headerlink" title="2 所有的通知需要设置 channelId:"></a>2 所有的通知需要设置 channelId:</h3><p>设置的方式:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new Notification.Builder(ctx).setChannelId(channelId);</span><br></pre></td></tr></table></figure></p><p>到此兼容的工作算是完成了.<br>但是这里的兼容只是局限在我们自己的业务代码.</p><h2 id="三-业务外的代码怎么办呢"><a href="#三-业务外的代码怎么办呢" class="headerlink" title="三. 业务外的代码怎么办呢?"></a>三. 业务外的代码怎么办呢?</h2><p>比如说在个推的GetuiSDK2.10.3.5 并没有对 Notification 做相关的处理.</p><p>Q: 怎么办?<br>A: 使用 AOP 为第三方 SDK 修BUG , 适配新特性 . </p><p> AOP 的实现有很多方式,这里我们会讲3种方式来实现这个效果.</p><h4 id="一-使用-lancet-饿了么开源的-AOP-框架"><a href="#一-使用-lancet-饿了么开源的-AOP-框架" class="headerlink" title="一. 使用 lancet  ( 饿了么开源的 AOP 框架 )"></a>一. 使用 <a href="https://github.com/eleme/lancet" target="_blank" rel="noopener">lancet</a>  ( 饿了么开源的 AOP 框架 )</h4><p>引入:<a href="https://github.com/eleme/lancet" target="_blank" rel="noopener">https://github.com/eleme/lancet</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public class NotifactionFix &#123;</span><br><span class="line"></span><br><span class="line">     public static final String CHANNEL = &quot;dim&quot;;</span><br><span class="line"></span><br><span class="line">    @Proxy(&quot;notify&quot;)</span><br><span class="line">    @TargetClass(&quot;android.app.NotificationManager&quot;)</span><br><span class="line">    public void notify(int id, Notification notification) &#123;</span><br><span class="line">        if (SDK_INT &gt;= 26) &#123;</span><br><span class="line">            maybeSetChannelId(notification);</span><br><span class="line">        &#125;</span><br><span class="line">        Origin.callVoid();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Proxy(&quot;notify&quot;)</span><br><span class="line">    @TargetClass(&quot;android.app.NotificationManager&quot;)</span><br><span class="line">    public void notify(String tag, int id, Notification notification) &#123;</span><br><span class="line">        maybeSetChannelId(notification);</span><br><span class="line">        Origin.callVoid();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   public static void maybeSetChannelId(Notification notification) &#123;</span><br><span class="line">        if (SDK_INT &gt;= 26) &#123;</span><br><span class="line">            if (TextUtils.isEmpty(notification.getChannelId())) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    Field mChannelId = Notification.class.getDeclaredField(&quot;mChannelId&quot;);</span><br><span class="line">                    mChannelId.setAccessible(true);</span><br><span class="line">                    mChannelId.set(notification,CHANNEL);</span><br><span class="line">                &#125; catch (NoSuchFieldException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; catch (IllegalAccessException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="二-使用-aspectjX"><a href="#二-使用-aspectjX" class="headerlink" title="二 使用 aspectjX"></a>二 使用 <a href="https://github.com/HujiangTechnology/gradle_plugin_android_aspectjx" target="_blank" rel="noopener">aspectjX</a></h4><p>引入 :<a href="https://github.com/HujiangTechnology/gradle_plugin_android_aspectjx" target="_blank" rel="noopener">https://github.com/HujiangTechnology/gradle_plugin_android_aspectjx</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">@Aspect</span><br><span class="line">public class NotificationFix &#123;</span><br><span class="line"></span><br><span class="line">    public static final String CHANNEL = &quot;dim&quot;;</span><br><span class="line"></span><br><span class="line">    private static NotificationFix sNotificationFix = new NotificationFix();</span><br><span class="line"></span><br><span class="line">    public static NotificationFix aspectOf() &#123;</span><br><span class="line">        return sNotificationFix;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Pointcut(&quot;call(public void android.app.NotificationManager.notify(..))&quot;)</span><br><span class="line">    void notificationManager_notifyMethod() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Before(&quot;notificationManager_notifyMethod()&quot;)</span><br><span class="line">    public void hookNotificationManager_notifyMethod(JoinPoint joinPoint) &#123;</span><br><span class="line">        Log.e(&quot;dim&quot;, &quot;hookNotificationManager_notifyMethod: &quot;);</span><br><span class="line">        for (Object arg : joinPoint.getArgs()) &#123;</span><br><span class="line">            if (arg != null &amp;&amp; arg instanceof Notification) &#123;</span><br><span class="line">                maybeSetChannelId((Notification) arg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   public static void maybeSetChannelId(Notification notification) &#123;</span><br><span class="line">        if (SDK_INT &gt;= 26) &#123;</span><br><span class="line">            if (TextUtils.isEmpty(notification.getChannelId())) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    Field mChannelId = Notification.class.getDeclaredField(&quot;mChannelId&quot;);</span><br><span class="line">                    mChannelId.setAccessible(true);</span><br><span class="line">                    mChannelId.set(notification, CHANNEL);</span><br><span class="line">                &#125; catch (NoSuchFieldException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; catch (IllegalAccessException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="三-使用-ASM-框架"><a href="#三-使用-ASM-框架" class="headerlink" title="三 使用 ASM 框架."></a>三 使用 ASM 框架.</h4><h5 id="3-1-Android-Plugin-处理"><a href="#3-1-Android-Plugin-处理" class="headerlink" title="3.1 Android Plugin 处理"></a>3.1 Android Plugin 处理</h5><p>在androisjd 打包中加入对 class 的处理<br>引入’ compile ‘org.ow2.asm:asm:6.0_ALPHA’’</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">byte[] process(byte[] src) &#123;</span><br><span class="line">       try &#123;</span><br><span class="line">           ClassReader classReader = new ClassReader(src);</span><br><span class="line">           ClassWriter cw = new ClassWriter(classReader, ClassWriter.COMPUTE_MAXS);</span><br><span class="line">           classReader.accept(new AopClassVisitor(cw, sasukeExtension), ClassReader.EXPAND_FRAMES);</span><br><span class="line">           return cw.toByteArray();</span><br><span class="line">       &#125; catch (Exception e) &#123;</span><br><span class="line">           return src;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>AopClassVisitor.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class AopClassVisitor extends ClassVisitor &#123;</span><br><span class="line">     private String className;</span><br><span class="line"></span><br><span class="line">    public AopClassVisitor(ClassWriter cw) &#123;</span><br><span class="line">        super(Opcodes.ASM5, cw);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void visit(int version, int access, String name, String signature, String superName, String[] interfaces) &#123;</span><br><span class="line">        className = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) &#123;</span><br><span class="line">        if (className.equals(&quot;red/dim/hook/NotificationFix&quot;)) &#123;</span><br><span class="line">            return super.visitMethod(access, name, desc, signature, exceptions);</span><br><span class="line">        &#125;</span><br><span class="line">        return new AopMethodVisitor(super.visitMethod(access, name, desc, signature, exceptions));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>AopMethodVisitor.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class AopMethodVisitor extends MethodVisitor &#123;</span><br><span class="line">    AopMethodVisitor(MethodVisitor methodVisitor) &#123;</span><br><span class="line">        super(Opcodes.ASM5, methodVisitor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void visitMethodInsn(int opcode, String owner, String name, String desc, boolean itf) &#123;</span><br><span class="line">        if (opcode == Opcodes.INVOKEINTERFACE</span><br><span class="line">                &amp;&amp; &quot;android/app/NotificationManager&quot;.equals(owner)</span><br><span class="line">                &amp;&amp; &quot;notify&quot;.equals(name)</span><br><span class="line">                &amp;&amp; &quot;(I;Landroid/app/Notification)V&quot;.equals(desc)) &#123;</span><br><span class="line">            visitMethodInsn(Opcodes.INVOKESTATIC, &quot;red/dim/hook/NotificationFix&quot;, &quot;notify&quot;, &quot;(Landroid/app/NotificationManager;I;Landroid/app/Notification)V&quot;, false);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if (opcode == Opcodes.INVOKEINTERFACE</span><br><span class="line">                &amp;&amp; &quot;android/app/NotificationManager&quot;.equals(owner)</span><br><span class="line">                &amp;&amp; &quot;notify&quot;.equals(name)</span><br><span class="line">                &amp;&amp; &quot;(Ljava.lang.String;I;Landroid/app/Notification)V&quot;.equals(desc)) &#123;</span><br><span class="line">            visitMethodInsn(Opcodes.INVOKESTATIC, &quot;red/dim/hook/NotificationFix&quot;, &quot;notify&quot;, &quot;(Landroid/app/NotificationManager;Ljava.lang.String;I;Landroid/app/Notification)V&quot;, false);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        super.visitMethodInsn(opcode, owner, name, desc, itf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>上述的代码通过字节码分析将所有的NotificationManager 的 notify 的两个方法的调用都路由到<br> NotificationFix 的 notify 静态方法上.</p><h5 id="3-2-SDK-处理"><a href="#3-2-SDK-处理" class="headerlink" title="3.2  SDK 处理"></a>3.2  SDK 处理</h5><p>在 SDK 加入处理类<br>red.dim.hook.NotificationFix.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class NotificationFix &#123;</span><br><span class="line"></span><br><span class="line">    public static final String CHANNEL = &quot;dim&quot;;</span><br><span class="line"></span><br><span class="line">    public static void notify(NotificationManager notificationManager, int id, Notification notification) &#123;</span><br><span class="line">        maybeSetChannelId(notification);</span><br><span class="line">        notificationManager.notify(id, notification);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void notify(NotificationManager notificationManager, String tag, int id, Notification notification) &#123;</span><br><span class="line">        maybeSetChannelId(notification);</span><br><span class="line">        notificationManager.notify(tag, id, notification);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void maybeSetChannelId(Notification notification) &#123;</span><br><span class="line">        if (SDK_INT &gt;= 26) &#123;</span><br><span class="line">            if (TextUtils.isEmpty(notification.getChannelId())) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    Field mChannelId = Notification.class.getDeclaredField(&quot;mChannelId&quot;);</span><br><span class="line">                    mChannelId.setAccessible(true);</span><br><span class="line">                    mChannelId.set(notification, CHANNEL);</span><br><span class="line">                &#125; catch (NoSuchFieldException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; catch (IllegalAccessException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="四-总结"><a href="#四-总结" class="headerlink" title="四 总结"></a>四 总结</h1><p>三种 AOP 方式 各有优势</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://dim.red&quot;&gt;dim.red&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;一-背景&quot;&gt;&lt;a href=&quot;#一-背景&quot; class=&quot;headerlink&quot; title=&quot;一 背景&quot;&gt;&lt;/a&gt;一 背景&lt;/h1&gt;&lt;p&gt;android 的版本的更替往往需要开发者进行跟进.&lt;/p&gt;
&lt;p&gt;Notification 在Android 8.0 上需要做一些兼容的工作.&lt;a href=&quot;https://developer.android.com/guide/topics/ui/notifiers/notifications.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;官方指导文档&lt;/a&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>AspectJ 在Android 上的应用和加速</title>
    <link href="http://dim.red/2017/04/23/aspectj_aop/"/>
    <id>http://dim.red/2017/04/23/aspectj_aop/</id>
    <published>2017-04-22T16:00:00.000Z</published>
    <updated>2019-05-29T03:41:40.076Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://dim.red">dim.red</a></p><h1 id="开头"><a href="#开头" class="headerlink" title="开头"></a>开头</h1><p>java上的AOP 框架比较出名的是AspectJ，比较可惜的是这个框架是在gradle上需要一些变换才能使用。<br><a id="more"></a><br>在使用这个框架之前,我们来看AspectJ 命令的几个比较重要的参数：<br>-classpath：class和source 的位置<br>-aspectpath： 定义了切面规则的class<br>-d：指定输出的目录<br>-outjar：指定输出的jar上<br>-inpath：需要处理的.class<br>classpath 的作用是在当解析一个类的时候，当这个类是不在inpath 中，会从classpath 中寻找。<br>在使用AspectJ的时候, 我们用以下几个方面来优化我们的速度。</p><h2 id="一-多线程"><a href="#一-多线程" class="headerlink" title="一 多线程:"></a>一 多线程:</h2><p>首先我们通过android plugin的Transform api ，收集所有的class文件。<br>然后用AspectJ处理所有的class.输出到对应的目录下。<br>这里我们为了保证transform灵活性，我们不将所有的class 合并成一个jar，而是每个输入对应一个输出。同时使用多线程来为这个过程加速。<br>在后续的使用我们发现单纯的直接用多线程来处理这个问题，会引发一个异常，异常如下：<br><img src="/2017/04/23/aspectj_aop/aspectj_aop_01.png" alt="异常.png"><br>通过分析可以发现问题是出现在CompilerAdapter 类下，具体是因为CompilerAdapter 会被注入到相关类中。而注入的是同一个实例，在多线程下操作中，一并发就会导致一些bug， 我们重新编写CompilerAdapter 类。在对应的field上用ThreadLocal 包裹，使在参数实例在多线程下隔离，这样就简单的解决问题。</p><p>这里有个比较有意思的点是：AspectJ AOP 框架对自身的代码进行了AOP编程。</p><h2 id="二-指定精确的aspectpath"><a href="#二-指定精确的aspectpath" class="headerlink" title="二 指定精确的aspectpath"></a>二 指定精确的aspectpath</h2><p>为了加速aspectJ的处理过程， 我们会将aspectpath对应的class 找出来，然后在AspectJ处理的时候将参数指向给aspectpath。 我们通过用ASM 框架解析类，查找所有被Lorg/aspectj/lang/annotation/Aspect 注释的类，收集到一个单独的文件夹中。这样可以为AspectJ处理提升速度。<br>同时为了加快查找aspectpath 的文件。<br>我们支持了对Android library 和Java Library 的aspectpath 文件进行标注。在主项目中查找aspectpath 文件的时候，可以根据这个标注更快的收集.</p><ul><li>Android Library 我们定义2个Transform ，一个针对Class，收集和分析class，一个针对资源，将上个Transform收集的结果写入Java Resource 中的NOTICE文件。</li><li>Java Library 则是在jar task 后面分析生成的jar文件.同样把结果写入Java Resource 的 NOTICE文件。</li></ul><p>这里之所以使用NOTICE ，而不使用别的，一是为了兼容Android Plugin 版本的变迁。二是因为 Android Plugin 的Java Resource 的合并是会忽略掉几个特定的文件，而NOTICE就在这几个特定文件中。<br>2.0 Android Plugin 忽略的文件：<br><img src="/2017/04/23/aspectj_aop/aspectj_aop_02.png" alt="Android Plugin 2.0 "></p><p>2.3 Android Plugin 忽略的文件：<br><img src="/2017/04/23/aspectj_aop/aspectj_aop_03.png" alt="Android Plugin 2.3.png"></p><p>使用NOTICE 好处就是，你用插件处理的jar 包或者aar 在应用到不相干的项目中，在生成的APK不会多余令人困户的配置文件存在。</p><h2 id="三-支持增量："><a href="#三-支持增量：" class="headerlink" title="三 支持增量："></a>三 支持增量：</h2><p>我们几乎所有的Transform 都支持了增量编译，意思是AspectJ 并不会每次都处理所有的class， 他只会处理有变更的class 文件。 除非是你的aspectpath文件出现了变更，即AOP规则变更了, 之前的处理结果已经不可靠了，就会触发一次全量的处理。<br>为了支持这个特性，我们必须手动的为AspectJ 新增一个参数  <code>-infiles</code>。为了这个特性我们必须去修改aspectJ 的源码。修改以下3个类 <code>org.aspectj.ajdt.internal.core.builder.AjBuildManager</code>和<code>org.aspectj.ajdt.internal.core.builder.AjBuildConfig</code> 和<code>org.aspectj.ajdt.ajc.BuildArgParser</code>， 这个特性在持续开发中对于节省时间特别有效。</p><p>因为在一些需求我们需要修改AspectJ的代码，因为AspectJ 的源码编译比较麻烦。我们这里使用修改后的java编译出的class 文件，然后直接覆盖AspectJ jar包中对应的文件上。</p><h1 id="结尾"><a href="#结尾" class="headerlink" title="结尾:"></a>结尾:</h1><p>我们将所有的代码放置在github 上 <a href="https://github.com/zzz40500/AspectJAOP" target="_blank" rel="noopener">AspectJAOP</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://dim.red&quot;&gt;dim.red&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;开头&quot;&gt;&lt;a href=&quot;#开头&quot; class=&quot;headerlink&quot; title=&quot;开头&quot;&gt;&lt;/a&gt;开头&lt;/h1&gt;&lt;p&gt;java上的AOP 框架比较出名的是AspectJ，比较可惜的是这个框架是在gradle上需要一些变换才能使用。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Android Plugin Transform 初探</title>
    <link href="http://dim.red/2017/04/05/android_plugin_transform_%20exploration/"/>
    <id>http://dim.red/2017/04/05/android_plugin_transform_ exploration/</id>
    <published>2017-04-04T16:00:00.000Z</published>
    <updated>2018-11-17T17:59:08.666Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://dim.red">dim.red</a></p><p>环境: android gradle 2.3 </p><p><a href="http://tools.android.com/tech-docs/new-build-system/transform-api" target="_blank" rel="noopener">transform api</a></p><h2 id="一-概况"><a href="#一-概况" class="headerlink" title="一 概况"></a>一 概况</h2><p>transform 开始于1.5.0-beta1 可以用于在android 打包,class转换成dex 过程中,加入开发者自定义的处理逻辑. 他也可以处理native.只是native 这里处理的是so 文件的,再加工难度比较大. </p><h2 id="二-定义"><a href="#二-定义" class="headerlink" title="二 定义"></a>二 定义</h2><p><code>ContentType</code>:<br>CLASSES,<br>RESOURCES,<br>DEX,<br>NATIVE_LIBS,<br>CLASSES_ENHANCED,<br>JACK<br>ContentType表示文件的类型. CLASSES 这个是javac 编译成class文件<br>RESOURCES: 这里的resources 单指Java 的资源.<br>DEX 这个是class 文件dx 编译成的dex 文件.<br>比较可惜的是自定义的 transform 无法处理这些文件. 具体原因看后面.<br><code>Scope:</code><br>        PROJECT(0x01),<br>        PROJECT_LOCAL_DEPS(0x02),<br>        SUB_PROJECTS(0x04),<br>        SUB_PROJECTS_LOCAL_DEPS(0x08),<br>        EXTERNAL_LIBRARIES(0x10),<br>        TESTED_CODE(0x20),<br>        PROVIDED_ONLY(0x40)  </p><p>通过 Scope  和ContentType可以组成一个资源流.即PROJECT 和CLASSES ,表示了主项目中java 编译成的class 组成的一个资源流,SUB_PROJECTS 和 CLASSES ,表示的是本地子项目中的java 编译的class 资源流.</p><h2 id="三-transform-的作用"><a href="#三-transform-的作用" class="headerlink" title="三 transform 的作用"></a>三 transform 的作用</h2><p>transform 是来处理和转换这些流的.<br>transform 中存在两种资源流,一种是会被消费掉.一种只是参与了转换过程.并不会被消费掉.  </p><p>资源流存储在一个资源池. transform 从这个资源池收集这两种流.然后经过一定的规则转换生成新的资源流放到这个池子里. 同时将未消耗的资源流也放回这个池子里去,下一个transform 重复之前的流程.  </p><h3 id="api"><a href="#api" class="headerlink" title="api"></a>api</h3><p><code>Set&lt;ContentType&gt; getInputTypes()</code>:定义了你要处理的类型;<br><code>Set&lt;Scope&gt; getScopes()</code>:你要消耗资源流的范围;<br><code>Set&lt;Scope&gt; getReferencedScopes()</code>:转换过程中需要资源流的范围,在转换过程中不会被消耗,转换结束后, 会将资源流放回资源池去.<br><code>Set&lt;ContentType&gt; getOutputTypes()</code> 转换输出类型,默认是getInputTypes()  </p><h2 id="四-transform工作原理"><a href="#四-transform工作原理" class="headerlink" title="四 transform工作原理"></a>四 transform工作原理</h2><p>对外注册api:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">android.registerTransform(new XTransform());</span><br><span class="line">android.registerTransform(new XTransform(), dependencies)</span><br></pre></td></tr></table></figure></p><p>内部注册api<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TransformManager.addTransform();</span><br></pre></td></tr></table></figure></p><p>gradle 会收集一些原始的资源流, 同时这些流可能还会有依赖task的,类似前置任务,比如说PROJECT 的CLASSES 需要依赖avac 的task 的任务.NATIVE_LIBS 需要依赖于ndk 的task ,这个也是可以理解的, 因为project 的class 产生是需要通过javac 的任务生成的. 同时如果你的transform 需要处理或者依赖这些资源流, 会被自动的被依赖上这些task.当gradle 收集完原始的资源流以后, gradle 开始注册transform,因为注册的transform是有顺序的,所以先注册的先处理资源流, 如果先注册的transform 消耗掉的资源.后续的transform 就无法处理了, 但是他可以处理前面transform 生成的资源流.(比方说有一个transformA 消耗了PROJECT 的CLASSES.同时经过转换生成了PROJECT 的CLASSES, 那下一个transformB如果要消耗和处理PROJECT 的CLASSES,那么他处理的是就是transformA转换的资源流而不是gradle收集资源流.)  </p><p>自定义的transform之所以不能处理Dex 文件,是因为Dex 是由DexTransform|MultiDexTransform 由CLASSES 转成dex, 而自定义的transform 的注册在DexTransform|MultiDexTransform 之前,意思是自定义transform 注册的时候资源池里面还没dex的资源流.所以它无法处理Dex;  </p><h2 id="五-再讲资源流"><a href="#五-再讲资源流" class="headerlink" title="五 再讲资源流"></a>五 再讲资源流</h2><p>说是流,其实是一个个文件的集合.原始的资源流是在Configuration 阶段中,收集成一个个文件的聚合. 而transform 生成的资源流是怎样的是,它其实是一个根目录(build/transforms/xxx)为基准,根据规则生成的一个个目录. gradle 通过TransformOutputProvider这个类帮我们简化这个步骤.  </p><h2 id="六-尾巴"><a href="#六-尾巴" class="headerlink" title="六 尾巴"></a>六 尾巴</h2><ol><li>虽然从getReferencedScopes() 可以获取到资源流,但是你不应该对这个资源流做任何的改动.因为这个可能作为下一个transform的输入. 同时这个资源流里面的文件.可能是一个全局的文件. 你的更改,将不仅仅影响到这个工程.甚至其他工程.   </li></ol><ul><li>颗粒太大:处理是的流,无法处理流里面的单个文件. 就是说如果你只是想单单处理某个文件. 你将不得不处理整个流. 造成多余的copy,以及磁盘的占用.   </li><li>自定义的transform 无法处理Dex   </li><li>自定义的transform 无法使用自定义ContentType</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;http://dim.red&quot;&gt;dim.red&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;环境: android gradle 2.3 &lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://tools.android.com/tech-docs/new-build-system/t
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Gson 解析小技巧</title>
    <link href="http://dim.red/2016/05/27/gson-skill/"/>
    <id>http://dim.red/2016/05/27/gson-skill/</id>
    <published>2016-05-26T16:00:00.000Z</published>
    <updated>2018-08-25T08:43:17.049Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://dim.red">dim.red</a><br>解析 List 的时候官方的使用:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Dim&gt; dims=gson.fromJson(json,new TypeToken&lt;List&lt;Dim&gt;&gt;()&#123;&#125;.getType());</span><br></pre></td></tr></table></figure><p>使用TypeToken 匿名内部类的方式.获取到匿名内部类定义的泛型.<br><a id="more"></a></p><p>当我们封装一个工具类的时候,解析 List 的时候不可避免要传递一个 TypeToken 匿名内部类的进来.<br>有什么办法只传递<code>Dim</code> 而不用写很长的 TypeToken 呢?<br>方式其实很简单,就是为 Gson 构造一个正确的 Type 给它.</p><p>TypeFactory是一个工具类简单封装.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Created by dim on 16/5/27.</span><br><span class="line"> */</span><br><span class="line">public class TypeFactory &#123;</span><br><span class="line"></span><br><span class="line">    public static Type $List(Type type) &#123;</span><br><span class="line">        return $Gson$Types.newParameterizedTypeWithOwner(null, List.class, type);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Type $Set(Type type) &#123;</span><br><span class="line">        return $Gson$Types.newParameterizedTypeWithOwner(null, Set.class, type);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Type $HashMap(Type type, Type type2) &#123;</span><br><span class="line">        return $Gson$Types.newParameterizedTypeWithOwner(null, HashMap.class, type, type2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Type $Map(Type type, Type type2) &#123;</span><br><span class="line">        return $Gson$Types.newParameterizedTypeWithOwner(null, Map.class, type, type2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Type $Parameterized(Type ownerType, Type rawType, Type... typeArguments) &#123;</span><br><span class="line">        return $Gson$Types.newParameterizedTypeWithOwner(ownerType, rawType, typeArguments);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Type $Array(Type type) &#123;</span><br><span class="line">        return $Gson$Types.arrayOf(type);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Type $SubtypeOf(Type type) &#123;</span><br><span class="line">        return $Gson$Types.subtypeOf(type);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Type $SupertypeOf(Type type) &#123;</span><br><span class="line">        return $Gson$Types.supertypeOf(type);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Dim&gt; dims = gson.fromJson(json, TypeFactory.$List(Dim.class));</span><br></pre></td></tr></table></figure></p><p>再使用静态导入方法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import static com.dim.TypeFactory.*;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">List&lt;Dim&gt; dims = gson.fromJson(json, $List(Dim.class));</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>一些复杂的泛型<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">List&lt;Dim&gt; dims = gson.fromJson(json, $List(Dim.class));</span><br><span class="line">List&lt;List&lt;Dim&gt;&gt; dimss= gson.fromJson(json,$List($List(Dim.class)));</span><br><span class="line">Dim[] dimArray=gson.fromJson(json,$Array(Dim.class));</span><br><span class="line">Set&lt;Dim&gt; dimSet=gson.fromJson(json,$Set(Dim.class));</span><br><span class="line">Map&lt;String,Dim&gt; dimMap=gson.fromJson(json,$Map(String.class,Dim.class));</span><br><span class="line">Map&lt;String,List&lt;Dim&gt;&gt; dimsMap=gson.fromJson(json,$Map(String.class,$List(Dim.class)));</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://dim.red&quot;&gt;dim.red&lt;/a&gt;&lt;br&gt;解析 List 的时候官方的使用:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;List&amp;lt;Dim&amp;gt; dims=gson.fromJson(json,new TypeToken&amp;lt;List&amp;lt;Dim&amp;gt;&amp;gt;()&amp;#123;&amp;#125;.getType());&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;使用TypeToken 匿名内部类的方式.获取到匿名内部类定义的泛型.&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
